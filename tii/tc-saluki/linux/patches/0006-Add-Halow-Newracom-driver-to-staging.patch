From ab97fb7dde7a21abe6ac575611c92d0d11f518b1 Mon Sep 17 00:00:00 2001
From: Mika Joenpera <mika.joenpera@unikie.com>
Date: Mon, 12 Jun 2023 14:46:14 +0300
Subject: [PATCH] Add Halow Newracom driver to staging

Signed-off-by: Mika Joenpera <mika.joenpera@unikie.com>
---
 drivers/staging/Kconfig                 |    2 +
 drivers/staging/Makefile                |    1 +
 drivers/staging/nrc/Kconfig             |    8 +
 drivers/staging/nrc/Makefile            |  107 +
 drivers/staging/nrc/Makefile.11n.sdio   |  100 +
 drivers/staging/nrc/Makefile.halow.cspi |  100 +
 drivers/staging/nrc/compat.h            |   32 +
 drivers/staging/nrc/fastboot-cm0.h      |  394 +++
 drivers/staging/nrc/hif.c               | 1043 +++++++
 drivers/staging/nrc/mac80211-ext.c      |  186 ++
 drivers/staging/nrc/mac80211-ext.h      |   84 +
 drivers/staging/nrc/make_qsdk.sh        |   13 +
 drivers/staging/nrc/nrc-bd.c            |  827 +++++
 drivers/staging/nrc/nrc-bd.h            |   57 +
 drivers/staging/nrc/nrc-build-config.h  |  161 +
 drivers/staging/nrc/nrc-debug.c         |  708 +++++
 drivers/staging/nrc/nrc-debug.h         |   84 +
 drivers/staging/nrc/nrc-dump.c          |   72 +
 drivers/staging/nrc/nrc-dump.h          |   22 +
 drivers/staging/nrc/nrc-fw.c            |  364 +++
 drivers/staging/nrc/nrc-fw.h            |   68 +
 drivers/staging/nrc/nrc-hif-cspi.c      | 2325 ++++++++++++++
 drivers/staging/nrc/nrc-hif-cspi.h      |   23 +
 drivers/staging/nrc/nrc-hif-debug.c     |  121 +
 drivers/staging/nrc/nrc-hif-debug.h     |   38 +
 drivers/staging/nrc/nrc-hif-sdio.c      | 1108 +++++++
 drivers/staging/nrc/nrc-hif-sdio.h      |   23 +
 drivers/staging/nrc/nrc-hif-ssp.c       |  175 ++
 drivers/staging/nrc/nrc-hif-ssp.h       |   33 +
 drivers/staging/nrc/nrc-hif-uart.c      |  543 ++++
 drivers/staging/nrc/nrc-hif-uart.h      |   67 +
 drivers/staging/nrc/nrc-hif.h           |  426 +++
 drivers/staging/nrc/nrc-init.c          |  722 +++++
 drivers/staging/nrc/nrc-init.h          |   29 +
 drivers/staging/nrc/nrc-mac80211.c      | 3717 +++++++++++++++++++++++
 drivers/staging/nrc/nrc-mac80211.h      |  108 +
 drivers/staging/nrc/nrc-netlink.c       | 1744 +++++++++++
 drivers/staging/nrc/nrc-netlink.h       |  113 +
 drivers/staging/nrc/nrc-pm.c            |  683 +++++
 drivers/staging/nrc/nrc-recovery.c      |  112 +
 drivers/staging/nrc/nrc-recovery.h      |   33 +
 drivers/staging/nrc/nrc-ssp-dev.h       |   51 +
 drivers/staging/nrc/nrc-ssp.c           |  631 ++++
 drivers/staging/nrc/nrc-ssp.h           |   53 +
 drivers/staging/nrc/nrc-stats.c         |  479 +++
 drivers/staging/nrc/nrc-stats.h         |   48 +
 drivers/staging/nrc/nrc-trx.c           | 1199 ++++++++
 drivers/staging/nrc/nrc-vendor.h        |   72 +
 drivers/staging/nrc/nrc-wim-types.h     |  872 ++++++
 drivers/staging/nrc/nrc.h               |  501 +++
 drivers/staging/nrc/nrc.lds             |   16 +
 drivers/staging/nrc/wim.c               |  752 +++++
 drivers/staging/nrc/wim.h               |  183 ++
 53 files changed, 21433 insertions(+)
 create mode 100644 drivers/staging/nrc/Kconfig
 create mode 100755 drivers/staging/nrc/Makefile
 create mode 100755 drivers/staging/nrc/Makefile.11n.sdio
 create mode 100755 drivers/staging/nrc/Makefile.halow.cspi
 create mode 100755 drivers/staging/nrc/compat.h
 create mode 100755 drivers/staging/nrc/fastboot-cm0.h
 create mode 100755 drivers/staging/nrc/hif.c
 create mode 100755 drivers/staging/nrc/mac80211-ext.c
 create mode 100755 drivers/staging/nrc/mac80211-ext.h
 create mode 100755 drivers/staging/nrc/make_qsdk.sh
 create mode 100755 drivers/staging/nrc/nrc-bd.c
 create mode 100755 drivers/staging/nrc/nrc-bd.h
 create mode 100755 drivers/staging/nrc/nrc-build-config.h
 create mode 100755 drivers/staging/nrc/nrc-debug.c
 create mode 100755 drivers/staging/nrc/nrc-debug.h
 create mode 100755 drivers/staging/nrc/nrc-dump.c
 create mode 100755 drivers/staging/nrc/nrc-dump.h
 create mode 100755 drivers/staging/nrc/nrc-fw.c
 create mode 100755 drivers/staging/nrc/nrc-fw.h
 create mode 100644 drivers/staging/nrc/nrc-hif-cspi.c
 create mode 100644 drivers/staging/nrc/nrc-hif-cspi.h
 create mode 100644 drivers/staging/nrc/nrc-hif-debug.c
 create mode 100644 drivers/staging/nrc/nrc-hif-debug.h
 create mode 100644 drivers/staging/nrc/nrc-hif-sdio.c
 create mode 100644 drivers/staging/nrc/nrc-hif-sdio.h
 create mode 100644 drivers/staging/nrc/nrc-hif-ssp.c
 create mode 100644 drivers/staging/nrc/nrc-hif-ssp.h
 create mode 100644 drivers/staging/nrc/nrc-hif-uart.c
 create mode 100644 drivers/staging/nrc/nrc-hif-uart.h
 create mode 100755 drivers/staging/nrc/nrc-hif.h
 create mode 100644 drivers/staging/nrc/nrc-init.c
 create mode 100644 drivers/staging/nrc/nrc-init.h
 create mode 100644 drivers/staging/nrc/nrc-mac80211.c
 create mode 100644 drivers/staging/nrc/nrc-mac80211.h
 create mode 100644 drivers/staging/nrc/nrc-netlink.c
 create mode 100644 drivers/staging/nrc/nrc-netlink.h
 create mode 100644 drivers/staging/nrc/nrc-pm.c
 create mode 100644 drivers/staging/nrc/nrc-recovery.c
 create mode 100644 drivers/staging/nrc/nrc-recovery.h
 create mode 100644 drivers/staging/nrc/nrc-ssp-dev.h
 create mode 100644 drivers/staging/nrc/nrc-ssp.c
 create mode 100644 drivers/staging/nrc/nrc-ssp.h
 create mode 100644 drivers/staging/nrc/nrc-stats.c
 create mode 100644 drivers/staging/nrc/nrc-stats.h
 create mode 100644 drivers/staging/nrc/nrc-trx.c
 create mode 100644 drivers/staging/nrc/nrc-vendor.h
 create mode 100644 drivers/staging/nrc/nrc-wim-types.h
 create mode 100755 drivers/staging/nrc/nrc.h
 create mode 100644 drivers/staging/nrc/nrc.lds
 create mode 100644 drivers/staging/nrc/wim.c
 create mode 100755 drivers/staging/nrc/wim.h

diff --git a/drivers/staging/Kconfig b/drivers/staging/Kconfig
index a5a014ada746..8ee5b1914881 100644
--- a/drivers/staging/Kconfig
+++ b/drivers/staging/Kconfig
@@ -106,4 +106,6 @@ source "drivers/staging/emc2301/Kconfig"
 
 source "drivers/staging/max1726x/Kconfig"
 
+source "drivers/staging/nrc/Kconfig"
+
 endif # STAGING
diff --git a/drivers/staging/Makefile b/drivers/staging/Makefile
index 95c5c18ca118..18fcf99a262c 100644
--- a/drivers/staging/Makefile
+++ b/drivers/staging/Makefile
@@ -43,3 +43,4 @@ obj-$(CONFIG_QLGE)		+= qlge/
 obj-$(CONFIG_WFX)		+= wfx/
 obj-$(CONFIG_SENSORS_EMC2301)	+= emc2301/
 obj-$(CONFIG_BATTERY_MAX1726X)	+= max1726x/
+obj-$(CONFIG_NRC7292)		+= nrc/
diff --git a/drivers/staging/nrc/Kconfig b/drivers/staging/nrc/Kconfig
new file mode 100644
index 000000000000..eb8a858aa007
--- /dev/null
+++ b/drivers/staging/nrc/Kconfig
@@ -0,0 +1,8 @@
+
+config NRC7292
+	tristate "Newracom 802.11ah Wi-Fi halow driver (NRC7292)"
+	depends on MAC80211
+	depends on SPI
+	help
+		The Host Driver for Newracom 802.11ah Wi-Fi halow device (NRC7292)
+
diff --git a/drivers/staging/nrc/Makefile b/drivers/staging/nrc/Makefile
new file mode 100755
index 000000000000..741f9688ab0b
--- /dev/null
+++ b/drivers/staging/nrc/Makefile
@@ -0,0 +1,107 @@
+# SPDX-License-Identifier: GPL-2.0
+KDIR ?= /lib/modules/$(shell uname -r)/build
+CHECKPATCH ?= $(KDIR)/scripts/checkpatch.pl
+
+#include $(KDIR)/.config
+
+M_SRC = nrc
+
+obj-m += $(M_SRC).o
+$(M_SRC)-objs = \
+		nrc-mac80211.o \
+		nrc-trx.o \
+		nrc-init.o \
+		nrc-debug.o \
+		hif.o \
+		wim.o \
+		nrc-hif-debug.o \
+		nrc-hif-uart.o \
+		nrc-hif-ssp.o \
+		nrc-fw.o \
+		nrc-netlink.o \
+		nrc-ssp.o \
+		nrc-hif-cspi.o \
+		mac80211-ext.o \
+		nrc-stats.o \
+		nrc-pm.o \
+		nrc-dump.o \
+		nrc-hif-sdio.o \
+		nrc-bd.o \
+		nrc-recovery.o
+
+ccflags-y := \
+	-DDEBUG \
+	-DBUILD_UMAC_DRIVER \
+	-DCONFIG_NRC_HIF_CSPI \
+	-DENABLE_DYNAMIC_PS \
+	-DCONFIG_MAC80211_MESH
+	#-DENABLE_HW_RESET
+    #-DCONFIG_NRC_HIF_SDIO
+	#-DCONFIG_NRC_HIF_DEBUG \
+    #-DCONFIG_NRC_HIF_SDIO \
+	#-DCONFIG_NRC_HIF_UART \
+	#-DCONFIG_NRC_HIF_AH_UART \
+	#-DCONFIG_NRC_HIF_SSP
+
+ldflags-y += -T $(src)/nrc.lds
+
+
+ifeq ($(TESTMODE), y)
+ccflags-y += \
+		-DTEST_SELF_GENERATION
+endif
+
+#ccflags-y += -Wall -Werror -g
+ccflags-y += -Wall -Werror
+
+all: modules
+
+cleanall: clean all
+
+modules:
+	@echo $(NRCLINUXHOSTDIR)
+	@$(MAKE) -C $(KDIR) M=$$PWD modules
+
+modules_install:
+	@$(MAKE) -C $(KDIR) M=$$PWD modules_install
+
+install: modules
+	@sudo insmod $(M_SRC).ko
+
+test: modules
+	@sudo insmod $(M_SRC).ko
+	@sudo rmmod -f $(M_SRC)
+
+doxyfile.inc:
+	@echo INPUT         =  $(NRCLINUXHOSTDIR) > doxyfile.inc
+	@echo EXTRACT_ALL   = yes >> doxyfile.inc
+	@echo EXTRACT_STATIC = yes >> doxyfile.inc
+	@echo INLINE_SOURCES = yes >> doxyfile.inc
+	@echo HAVE_DOT = yes = yes >> doxyfile.inc
+
+doxy: doxyfile.inc
+	@doxygen doxyfile.inc
+
+clean:
+	@rm -f *.o
+	@rm -f *.ko
+	@rm -f .*.cmd
+	@rm -f *.mod *.mod.c
+	@rm -f modules.order
+	@rm -f Module.symvers
+	@rm -rf .tmp_versions
+	@rm -rf html
+	@rm -rf latex
+	@rm -f doxyfile.inc
+
+check: checkstyle
+
+checkstyle:
+	@$(CHECKPATCH) --root=$(KDIR) -file -terse --ignore=LINUX_VERSION_CODE -no-tree *.c *.h
+
+checkstyle2:
+	@if [ $$($(CHECKPATCH) --root=$(KDIR) -file --quiet -no-tree *.c *.h | awk '{if($$1 == "ERROR:") print $$1;}' | wc -l) -ne 0 ]; \
+	then \
+		echo >&2 "checkstyle2 error"; \
+		false; \
+	fi
diff --git a/drivers/staging/nrc/Makefile.11n.sdio b/drivers/staging/nrc/Makefile.11n.sdio
new file mode 100755
index 000000000000..136f21236b4a
--- /dev/null
+++ b/drivers/staging/nrc/Makefile.11n.sdio
@@ -0,0 +1,100 @@
+ifndef $(NRCLINUXHOSTDIR)
+#$(warning WARNING: NRCLINUXHOSTDIR is not defined.)
+NRCLINUXHOSTDIR = $(PWD)
+else
+WIRESHARKDIR= $(WIRESHARKDIR)/driver
+endif
+
+KDIR ?= /lib/modules/$(shell uname -r)/build
+CHECKPATCH ?= $(KDIR)/scripts/checkpatch.pl
+
+include $(KDIR)/.config
+
+M_SRC = nrc
+
+obj-m += $(M_SRC).o
+$(M_SRC)-objs = \
+		nrc-mac80211.o \
+		nrc-trx.o \
+		nrc-init.o \
+		nrc-debug.o \
+		hif.o \
+		wim.o \
+		nrc-hif-debug.o \
+		nrc-hif-uart.o \
+		nrc-hif-ssp.o \
+		nrc-fw.o \
+		nrc-netlink.o \
+		nrc-ssp.o \
+		nrc-hif-cspi.o \
+		mac80211-ext.o \
+		nrc-pm.o \
+		nrc-dump.o \
+		nrc-hif-sdio.o
+
+ccflags-y := \
+	-DDEBUG \
+	-DBUILD_UMAC_DRIVER \
+    -DCONFIG_NRC_HIF_SDIO
+
+ldflags-y += -T$(M)/nrc.lds
+
+
+ifeq ($(TESTMODE), y)
+ccflags-y += \
+		-DTEST_SELF_GENERATION
+endif
+
+ccflags-y += -Wall -Werror
+
+all: modules
+
+cleanall: clean all
+
+modules:
+	@echo $(NRCLINUXHOSTDIR)
+	@$(MAKE) -C $(KDIR) M=$$PWD modules
+
+modules_install:
+	@$(MAKE) -C $(KDIR) M=$$PWD modules_install
+
+install: modules
+	@sudo insmod $(M_SRC).ko
+
+test: modules
+	@sudo insmod $(M_SRC).ko
+	@sudo rmmod -f $(M_SRC)
+
+doxyfile.inc:
+	@echo INPUT         =  $(NRCLINUXHOSTDIR) > doxyfile.inc
+	@echo EXTRACT_ALL   = yes >> doxyfile.inc
+	@echo EXTRACT_STATIC = yes >> doxyfile.inc
+	@echo INLINE_SOURCES = yes >> doxyfile.inc
+	@echo HAVE_DOT = yes = yes >> doxyfile.inc
+
+doxy: doxyfile.inc
+	@doxygen doxyfile.inc
+
+clean:
+	@rm -f *.o
+	@rm -f *.ko
+	@rm -f \.*.cmd
+	@rm -f *.mod.c
+	@rm -f modules.order
+	@rm -f Module.symvers
+	@rm -rf .tmp_versions
+	@rm -rf html
+	@rm -rf latex
+	@rm -f doxyfile.inc
+
+check: checkstyle
+
+checkstyle:
+	@$(CHECKPATCH) --root=$(KDIR) -file -terse --ignore=LINUX_VERSION_CODE -no-tree *.c *.h
+
+checkstyle2:
+	@if [ $$($(CHECKPATCH) --root=$(KDIR) -file --quiet -no-tree *.c *.h | awk '{if($$1 == "ERROR:") print $$1;}' | wc -l) -ne 0 ]; \
+	then \
+		echo >&2 "checkstyle2 error"; \
+		false; \
+	fi
diff --git a/drivers/staging/nrc/Makefile.halow.cspi b/drivers/staging/nrc/Makefile.halow.cspi
new file mode 100755
index 000000000000..4a4ab50ea5bd
--- /dev/null
+++ b/drivers/staging/nrc/Makefile.halow.cspi
@@ -0,0 +1,100 @@
+ifndef $(NRCLINUXHOSTDIR)
+#$(warning WARNING: NRCLINUXHOSTDIR is not defined.)
+NRCLINUXHOSTDIR = $(PWD)
+else
+WIRESHARKDIR= $(WIRESHARKDIR)/driver
+endif
+
+KDIR ?= /lib/modules/$(shell uname -r)/build
+CHECKPATCH ?= $(KDIR)/scripts/checkpatch.pl
+
+include $(KDIR)/.config
+
+M_SRC = nrc
+
+obj-m += $(M_SRC).o
+$(M_SRC)-objs = \
+		nrc-mac80211.o \
+		nrc-trx.o \
+		nrc-init.o \
+		nrc-debug.o \
+		hif.o \
+		wim.o \
+		nrc-hif-debug.o \
+		nrc-hif-uart.o \
+		nrc-hif-ssp.o \
+		nrc-fw.o \
+		nrc-netlink.o \
+		nrc-ssp.o \
+		nrc-hif-cspi.o \
+		mac80211-ext.o \
+		nrc-pm.o \
+		nrc-dump.o \
+		nrc-hif-sdio.o
+
+ccflags-y := \
+	-DDEBUG \
+	-DBUILD_UMAC_DRIVER \
+    -DCONFIG_NRC_HIF_CSPI
+
+ldflags-y += -T$(M)/nrc.lds
+
+
+ifeq ($(TESTMODE), y)
+ccflags-y += \
+		-DTEST_SELF_GENERATION
+endif
+
+ccflags-y += -Wall -Werror
+
+all: modules
+
+cleanall: clean all
+
+modules:
+	@echo $(NRCLINUXHOSTDIR)
+	@$(MAKE) -C $(KDIR) M=$$PWD modules
+
+modules_install:
+	@$(MAKE) -C $(KDIR) M=$$PWD modules_install
+
+install: modules
+	@sudo insmod $(M_SRC).ko
+
+test: modules
+	@sudo insmod $(M_SRC).ko
+	@sudo rmmod -f $(M_SRC)
+
+doxyfile.inc:
+	@echo INPUT         =  $(NRCLINUXHOSTDIR) > doxyfile.inc
+	@echo EXTRACT_ALL   = yes >> doxyfile.inc
+	@echo EXTRACT_STATIC = yes >> doxyfile.inc
+	@echo INLINE_SOURCES = yes >> doxyfile.inc
+	@echo HAVE_DOT = yes = yes >> doxyfile.inc
+
+doxy: doxyfile.inc
+	@doxygen doxyfile.inc
+
+clean:
+	@rm -f *.o
+	@rm -f *.ko
+	@rm -f \.*.cmd
+	@rm -f *.mod.c
+	@rm -f modules.order
+	@rm -f Module.symvers
+	@rm -rf .tmp_versions
+	@rm -rf html
+	@rm -rf latex
+	@rm -f doxyfile.inc
+
+check: checkstyle
+
+checkstyle:
+	@$(CHECKPATCH) --root=$(KDIR) -file -terse --ignore=LINUX_VERSION_CODE -no-tree *.c *.h
+
+checkstyle2:
+	@if [ $$($(CHECKPATCH) --root=$(KDIR) -file --quiet -no-tree *.c *.h | awk '{if($$1 == "ERROR:") print $$1;}' | wc -l) -ne 0 ]; \
+	then \
+		echo >&2 "checkstyle2 error"; \
+		false; \
+	fi
diff --git a/drivers/staging/nrc/compat.h b/drivers/staging/nrc/compat.h
new file mode 100755
index 000000000000..67496171b77c
--- /dev/null
+++ b/drivers/staging/nrc/compat.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef __COMPAT_H__
+#define __COMPAT_H__
+
+#include <net/mac80211.h>
+#include "nrc.h"
+#include "wim.h"
+
+#if !defined(ieee80211_hw_set)
+#define ieee80211_hw_set(hw, flg) ((hw)->flags |= IEEE80211_HW_##flg)
+#endif
+
+#if !defined(CONFIG_SUPPORT_BEACON_TEMPLATE)
+#define ieee80211_beacon_get_template(hw, vif, N) ieee80211_beacon_get(hw, vif)
+#endif
+
+#endif
diff --git a/drivers/staging/nrc/fastboot-cm0.h b/drivers/staging/nrc/fastboot-cm0.h
new file mode 100755
index 000000000000..28090fec1225
--- /dev/null
+++ b/drivers/staging/nrc/fastboot-cm0.h
@@ -0,0 +1,394 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+const unsigned char fb_cm0[] = {
+	0x00, 0x50, 0x4b, 0x10, 0xf9, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00,
+	0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00,
+	0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00,
+	0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00,
+	0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00,
+	0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00,
+	0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00,
+	0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00,
+	0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00,
+	0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00,
+	0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00,
+	0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00,
+	0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00,
+	0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00,
+	0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00,
+	0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00,
+	0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00,
+	0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00,
+	0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00,
+	0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00,
+	0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00,
+	0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00, 0xf5, 0x0e, 0x00, 0x00,
+	0xf5, 0x0e, 0x00, 0x00, 0x05, 0x4b, 0x80, 0x00, 0x7b, 0x44, 0xc3, 0x58,
+	0x00, 0x20, 0x9a, 0x69, 0x92, 0x06, 0x01, 0xd4, 0x19, 0x60, 0x01, 0x30,
+	0x70, 0x47, 0xc0, 0x46, 0x84, 0x0f, 0x00, 0x00, 0x05, 0x4b, 0x80, 0x00,
+	0x7b, 0x44, 0xc3, 0x58, 0x00, 0x20, 0x9a, 0x69, 0xd2, 0x06, 0x02, 0xd4,
+	0x1b, 0x68, 0x01, 0x30, 0x0b, 0x70, 0x70, 0x47, 0x68, 0x0f, 0x00, 0x00,
+	0x70, 0xb5, 0x05, 0x00, 0x0c, 0x00, 0x21, 0x78, 0x00, 0x29, 0x06, 0xd0,
+	0x28, 0x00, 0xff, 0xf7, 0xdb, 0xff, 0x43, 0x1e, 0x98, 0x41, 0x24, 0x18,
+	0xf5, 0xe7, 0x70, 0xbd, 0x06, 0x4b, 0x80, 0x00, 0x7b, 0x44, 0xc3, 0x58,
+	0x03, 0x20, 0x9a, 0x6c, 0x00, 0x29, 0x01, 0xd0, 0x02, 0x43, 0x00, 0xe0,
+	0x82, 0x43, 0x9a, 0x64, 0x70, 0x47, 0xc0, 0x46, 0x30, 0x0f, 0x00, 0x00,
+	0xf0, 0xb5, 0x00, 0x26, 0x05, 0x00, 0x85, 0xb0, 0x0b, 0xab, 0x1f, 0x78,
+	0x0c, 0xab, 0x1b, 0x78, 0x01, 0x92, 0x02, 0x93, 0x1e, 0x4b, 0x82, 0x00,
+	0x7b, 0x44, 0xd4, 0x58, 0x1d, 0x4b, 0x31, 0x00, 0x26, 0x63, 0x63, 0x64,
+	0xff, 0xf7, 0xdc, 0xff, 0x28, 0x00, 0x10, 0x30, 0xc0, 0xb2, 0x00, 0xf0,
+	0x99, 0xf8, 0x01, 0x9b, 0x05, 0x00, 0x1b, 0x01, 0x19, 0x00, 0x00, 0x93,
+	0x00, 0xf0, 0xd0, 0xfe, 0x00, 0x99, 0x03, 0x90, 0x28, 0x00, 0x00, 0xf0,
+	0x51, 0xff, 0xc8, 0x00, 0x01, 0x99, 0x00, 0xf0, 0xc7, 0xfe, 0x01, 0x22,
+	0x43, 0x08, 0x10, 0x40, 0xc0, 0x18, 0x03, 0x9b, 0x63, 0x62, 0x02, 0x9b,
+	0xa0, 0x62, 0xb3, 0x42, 0x05, 0xd0, 0x93, 0x42, 0x07, 0xd1, 0x70, 0x23,
+	0xe3, 0x62, 0xa6, 0x63, 0x03, 0xe0, 0x60, 0x23, 0xe3, 0x62, 0x50, 0x3b,
+	0xa3, 0x63, 0x00, 0x2f, 0x03, 0xd0, 0x01, 0x2f, 0x03, 0xd1, 0x05, 0x4b,
+	0x00, 0xe0, 0x05, 0x4b, 0x23, 0x63, 0x05, 0xb0, 0xf0, 0xbd, 0xc0, 0x46,
+	0xfc, 0x0e, 0x00, 0x00, 0xff, 0x07, 0x00, 0x00, 0x01, 0xc3, 0x00, 0x00,
+	0x01, 0x03, 0x00, 0x00, 0x02, 0x68, 0x01, 0x4b, 0x9a, 0x60, 0x70, 0x47,
+	0x00, 0x50, 0x00, 0x40, 0x01, 0x4b, 0x9b, 0x68, 0x03, 0x60, 0x70, 0x47,
+	0x00, 0x50, 0x00, 0x40, 0x02, 0x4b, 0x80, 0x00, 0xc3, 0x58, 0x0b, 0x60,
+	0x70, 0x47, 0xc0, 0x46, 0x00, 0x58, 0x00, 0x40, 0x0a, 0x68, 0x02, 0x4b,
+	0x80, 0x00, 0xc2, 0x50, 0x70, 0x47, 0xc0, 0x46, 0x00, 0x58, 0x00, 0x40,
+	0x02, 0x4b, 0x18, 0x68, 0x80, 0x07, 0x80, 0x0f, 0x70, 0x47, 0xc0, 0x46,
+	0x00, 0xf0, 0x00, 0x40, 0x03, 0x00, 0x10, 0xb5, 0x00, 0x20, 0x07, 0x2b,
+	0x2e, 0xd8, 0x18, 0x00, 0x00, 0xf0, 0x6a, 0xfe, 0x04, 0x06, 0x0d, 0x0f,
+	0x18, 0x1a, 0x21, 0x24, 0x14, 0x48, 0x25, 0xe0, 0x14, 0x4b, 0x13, 0x48,
+	0x59, 0x68, 0x89, 0x00, 0x89, 0x0e, 0x01, 0x31, 0x07, 0xe0, 0x12, 0x48,
+	0x1c, 0xe0, 0x10, 0x4b, 0x10, 0x48, 0x59, 0x68, 0x89, 0x02, 0x89, 0x0e,
+	0x01, 0x31, 0x00, 0xf0, 0x5d, 0xfe, 0x13, 0xe0, 0x0d, 0x48, 0x11, 0xe0,
+	0x0a, 0x4b, 0x0c, 0x48, 0x59, 0x68, 0x89, 0x04, 0x89, 0x0e, 0x01, 0x31,
+	0xf3, 0xe7, 0x80, 0x20, 0x00, 0x02, 0x07, 0xe0, 0x80, 0x20, 0x05, 0x4b,
+	0x00, 0x02, 0x5b, 0x68, 0x9b, 0x06, 0x9b, 0x0e, 0x01, 0x33, 0xd8, 0x40,
+	0x10, 0xbd, 0xc0, 0x46, 0x00, 0x24, 0xf4, 0x00, 0x00, 0x10, 0x00, 0x40,
+	0x00, 0xd8, 0xb8, 0x05, 0x00, 0x48, 0xe8, 0x01, 0x70, 0xb5, 0x08, 0x30,
+	0x06, 0x4d, 0x84, 0x00, 0x60, 0x59, 0x00, 0x01, 0x00, 0x0f, 0xff, 0xf7,
+	0xb9, 0xff, 0x61, 0x59, 0x09, 0x05, 0x09, 0x0d, 0x01, 0x31, 0x00, 0xf0,
+	0x2f, 0xfe, 0x70, 0xbd, 0x00, 0x10, 0x00, 0x40, 0x0f, 0x21, 0x03, 0x4a,
+	0x08, 0x40, 0x13, 0x68, 0x8b, 0x43, 0x18, 0x43, 0x10, 0x60, 0x70, 0x47,
+	0x00, 0x10, 0x00, 0x40, 0x14, 0x4b, 0x02, 0x00, 0x18, 0x68, 0x00, 0xb5,
+	0x00, 0x07, 0x00, 0x0f, 0x01, 0x38, 0x06, 0x28, 0x1e, 0xd8, 0x00, 0xf0,
+	0x0d, 0xfe, 0x04, 0x1d, 0x0a, 0x1d, 0x10, 0x1d, 0x17, 0x00, 0x3f, 0x21,
+	0x0a, 0x40, 0x11, 0x06, 0x58, 0x68, 0x0c, 0x4a, 0x0a, 0xe0, 0x3f, 0x21,
+	0x0a, 0x40, 0x11, 0x04, 0x58, 0x68, 0x0a, 0x4a, 0x04, 0xe0, 0x3f, 0x21,
+	0x0a, 0x40, 0x11, 0x02, 0x58, 0x68, 0x08, 0x4a, 0x02, 0x40, 0x03, 0xe0,
+	0x3f, 0x20, 0x59, 0x68, 0x02, 0x40, 0x81, 0x43, 0x0a, 0x43, 0x5a, 0x60,
+	0x00, 0xbd, 0xc0, 0x46, 0x00, 0x10, 0x00, 0x40, 0xff, 0xff, 0xff, 0xc0,
+	0xff, 0xff, 0xc0, 0xff, 0xff, 0xc0, 0xff, 0xff, 0x01, 0x20, 0x70, 0x47,
+	0x30, 0xb5, 0x00, 0x28, 0x17, 0xd0, 0x01, 0x28, 0x2c, 0xd1, 0x18, 0x4d,
+	0x01, 0x40, 0x6c, 0x68, 0x02, 0x40, 0x84, 0x43, 0x21, 0x43, 0x02, 0x24,
+	0x18, 0x40, 0x10, 0x23, 0x69, 0x60, 0x69, 0x68, 0x52, 0x00, 0xa1, 0x43,
+	0x0a, 0x43, 0x6a, 0x60, 0x6a, 0x68, 0x00, 0x01, 0x9a, 0x43, 0x13, 0x00,
+	0x03, 0x43, 0x6b, 0x60, 0x18, 0xe0, 0x01, 0x24, 0x0d, 0x4d, 0x21, 0x40,
+	0x68, 0x68, 0x22, 0x40, 0xa0, 0x43, 0x01, 0x43, 0x02, 0x20, 0xa2, 0x40,
+	0x1c, 0x40, 0x10, 0x23, 0x69, 0x60, 0x69, 0x68, 0x81, 0x43, 0x0a, 0x43,
+	0x6a, 0x60, 0x6a, 0x68, 0x20, 0x01, 0x9a, 0x43, 0x14, 0x00, 0x04, 0x43,
+	0x6c, 0x60, 0x01, 0xe0, 0x03, 0x4b, 0x1b, 0x68, 0x30, 0xbd, 0xc0, 0x46,
+	0x00, 0x02, 0x09, 0x40, 0x00, 0x01, 0x09, 0x40, 0x48, 0x41, 0x08, 0x40,
+	0x30, 0xb5, 0x00, 0x28, 0x16, 0xd0, 0x01, 0x28, 0x2a, 0xd1, 0x17, 0x4d,
+	0x01, 0x40, 0xac, 0x68, 0xdb, 0x07, 0x84, 0x43, 0x10, 0x40, 0x42, 0x00,
+	0x02, 0x20, 0x21, 0x43, 0xa9, 0x60, 0xa9, 0x68, 0x81, 0x43, 0x08, 0x00,
+	0x10, 0x43, 0xa8, 0x60, 0xaa, 0x68, 0x52, 0x00, 0x52, 0x08, 0x13, 0x43,
+	0xab, 0x60, 0x17, 0xe0, 0x01, 0x24, 0x0d, 0x4d, 0x21, 0x40, 0xa8, 0x68,
+	0xdb, 0x07, 0xa0, 0x43, 0x01, 0x43, 0xa9, 0x60, 0x02, 0x21, 0xa8, 0x68,
+	0x14, 0x40, 0x88, 0x43, 0x62, 0x00, 0x04, 0x00, 0x14, 0x43, 0xac, 0x60,
+	0xaa, 0x68, 0x52, 0x00, 0x52, 0x08, 0x1a, 0x43, 0xaa, 0x60, 0x01, 0xe0,
+	0x03, 0x4b, 0x1b, 0x68, 0x30, 0xbd, 0xc0, 0x46, 0x00, 0x02, 0x09, 0x40,
+	0x00, 0x01, 0x09, 0x40, 0x48, 0x41, 0x08, 0x40, 0x00, 0x28, 0x03, 0xd0,
+	0x01, 0x28, 0x09, 0xd1, 0x06, 0x4a, 0x00, 0xe0, 0x06, 0x4a, 0x53, 0x68,
+	0xc9, 0x07, 0x5b, 0x00, 0x5b, 0x08, 0x19, 0x43, 0x51, 0x60, 0x01, 0xe0,
+	0x03, 0x4b, 0x1b, 0x68, 0x70, 0x47, 0xc0, 0x46, 0x00, 0x02, 0x09, 0x40,
+	0x00, 0x01, 0x09, 0x40, 0x48, 0x41, 0x08, 0x40, 0x00, 0x28, 0x06, 0xd0,
+	0x01, 0x28, 0x0a, 0xd1, 0x06, 0x4a, 0x13, 0x68, 0x18, 0x43, 0x10, 0x60,
+	0x07, 0xe0, 0x01, 0x21, 0x04, 0x4a, 0x13, 0x68, 0x0b, 0x43, 0x13, 0x60,
+	0x01, 0xe0, 0x03, 0x4b, 0x1b, 0x68, 0x70, 0x47, 0x00, 0x02, 0x09, 0x40,
+	0x00, 0x01, 0x09, 0x40, 0x48, 0x41, 0x08, 0x40, 0x30, 0xb5, 0x03, 0xac,
+	0x25, 0x78, 0x00, 0x28, 0x0a, 0xd0, 0x01, 0x28, 0x22, 0xd1, 0x13, 0x4c,
+	0x92, 0x08, 0x21, 0x61, 0x61, 0x69, 0x09, 0x0c, 0x09, 0x04, 0x0a, 0x43,
+	0x62, 0x61, 0x08, 0xe0, 0x01, 0x20, 0x0f, 0x4c, 0x92, 0x08, 0x21, 0x61,
+	0x61, 0x69, 0x09, 0x0c, 0x09, 0x04, 0x11, 0x43, 0x61, 0x61, 0x02, 0x00,
+	0x61, 0x69, 0x9a, 0x43, 0x0a, 0x4b, 0xd2, 0x06, 0x0b, 0x40, 0x13, 0x43,
+	0x63, 0x61, 0x63, 0x69, 0xc0, 0x22, 0x00, 0x2d, 0x00, 0xd1, 0x80, 0x22,
+	0x12, 0x06, 0x13, 0x43, 0x63, 0x61, 0x02, 0xe0, 0x00, 0x20, 0x04, 0x4b,
+	0x1b, 0x68, 0x30, 0xbd, 0x00, 0x02, 0x09, 0x40, 0x00, 0x01, 0x09, 0x40,
+	0xff, 0xff, 0xff, 0xf7, 0x48, 0x41, 0x08, 0x40, 0x00, 0x28, 0x03, 0xd0,
+	0x01, 0x28, 0x06, 0xd1, 0x05, 0x4b, 0x00, 0xe0, 0x05, 0x4b, 0x98, 0x69,
+	0x80, 0x02, 0x80, 0x0e, 0x03, 0xe0, 0x01, 0x20, 0x03, 0x4b, 0x40, 0x42,
+	0x1b, 0x68, 0x70, 0x47, 0x00, 0x02, 0x09, 0x40, 0x00, 0x01, 0x09, 0x40,
+	0x48, 0x41, 0x08, 0x40, 0x01, 0x20, 0x70, 0x47, 0x09, 0x4b, 0x80, 0x00,
+	0x7b, 0x44, 0xc0, 0x58, 0x01, 0x23, 0x10, 0xb5, 0x04, 0x68, 0x1a, 0x40,
+	0x9c, 0x43, 0x0b, 0x40, 0x59, 0x00, 0x02, 0x23, 0x22, 0x43, 0x02, 0x60,
+	0x02, 0x68, 0x9a, 0x43, 0x13, 0x00, 0x0b, 0x43, 0x03, 0x60, 0x10, 0xbd,
+	0x34, 0x0b, 0x00, 0x00, 0x02, 0x4b, 0x80, 0x00, 0x7b, 0x44, 0xc3, 0x58,
+	0x99, 0x60, 0x70, 0x47, 0x08, 0x0b, 0x00, 0x00, 0x02, 0x4b, 0x80, 0x00,
+	0x7b, 0x44, 0xc3, 0x58, 0x98, 0x68, 0x70, 0x47, 0xf8, 0x0a, 0x00, 0x00,
+	0x01, 0x21, 0x04, 0x4b, 0x80, 0x00, 0x7b, 0x44, 0xc2, 0x58, 0xd3, 0x68,
+	0x0b, 0x43, 0xd3, 0x60, 0x70, 0x47, 0xc0, 0x46, 0xe6, 0x0a, 0x00, 0x00,
+	0x03, 0x4b, 0x80, 0x00, 0x7b, 0x44, 0xc3, 0x58, 0x18, 0x69, 0x00, 0x03,
+	0x00, 0x0f, 0x70, 0x47, 0xd0, 0x0a, 0x00, 0x00, 0x10, 0xb5, 0x03, 0x4b,
+	0x01, 0x00, 0x7b, 0x44, 0x18, 0x68, 0xff, 0xf7, 0x8d, 0xfd, 0x10, 0xbd,
+	0x52, 0x1a, 0x4b, 0x10, 0x10, 0xb5, 0x03, 0x4b, 0x01, 0x00, 0x7b, 0x44,
+	0x18, 0x68, 0xff, 0xf7, 0x91, 0xfd, 0x10, 0xbd, 0x3e, 0x1a, 0x4b, 0x10,
+	0x09, 0x4b, 0x0a, 0x4a, 0x0a, 0x49, 0x18, 0x68, 0x7a, 0x44, 0x88, 0x42,
+	0x0a, 0xd1, 0x09, 0x49, 0x5b, 0x68, 0x52, 0x58, 0x13, 0x60, 0x08, 0x48,
+	0x00, 0x68, 0x01, 0x68, 0x8d, 0x46, 0x04, 0x30, 0x01, 0x68, 0x8f, 0x46,
+	0x70, 0x47, 0xc0, 0x46, 0xf0, 0xbf, 0x4b, 0x10, 0x18, 0x0b, 0x00, 0x00,
+	0x52, 0x77, 0x65, 0x4e, 0x0c, 0x00, 0x00, 0x00, 0x48, 0x20, 0x4b, 0x10,
+	0x70, 0x47, 0x70, 0x47, 0x70, 0xb5, 0x03, 0x78, 0x04, 0x00, 0x27, 0x2b,
+	0x32, 0xd0, 0x26, 0xd8, 0x23, 0x2b, 0x62, 0xd1, 0x02, 0x7a, 0xc3, 0x79,
+	0x12, 0x02, 0x1a, 0x43, 0x03, 0x79, 0xc6, 0x78, 0x40, 0x79, 0x1b, 0x02,
+	0x33, 0x43, 0x00, 0x04, 0x1d, 0x00, 0x03, 0x00, 0xa0, 0x79, 0x2b, 0x43,
+	0x00, 0x06, 0x18, 0x43, 0x00, 0xf0, 0xc4, 0xfb, 0x21, 0x7a, 0xe3, 0x79,
+	0x09, 0x02, 0x19, 0x43, 0x23, 0x79, 0xe5, 0x78, 0x60, 0x79, 0x1b, 0x02,
+	0x2b, 0x43, 0x00, 0x04, 0x1a, 0x00, 0x03, 0x00, 0xa0, 0x79, 0x13, 0x43,
+	0x00, 0x06, 0x18, 0x43, 0x00, 0xf0, 0xbe, 0xfb, 0x3d, 0xe0, 0x2b, 0x2b,
+	0x2d, 0xd0, 0x32, 0x2b, 0x39, 0xd1, 0x00, 0xf0, 0xe4, 0xfb, 0x03, 0x21,
+	0x01, 0x20, 0x00, 0xf0, 0xe7, 0xfc, 0x32, 0xe0, 0x02, 0x7a, 0xc3, 0x79,
+	0x12, 0x02, 0x1a, 0x43, 0x03, 0x79, 0xc6, 0x78, 0x40, 0x79, 0x1b, 0x02,
+	0x33, 0x43, 0x00, 0x04, 0x1d, 0x00, 0x03, 0x00, 0xa0, 0x79, 0x2b, 0x43,
+	0x00, 0x06, 0x18, 0x43, 0x00, 0xf0, 0xad, 0xfb, 0x21, 0x7a, 0xe3, 0x79,
+	0x09, 0x02, 0x19, 0x43, 0x23, 0x79, 0xe5, 0x78, 0x60, 0x79, 0x1b, 0x02,
+	0x2b, 0x43, 0x00, 0x04, 0x1a, 0x00, 0x03, 0x00, 0xa0, 0x79, 0x13, 0x43,
+	0x00, 0x06, 0x18, 0x43, 0x00, 0xf0, 0xa7, 0xfb, 0x0d, 0xe0, 0x03, 0x79,
+	0xc1, 0x78, 0x40, 0x79, 0x1b, 0x02, 0x0b, 0x43, 0x00, 0x04, 0x1a, 0x00,
+	0x03, 0x00, 0xa0, 0x79, 0x13, 0x43, 0x00, 0x06, 0x18, 0x43, 0x00, 0xf0,
+	0xa7, 0xfb, 0x01, 0x20, 0x70, 0xbd, 0x00, 0x00, 0xf7, 0xb5, 0x04, 0x00,
+	0x26, 0x48, 0x01, 0xaa, 0x78, 0x44, 0x0e, 0x00, 0x69, 0x46, 0x00, 0xf0,
+	0xd7, 0xfb, 0x00, 0x99, 0xcd, 0x78, 0x4b, 0x78, 0x2d, 0x06, 0x1b, 0x02,
+	0x1d, 0x43, 0x0b, 0x78, 0x0f, 0x79, 0x1d, 0x43, 0x4b, 0x79, 0x88, 0x79,
+	0x1b, 0x02, 0x3b, 0x43, 0x00, 0x04, 0x1a, 0x00, 0x03, 0x00, 0xc8, 0x79,
+	0x13, 0x43, 0x00, 0x06, 0x18, 0x43, 0x00, 0x2c, 0x02, 0xd1, 0x19, 0x4b,
+	0x7b, 0x44, 0x18, 0x60, 0x4b, 0x7a, 0x0a, 0x7a, 0x1b, 0x02, 0x13, 0x43,
+	0x8a, 0x7a, 0x1f, 0x00, 0x12, 0x04, 0x13, 0x00, 0xca, 0x7a, 0x3b, 0x43,
+	0x12, 0x06, 0x1a, 0x43, 0x0c, 0x31, 0x00, 0xf0, 0xd7, 0xfb, 0x00, 0x2e,
+	0x02, 0xd0, 0xe0, 0xb2, 0xff, 0xf7, 0x28, 0xff, 0x00, 0x2d, 0x16, 0xd0,
+	0x0d, 0x4b, 0x03, 0x24, 0x7b, 0x44, 0x19, 0x68, 0x82, 0x23, 0x5b, 0x05,
+	0x99, 0x42, 0x05, 0xd0, 0xe0, 0x23, 0x1b, 0x06, 0xc9, 0x18, 0x4b, 0x1e,
+	0x99, 0x41, 0x0c, 0x19, 0x07, 0x48, 0x21, 0x00, 0x78, 0x44, 0xff, 0xf7,
+	0x45, 0xff, 0x21, 0x00, 0x01, 0x20, 0x00, 0xf0, 0x61, 0xfc, 0xf7, 0xbd,
+	0x1c, 0x19, 0x4b, 0x10, 0xe0, 0x18, 0x4b, 0x10, 0xac, 0x18, 0x4b, 0x10,
+	0xf4, 0x08, 0x00, 0x00, 0xf0, 0xb5, 0x00, 0x24, 0xb8, 0x4b, 0x8f, 0xb0,
+	0x1c, 0x60, 0x72, 0xb6, 0x03, 0x20, 0xff, 0xf7, 0x8f, 0xfd, 0x01, 0x20,
+	0xff, 0xf7, 0x96, 0xfd, 0xff, 0xf7, 0x32, 0xfd, 0x06, 0x00, 0x03, 0x28,
+	0x3d, 0xd1, 0x84, 0x22, 0xb1, 0x4b, 0x07, 0xad, 0x12, 0x06, 0x1a, 0x60,
+	0x28, 0x00, 0xff, 0xf7, 0x11, 0xfd, 0x40, 0x23, 0x2a, 0x78, 0x5b, 0x42,
+	0x13, 0x43, 0x2b, 0x70, 0x28, 0x00, 0x08, 0xad, 0xff, 0xf7, 0x02, 0xfd,
+	0x29, 0x00, 0x0b, 0x20, 0xff, 0xf7, 0x0a, 0xfd, 0xff, 0x23, 0xeb, 0x70,
+	0xab, 0x70, 0xf8, 0x3b, 0x6b, 0x70, 0x29, 0x00, 0x01, 0x3b, 0x0b, 0x20,
+	0x2b, 0x70, 0xff, 0xf7, 0x07, 0xfd, 0xe1, 0x22, 0x23, 0x00, 0x52, 0x02,
+	0x31, 0x00, 0x30, 0x00, 0x02, 0x94, 0x01, 0x94, 0x00, 0x94, 0xff, 0xf7,
+	0x99, 0xfc, 0x9e, 0x49, 0x30, 0x00, 0x79, 0x44, 0xff, 0xf7, 0x76, 0xfc,
+	0x9c, 0x48, 0x78, 0x44, 0xff, 0xf7, 0xf5, 0xfe, 0x9b, 0x4a, 0x9c, 0x49,
+	0x9c, 0x48, 0x7a, 0x44, 0x79, 0x44, 0x78, 0x44, 0x00, 0xf0, 0x88, 0xf9,
+	0x00, 0xf0, 0x28, 0xfa, 0xfc, 0xe7, 0xff, 0xf7, 0xef, 0xfc, 0x05, 0x00,
+	0x01, 0x28, 0x77, 0xd1, 0xff, 0xf7, 0xc4, 0xfe, 0xff, 0xf7, 0x7c, 0xfd,
+	0x28, 0x00, 0xff, 0xf7, 0x09, 0xfe, 0x20, 0x00, 0xff, 0xf7, 0x06, 0xfe,
+	0x23, 0x00, 0x22, 0x00, 0x21, 0x00, 0x28, 0x00, 0xff, 0xf7, 0x72, 0xfd,
+	0x23, 0x00, 0x22, 0x00, 0x21, 0x00, 0x20, 0x00, 0xff, 0xf7, 0x6c, 0xfd,
+	0x23, 0x00, 0x22, 0x00, 0x29, 0x00, 0x28, 0x00, 0xff, 0xf7, 0xa2, 0xfd,
+	0x23, 0x00, 0x22, 0x00, 0x29, 0x00, 0x20, 0x00, 0xff, 0xf7, 0x9c, 0xfd,
+	0x29, 0x00, 0x20, 0x00, 0xff, 0xf7, 0xd2, 0xfd, 0x29, 0x00, 0x28, 0x00,
+	0xff, 0xf7, 0xce, 0xfd, 0x81, 0x4b, 0x82, 0x4a, 0x82, 0x4e, 0x1a, 0x60,
+	0x82, 0x4a, 0x83, 0x48, 0x32, 0x60, 0x19, 0x68, 0x78, 0x44, 0xff, 0xf7,
+	0xaf, 0xfe, 0x81, 0x48, 0x31, 0x68, 0x78, 0x44, 0xff, 0xf7, 0xaa, 0xfe,
+	0x82, 0x21, 0x00, 0x94, 0x23, 0x00, 0x10, 0x22, 0x49, 0x05, 0x28, 0x00,
+	0xff, 0xf7, 0xe6, 0xfd, 0x01, 0x20, 0xff, 0xf7, 0x19, 0xfe, 0x00, 0x28,
+	0xfa, 0xd1, 0x82, 0x24, 0x64, 0x05, 0x25, 0x00, 0x77, 0x48, 0x21, 0x78,
+	0x78, 0x44, 0xff, 0xf7, 0x95, 0xfe, 0x76, 0x4b, 0x01, 0x34, 0x9c, 0x42,
+	0xf6, 0xd1, 0x2d, 0x68, 0x74, 0x48, 0x29, 0x00, 0x78, 0x44, 0xff, 0xf7,
+	0x8b, 0xfe, 0x00, 0x24, 0xac, 0x42, 0x16, 0xda, 0x71, 0x48, 0x21, 0x00,
+	0x78, 0x44, 0xff, 0xf7, 0x83, 0xfe, 0x82, 0x23, 0xdb, 0x02, 0xe1, 0x18,
+	0x80, 0x22, 0x00, 0x23, 0x89, 0x02, 0x00, 0x93, 0xd2, 0x00, 0x01, 0x20,
+	0xff, 0xf7, 0xbc, 0xfd, 0x01, 0x20, 0xff, 0xf7, 0xef, 0xfd, 0x00, 0x28,
+	0xfa, 0xd1, 0x01, 0x34, 0xe6, 0xe7, 0x03, 0x21, 0x01, 0x20, 0x00, 0xf0,
+	0x8d, 0xfb, 0xfe, 0xe7, 0xff, 0xf7, 0x72, 0xfc, 0x09, 0xad, 0x07, 0x00,
+	0x02, 0x28, 0x5b, 0xd1, 0xff, 0xf7, 0x46, 0xfe, 0x84, 0x22, 0x60, 0x4b,
+	0x07, 0xae, 0x12, 0x06, 0x1a, 0x60, 0x30, 0x00, 0xff, 0xf7, 0x4e, 0xfc,
+	0x01, 0x22, 0x33, 0x78, 0x30, 0x00, 0x13, 0x43, 0x3b, 0x43, 0x33, 0x70,
+	0x08, 0xae, 0xff, 0xf7, 0x3f, 0xfc, 0x31, 0x00, 0x0a, 0x20, 0xff, 0xf7,
+	0x47, 0xfc, 0xff, 0x23, 0x31, 0x00, 0xf3, 0x70, 0xb3, 0x70, 0x0a, 0x20,
+	0xfe, 0x3b, 0x73, 0x70, 0x34, 0x70, 0xff, 0xf7, 0x45, 0xfc, 0xe1, 0x22,
+	0x23, 0x00, 0x52, 0x02, 0x03, 0x21, 0x38, 0x00, 0x02, 0x94, 0x01, 0x94,
+	0x00, 0x94, 0xff, 0xf7, 0xd7, 0xfb, 0x4d, 0x4b, 0x21, 0x00, 0x7b, 0x44,
+	0x14, 0x22, 0x28, 0x00, 0x1f, 0x60, 0x00, 0xf0, 0x4b, 0xfb, 0x4a, 0x48,
+	0x78, 0x44, 0xff, 0xf7, 0x30, 0xfe, 0x09, 0x21, 0x28, 0x00, 0x00, 0xf0,
+	0x51, 0xfa, 0x28, 0x5d, 0xff, 0xf7, 0xf6, 0xfd, 0x43, 0x1e, 0x98, 0x41,
+	0x24, 0x18, 0x14, 0x2c, 0xf7, 0xd1, 0x00, 0x25, 0x00, 0x24, 0x13, 0x26,
+	0x02, 0xab, 0xf6, 0x18, 0x30, 0x00, 0xff, 0xf7, 0xf3, 0xfd, 0x00, 0x28,
+	0x05, 0xd0, 0x3e, 0x4b, 0x32, 0x78, 0x7b, 0x44, 0x1a, 0x55, 0x01, 0x34,
+	0xf1, 0xe7, 0x3c, 0x4b, 0x9c, 0x42, 0xee, 0xdd, 0x28, 0x00, 0x01, 0x21,
+	0xff, 0xf7, 0x7c, 0xfe, 0x01, 0x35, 0xe7, 0xe7, 0xff, 0xf7, 0xea, 0xfd,
+	0xff, 0xf7, 0x96, 0xfd, 0x22, 0x00, 0x21, 0x00, 0x20, 0x00, 0xff, 0xf7,
+	0x93, 0xfd, 0x21, 0x00, 0x14, 0x22, 0x28, 0x00, 0x00, 0xf0, 0x14, 0xfb,
+	0x31, 0x48, 0x78, 0x44, 0xff, 0xf7, 0xf9, 0xfd, 0x09, 0x21, 0x28, 0x00,
+	0x00, 0xf0, 0x1a, 0xfa, 0x29, 0x59, 0x00, 0x20, 0x04, 0x34, 0xff, 0xf7,
+	0x97, 0xfd, 0x14, 0x2c, 0xf8, 0xd1, 0x00, 0x20, 0xff, 0xf7, 0xa2, 0xfd,
+	0x00, 0x23, 0x00, 0x25, 0x05, 0x93, 0x00, 0x20, 0xff, 0xf7, 0xa8, 0xfd,
+	0x00, 0x27, 0x06, 0x00, 0x25, 0x4c, 0x7c, 0x44, 0x64, 0x19, 0xbe, 0x42,
+	0x0c, 0xd0, 0x00, 0x20, 0xff, 0xf7, 0x8a, 0xfd, 0x03, 0x0a, 0x20, 0x70,
+	0x63, 0x70, 0x03, 0x0c, 0x00, 0x0e, 0xa3, 0x70, 0xe0, 0x70, 0x01, 0x37,
+	0x04, 0x34, 0xf0, 0xe7, 0xb6, 0x00, 0x1a, 0x4b, 0xad, 0x19, 0x9d, 0x42,
+	0xe3, 0xdd, 0x00, 0x21, 0x05, 0x98, 0xff, 0xf7, 0x37, 0xfe, 0x05, 0x9b,
+	0x01, 0x33, 0xda, 0xe7, 0x00, 0x00, 0x09, 0x40, 0x6c, 0x10, 0x00, 0x40,
+	0x63, 0x08, 0x00, 0x00, 0x5d, 0x08, 0x00, 0x00, 0xe3, 0xfd, 0xff, 0xff,
+	0x79, 0xfd, 0xff, 0xff, 0x8b, 0xfd, 0xff, 0xff, 0x38, 0x00, 0x09, 0x40,
+	0x16, 0x07, 0x02, 0x01, 0x3c, 0x00, 0x09, 0x40, 0x57, 0x97, 0xb0, 0xde,
+	0xe3, 0x07, 0x00, 0x00, 0xe7, 0x07, 0x00, 0x00, 0xcb, 0x07, 0x00, 0x00,
+	0x10, 0x00, 0x40, 0x10, 0xbe, 0x07, 0x00, 0x00, 0xb8, 0x07, 0x00, 0x00,
+	0x68, 0x10, 0x00, 0x40, 0x66, 0x16, 0x4b, 0x10, 0x18, 0x07, 0x00, 0x00,
+	0x32, 0x16, 0x4b, 0x10, 0x17, 0x04, 0x00, 0x00, 0xbd, 0x06, 0x00, 0x00,
+	0xc6, 0x15, 0x4b, 0x10, 0x07, 0x49, 0x10, 0xb5, 0x79, 0x44, 0x0b, 0x68,
+	0x06, 0x4c, 0x00, 0x22, 0xa3, 0x42, 0x05, 0xd8, 0x5a, 0x1c, 0x0a, 0x60,
+	0x04, 0x4a, 0x7a, 0x44, 0xd0, 0x54, 0x01, 0x22, 0x10, 0x00, 0x10, 0xbd,
+	0x50, 0x29, 0x4b, 0x10, 0x0f, 0x10, 0x00, 0x00, 0x2e, 0x19, 0x4b, 0x10,
+	0x00, 0x22, 0x04, 0x4b, 0x7b, 0x44, 0x1a, 0x60, 0x03, 0x4b, 0x01, 0x32,
+	0x7b, 0x44, 0x1a, 0x60, 0x70, 0x47, 0xc0, 0x46, 0x24, 0x29, 0x4b, 0x10,
+	0x30, 0x39, 0x4b, 0x10, 0x00, 0x23, 0x41, 0x18, 0x88, 0x42, 0x04, 0xd0,
+	0x02, 0x78, 0x01, 0x30, 0x9b, 0x18, 0xdb, 0xb2, 0xf8, 0xe7, 0xd8, 0x43,
+	0xc0, 0xb2, 0x70, 0x47, 0x10, 0xb5, 0x00, 0x24, 0x09, 0x4b, 0x7b, 0x44,
+	0x1c, 0x60, 0x01, 0x23, 0x08, 0x4c, 0x7c, 0x44, 0x23, 0x60, 0x08, 0x4c,
+	0x7c, 0x44, 0x20, 0x60, 0x07, 0x48, 0x78, 0x44, 0x01, 0x60, 0x07, 0x49,
+	0x79, 0x44, 0x0a, 0x60, 0x06, 0x4a, 0x7a, 0x44, 0x13, 0x70, 0x10, 0xbd,
+	0xee, 0x28, 0x4b, 0x10, 0xfa, 0x38, 0x4b, 0x10, 0xfc, 0x38, 0x4b, 0x10,
+	0xf2, 0x38, 0x4b, 0x10, 0xf4, 0x38, 0x4b, 0x10, 0x9a, 0x14, 0x4b, 0x10,
+	0x0e, 0x4b, 0x70, 0xb5, 0x7b, 0x44, 0x1b, 0x68, 0x05, 0x00, 0x18, 0x1e,
+	0x15, 0xd0, 0x00, 0x24, 0xac, 0x42, 0x0e, 0xd0, 0x0a, 0x4b, 0x7b, 0x44,
+	0x1b, 0x78, 0x00, 0x2b, 0x0b, 0xd0, 0x09, 0x4b, 0x7b, 0x44, 0xe0, 0x5c,
+	0x08, 0x4b, 0x7b, 0x44, 0x1b, 0x68, 0x98, 0x47, 0x00, 0x28, 0x02, 0xd1,
+	0xf0, 0xe7, 0x01, 0x20, 0x01, 0xe0, 0x01, 0x34, 0xea, 0xe7, 0x70, 0xbd,
+	0xc4, 0x38, 0x4b, 0x10, 0x66, 0x14, 0x4b, 0x10, 0x94, 0x28, 0x4b, 0x10,
+	0xa2, 0x38, 0x4b, 0x10, 0x70, 0xb5, 0x0d, 0x00, 0x0e, 0x00, 0x01, 0x21,
+	0x1b, 0x4c, 0x10, 0x3e, 0x7c, 0x44, 0x21, 0x70, 0x00, 0x21, 0x60, 0x70,
+	0x28, 0x0a, 0xe0, 0x70, 0x10, 0x0a, 0x22, 0x71, 0x60, 0x71, 0x23, 0x72,
+	0x10, 0x0c, 0x1b, 0x0a, 0x12, 0x0e, 0xa0, 0x71, 0x63, 0x72, 0xa1, 0x72,
+	0xe1, 0x72, 0xa5, 0x70, 0xe2, 0x71, 0x60, 0x1c, 0x0b, 0x31, 0xff, 0xf7,
+	0x8f, 0xff, 0x02, 0x23, 0x23, 0x73, 0x04, 0x9b, 0xb6, 0xb2, 0xe0, 0x72,
+	0x00, 0x2b, 0x05, 0xd0, 0x20, 0x00, 0x32, 0x00, 0x0d, 0x30, 0x19, 0x00,
+	0x00, 0xf0, 0x6a, 0xf9, 0x03, 0x21, 0x09, 0x4c, 0xae, 0x1e, 0x7c, 0x44,
+	0x63, 0x19, 0xda, 0x1e, 0x11, 0x70, 0x00, 0x22, 0x01, 0x3b, 0xa2, 0x55,
+	0x29, 0x00, 0x04, 0x32, 0x20, 0x00, 0x1a, 0x70, 0xff, 0xf7, 0x72, 0xff,
+	0xa0, 0x55, 0x70, 0xbd, 0x5c, 0x28, 0x4b, 0x10, 0x0e, 0x28, 0x4b, 0x10,
+	0x07, 0xb5, 0x03, 0x78, 0x21, 0x2b, 0x0a, 0xd1, 0x00, 0x22, 0x10, 0x21,
+	0x00, 0x92, 0x13, 0x00, 0x22, 0x20, 0xff, 0xf7, 0xb5, 0xff, 0x10, 0x20,
+	0xff, 0xf7, 0x8c, 0xff, 0x05, 0xe0, 0x04, 0x4b, 0x7b, 0x44, 0x1b, 0x68,
+	0x00, 0x2b, 0x00, 0xd0, 0x98, 0x47, 0x01, 0x20, 0x0e, 0xbd, 0xc0, 0x46,
+	0xe4, 0x37, 0x4b, 0x10, 0x43, 0x4b, 0xf7, 0xb5, 0x7b, 0x44, 0x1b, 0x68,
+	0x00, 0x2b, 0x00, 0xd1, 0x7e, 0xe0, 0x03, 0x27, 0x40, 0x4b, 0x7b, 0x44,
+	0x1b, 0x78, 0x00, 0x2b, 0x00, 0xd1, 0x77, 0xe0, 0x6b, 0x46, 0xdc, 0x1d,
+	0x3d, 0x4b, 0x20, 0x00, 0x7b, 0x44, 0x1b, 0x68, 0x98, 0x47, 0x00, 0x28,
+	0x6e, 0xd0, 0x3b, 0x4b, 0x7b, 0x44, 0x18, 0x68, 0x01, 0x38, 0x03, 0x28,
+	0x02, 0xd9, 0xff, 0xf7, 0x25, 0xff, 0xe7, 0xe7, 0x00, 0xf0, 0x22, 0xf9,
+	0x02, 0x0b, 0x25, 0x3f, 0x20, 0x78, 0x01, 0x28, 0xe0, 0xd1, 0xff, 0xf7,
+	0x05, 0xff, 0x33, 0x4b, 0x02, 0x22, 0x7b, 0x44, 0x2e, 0xe0, 0x20, 0x78,
+	0xff, 0xf7, 0xfe, 0xfe, 0x30, 0x4b, 0x7b, 0x44, 0x1b, 0x68, 0x0d, 0x2b,
+	0x0e, 0xd1, 0x23, 0x78, 0x02, 0x2b, 0xcf, 0xd1, 0x2d, 0x48, 0x0b, 0x21,
+	0x78, 0x44, 0x01, 0x30, 0xff, 0xf7, 0x14, 0xff, 0x00, 0x28, 0x3e, 0xd1,
+	0x2a, 0x4b, 0x7b, 0x44, 0x1f, 0x60, 0xc3, 0xe7, 0x0d, 0x2b, 0xc1, 0xd9,
+	0x37, 0xe0, 0x20, 0x78, 0xff, 0xf7, 0xe4, 0xfe, 0x26, 0x4b, 0x7b, 0x44,
+	0x9a, 0x78, 0xdb, 0x78, 0x1b, 0x02, 0x13, 0x43, 0x24, 0x4a, 0x02, 0x3b,
+	0x7a, 0x44, 0x12, 0x68, 0x93, 0x42, 0x07, 0xd1, 0x23, 0x78, 0x03, 0x2b,
+	0xae, 0xd1, 0x04, 0x22, 0x20, 0x4b, 0x7b, 0x44, 0x1a, 0x60, 0xa9, 0xe7,
+	0x93, 0x42, 0xa7, 0xd2, 0x1d, 0xe0, 0x20, 0x78, 0x1d, 0x4e, 0xff, 0xf7,
+	0xc9, 0xfe, 0x1d, 0x4b, 0x7e, 0x44, 0xf5, 0x78, 0x7b, 0x44, 0xb2, 0x78,
+	0x1b, 0x68, 0x2d, 0x02, 0x15, 0x43, 0x9d, 0x42, 0x12, 0xd1, 0x23, 0x78,
+	0x04, 0x2b, 0x95, 0xd1, 0x29, 0x00, 0x30, 0x00, 0xff, 0xf7, 0xdc, 0xfe,
+	0x00, 0x28, 0x06, 0xd1, 0x2a, 0x00, 0x31, 0x00, 0x10, 0x3a, 0x0d, 0x31,
+	0x70, 0x1c, 0xff, 0xf7, 0x67, 0xff, 0xff, 0xf7, 0xc3, 0xfe, 0x85, 0xe7,
+	0x9d, 0x42, 0x00, 0xd3, 0x82, 0xe7, 0xf8, 0xe7, 0xf7, 0xbd, 0xc0, 0x46,
+	0xc8, 0x37, 0x4b, 0x10, 0x6a, 0x13, 0x4b, 0x10, 0xa8, 0x37, 0x4b, 0x10,
+	0x94, 0x37, 0x4b, 0x10, 0x6e, 0x37, 0x4b, 0x10, 0x4e, 0x27, 0x4b, 0x10,
+	0x2c, 0x17, 0x4b, 0x10, 0x42, 0x37, 0x4b, 0x10, 0x0a, 0x17, 0x4b, 0x10,
+	0x0c, 0x27, 0x4b, 0x10, 0x0e, 0x37, 0x4b, 0x10, 0xd4, 0x16, 0x4b, 0x10,
+	0xe0, 0x26, 0x4b, 0x10, 0x0b, 0x00, 0x70, 0xb5, 0x8e, 0x18, 0xb3, 0x42,
+	0x04, 0xd0, 0x1d, 0x78, 0x5c, 0x1a, 0x25, 0x54, 0x01, 0x33, 0xf8, 0xe7,
+	0x10, 0x00, 0x70, 0xbd, 0x07, 0xb5, 0x8b, 0xb2, 0x00, 0x21, 0x02, 0x00,
+	0x00, 0x91, 0x24, 0x20, 0x10, 0x31, 0xff, 0xf7, 0xef, 0xfe, 0x10, 0x20,
+	0xff, 0xf7, 0xc6, 0xfe, 0x0e, 0xbd, 0x0b, 0x00, 0x30, 0xb5, 0x8d, 0x18,
+	0xab, 0x42, 0x04, 0xd0, 0x5c, 0x1a, 0x24, 0x5c, 0x1c, 0x70, 0x01, 0x33,
+	0xf8, 0xe7, 0x10, 0x00, 0x30, 0xbd, 0x13, 0xb5, 0x0c, 0x00, 0x02, 0x00,
+	0x00, 0x20, 0x10, 0x34, 0x8b, 0xb2, 0x00, 0x90, 0xa1, 0xb2, 0x28, 0x30,
+	0xff, 0xf7, 0xd4, 0xfe, 0x20, 0x00, 0xff, 0xf7, 0xab, 0xfe, 0x16, 0xbd,
+	0x01, 0x68, 0x8d, 0x46, 0x40, 0x68, 0x80, 0x47, 0x70, 0x47, 0x07, 0xb5,
+	0x00, 0x22, 0x10, 0x21, 0x00, 0x92, 0x13, 0x00, 0x33, 0x20, 0xff, 0xf7,
+	0xc3, 0xfe, 0x10, 0x20, 0xff, 0xf7, 0x9a, 0xfe, 0x0e, 0xbd, 0x00, 0x00,
+	0xf0, 0xb5, 0x0c, 0x27, 0x87, 0xb0, 0x03, 0xac, 0x05, 0x00, 0x01, 0x91,
+	0x3a, 0x00, 0x00, 0x21, 0x20, 0x00, 0x00, 0xf0, 0xe7, 0xf8, 0x01, 0x23,
+	0x23, 0x70, 0x6b, 0x46, 0x04, 0x26, 0x0b, 0x49, 0x9b, 0x88, 0x32, 0x00,
+	0x79, 0x44, 0x28, 0x00, 0x23, 0x81, 0xa6, 0x80, 0x00, 0xf0, 0x3a, 0xf8,
+	0x3a, 0x00, 0x21, 0x00, 0xa8, 0x19, 0x00, 0xf0, 0x35, 0xf8, 0x28, 0x00,
+	0x04, 0x49, 0x32, 0x00, 0x79, 0x44, 0x10, 0x30, 0x00, 0xf0, 0x2e, 0xf8,
+	0x07, 0xb0, 0xf0, 0xbd, 0x67, 0x02, 0x00, 0x00, 0x50, 0x02, 0x00, 0x00,
+	0x03, 0x00, 0x14, 0x33, 0x0b, 0x60, 0x43, 0x8a, 0x13, 0x60, 0x70, 0x47,
+	0xfe, 0xe7, 0x00, 0x00, 0x00, 0x23, 0x07, 0xb5, 0x0a, 0x4a, 0x0b, 0x49,
+	0x7a, 0x44, 0x51, 0x58, 0x00, 0x91, 0x0a, 0x49, 0x51, 0x58, 0x01, 0x91,
+	0x00, 0x99, 0x01, 0x98, 0x59, 0x18, 0x81, 0x42, 0x05, 0xd2, 0x07, 0x48,
+	0x10, 0x58, 0xc0, 0x58, 0x04, 0x33, 0x08, 0x60, 0xf4, 0xe7, 0xff, 0xf7,
+	0x59, 0xfc, 0x07, 0xbd, 0x2c, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x23, 0x10, 0xb5,
+	0x9a, 0x42, 0x03, 0xd0, 0xcc, 0x5c, 0xc4, 0x54, 0x01, 0x33, 0xf9, 0xe7,
+	0x10, 0xbd, 0x00, 0x00, 0x02, 0xb4, 0x71, 0x46, 0x49, 0x08, 0x49, 0x00,
+	0x09, 0x5c, 0x49, 0x00, 0x8e, 0x44, 0x02, 0xbc, 0x70, 0x47, 0xc0, 0x46,
+	0x00, 0x22, 0x43, 0x08, 0x8b, 0x42, 0x74, 0xd3, 0x03, 0x09, 0x8b, 0x42,
+	0x5f, 0xd3, 0x03, 0x0a, 0x8b, 0x42, 0x44, 0xd3, 0x03, 0x0b, 0x8b, 0x42,
+	0x28, 0xd3, 0x03, 0x0c, 0x8b, 0x42, 0x0d, 0xd3, 0xff, 0x22, 0x09, 0x02,
+	0x12, 0xba, 0x03, 0x0c, 0x8b, 0x42, 0x02, 0xd3, 0x12, 0x12, 0x09, 0x02,
+	0x65, 0xd0, 0x03, 0x0b, 0x8b, 0x42, 0x19, 0xd3, 0x00, 0xe0, 0x09, 0x0a,
+	0xc3, 0x0b, 0x8b, 0x42, 0x01, 0xd3, 0xcb, 0x03, 0xc0, 0x1a, 0x52, 0x41,
+	0x83, 0x0b, 0x8b, 0x42, 0x01, 0xd3, 0x8b, 0x03, 0xc0, 0x1a, 0x52, 0x41,
+	0x43, 0x0b, 0x8b, 0x42, 0x01, 0xd3, 0x4b, 0x03, 0xc0, 0x1a, 0x52, 0x41,
+	0x03, 0x0b, 0x8b, 0x42, 0x01, 0xd3, 0x0b, 0x03, 0xc0, 0x1a, 0x52, 0x41,
+	0xc3, 0x0a, 0x8b, 0x42, 0x01, 0xd3, 0xcb, 0x02, 0xc0, 0x1a, 0x52, 0x41,
+	0x83, 0x0a, 0x8b, 0x42, 0x01, 0xd3, 0x8b, 0x02, 0xc0, 0x1a, 0x52, 0x41,
+	0x43, 0x0a, 0x8b, 0x42, 0x01, 0xd3, 0x4b, 0x02, 0xc0, 0x1a, 0x52, 0x41,
+	0x03, 0x0a, 0x8b, 0x42, 0x01, 0xd3, 0x0b, 0x02, 0xc0, 0x1a, 0x52, 0x41,
+	0xcd, 0xd2, 0xc3, 0x09, 0x8b, 0x42, 0x01, 0xd3, 0xcb, 0x01, 0xc0, 0x1a,
+	0x52, 0x41, 0x83, 0x09, 0x8b, 0x42, 0x01, 0xd3, 0x8b, 0x01, 0xc0, 0x1a,
+	0x52, 0x41, 0x43, 0x09, 0x8b, 0x42, 0x01, 0xd3, 0x4b, 0x01, 0xc0, 0x1a,
+	0x52, 0x41, 0x03, 0x09, 0x8b, 0x42, 0x01, 0xd3, 0x0b, 0x01, 0xc0, 0x1a,
+	0x52, 0x41, 0xc3, 0x08, 0x8b, 0x42, 0x01, 0xd3, 0xcb, 0x00, 0xc0, 0x1a,
+	0x52, 0x41, 0x83, 0x08, 0x8b, 0x42, 0x01, 0xd3, 0x8b, 0x00, 0xc0, 0x1a,
+	0x52, 0x41, 0x43, 0x08, 0x8b, 0x42, 0x01, 0xd3, 0x4b, 0x00, 0xc0, 0x1a,
+	0x52, 0x41, 0x41, 0x1a, 0x00, 0xd2, 0x01, 0x46, 0x52, 0x41, 0x10, 0x46,
+	0x70, 0x47, 0xff, 0xe7, 0x01, 0xb5, 0x00, 0x20, 0x00, 0xf0, 0x06, 0xf8,
+	0x02, 0xbd, 0xc0, 0x46, 0x00, 0x29, 0xf7, 0xd0, 0x76, 0xe7, 0x70, 0x47,
+	0x70, 0x47, 0xc0, 0x46, 0x03, 0x00, 0x82, 0x18, 0x93, 0x42, 0x02, 0xd0,
+	0x19, 0x70, 0x01, 0x33, 0xfa, 0xe7, 0x70, 0x47, 0x01, 0xb4, 0x02, 0x48,
+	0x84, 0x46, 0x01, 0xbc, 0x60, 0x47, 0x00, 0xbf, 0x01, 0x20, 0x4b, 0x10,
+	0x00, 0x90, 0x00, 0x40, 0x00, 0xa0, 0x00, 0x40, 0x00, 0x10, 0x04, 0x40,
+	0x00, 0x20, 0x04, 0x40, 0x00, 0x30, 0x09, 0x40, 0x00, 0x38, 0x09, 0x40,
+	0x72, 0x65, 0x73, 0x65, 0x74, 0x20, 0x3d, 0x20, 0x00, 0x52, 0x00, 0x46,
+	0x57, 0x20, 0x55, 0x70, 0x67, 0x72, 0x61, 0x64, 0x65, 0x20, 0x4d, 0x6f,
+	0x64, 0x65, 0x00, 0x53, 0x57, 0x5f, 0x56, 0x45, 0x52, 0x53, 0x49, 0x4f,
+	0x4e, 0x20, 0x3d, 0x20, 0x00, 0x42, 0x44, 0x5f, 0x56, 0x45, 0x52, 0x53,
+	0x49, 0x4f, 0x4e, 0x20, 0x3d, 0x20, 0x00, 0x64, 0x61, 0x74, 0x61, 0x3a,
+	0x20, 0x00, 0x6e, 0x5f, 0x63, 0x68, 0x75, 0x6e, 0x6b, 0x3a, 0x20, 0x00,
+	0x69, 0x6e, 0x64, 0x65, 0x78, 0x3a, 0x20, 0x00, 0x48, 0x53, 0x55, 0x41,
+	0x52, 0x54, 0x20, 0x42, 0x6f, 0x6f, 0x74, 0x20, 0x4d, 0x6f, 0x64, 0x65,
+	0x0d, 0x0a, 0x00, 0x41, 0x48, 0x42, 0x20, 0x42, 0x6f, 0x6f, 0x74, 0x20,
+	0x4d, 0x6f, 0x64, 0x65, 0x0d, 0x0a, 0x00, 0x4e, 0x52, 0x43, 0x5b, 0x00,
+	0x5d, 0x4d, 0x53, 0x47, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x4b, 0x10,
+	0x4c, 0x11, 0x00, 0x00, 0x48, 0x20, 0x4b, 0x10, 0x48, 0x20, 0x4b, 0x10,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x30, 0xb5, 0x0d, 0x4c, 0x0d, 0x4b, 0x22, 0x68, 0x00, 0x28, 0x0a, 0xd0,
+	0x0f, 0x20, 0x82, 0x43, 0x11, 0x43, 0x21, 0x60, 0xc0, 0x21, 0x00, 0x22,
+	0x09, 0x06, 0x1a, 0x60, 0x19, 0x60, 0x1a, 0x60, 0x09, 0xe0, 0xf0, 0x25,
+	0x09, 0x01, 0xaa, 0x43, 0x11, 0x43, 0xc0, 0x22, 0x92, 0x05, 0x21, 0x60,
+	0x18, 0x60, 0x1a, 0x60, 0x18, 0x60, 0xfe, 0xe7, 0x04, 0xf0, 0x00, 0x40,
+	0x10, 0x10, 0x00, 0x40, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00
+};
+const unsigned int fb_cm0_len = 4500;
diff --git a/drivers/staging/nrc/hif.c b/drivers/staging/nrc/hif.c
new file mode 100755
index 000000000000..ead785365684
--- /dev/null
+++ b/drivers/staging/nrc/hif.c
@@ -0,0 +1,1043 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <net/mac80211.h>
+#include <linux/gpio.h>
+
+#include "nrc-hif.h"
+#include "nrc-recovery.h"
+#include "nrc-build-config.h"
+
+#if defined(CONFIG_NRC_HIF_SSP)
+#include "nrc-hif-ssp.h"
+#elif defined(CONFIG_NRC_HIF_UART)
+#include "nrc-hif-uart.h"
+#elif defined(CONFIG_NRC_HIF_DEBUG)
+#include "nrc-hif-debug.h"
+#elif defined(CONFIG_NRC_HIF_CSPI)
+#include "nrc-hif-cspi.h"
+#elif defined(CONFIG_NRC_HIF_SDIO)
+#include "nrc-hif-sdio.h"
+#endif
+
+#include "nrc-mac80211.h"
+#include "nrc-netlink.h"
+#include "wim.h"
+#include "nrc-dump.h"
+#include "nrc-vendor.h"
+#if defined(DEBUG)
+#include "nrc-debug.h"
+#endif
+
+#define to_nw(dev)	((dev)->nw)
+
+static void nrc_hif_work(struct work_struct *work);
+static void nrc_hif_ps_work(struct work_struct *work);
+static int hif_receive_skb(struct nrc_hif_device *dev, struct sk_buff *skb);
+
+struct nrc_hif_device *nrc_hif_init(struct nrc *nw)
+{
+	struct nrc_hif_device *dev = NULL;
+	int i;
+
+#if defined(CONFIG_NRC_HIF_SSP)
+	dev = nrc_hif_ssp_init();
+#elif defined(CONFIG_NRC_HIF_UART)
+	dev = nrc_hif_uart_init();
+#elif defined(CONFIG_NRC_HIF_DEBUG)
+	dev = nrc_hif_debug_init();
+#elif defined(CONFIG_NRC_HIF_CSPI)
+	dev = nrc_hif_cspi_init();
+#elif defined(CONFIG_NRC_HIF_SDIO)
+	dev = nrc_hif_sdio_init();
+#endif
+	if (!dev)
+		goto out;
+
+	dev->nw = nw;
+	dev->suspended = false;
+
+	/* Initialize wim and frame queue */
+	for (i = 0; i < ARRAY_SIZE(dev->queue); i++)
+		skb_queue_head_init(&dev->queue[i]);
+
+	INIT_WORK(&dev->work, nrc_hif_work);
+	INIT_WORK(&dev->ps_work, nrc_hif_ps_work);
+
+	dev->hif_ops->receive = hif_receive_skb;
+
+	nrc_hif_start(dev);
+
+out:
+	return dev;
+}
+
+void nrc_hif_free_skb(struct nrc *nw, struct sk_buff *skb)
+{
+	struct hif *hif = (void *)skb->data;
+	struct frame_hdr *fh = (struct frame_hdr *)(hif + 1);
+	bool ack = true;
+	int credit;
+
+	if (hif->type == HIF_TYPE_FRAME) {
+		struct ieee80211_tx_info *txi = IEEE80211_SKB_CB(skb);
+
+		ieee80211_tx_info_clear_status(txi);
+		if (!(txi->flags & IEEE80211_TX_CTL_NO_ACK) && ack)
+			txi->flags |= IEEE80211_TX_STAT_ACK;
+
+		credit = DIV_ROUND_UP(skb->len, nw->fwinfo.buffer_size);
+#ifdef CONFIG_NRC_HIF_PRINT_FLOW_CONTROL
+		nrc_dbg(NRC_DBG_HIF, "%s ac:%d, pend:%d, credit:%d\n",
+				__func__, fh->flags.tx.ac,
+				atomic_read(&nw->tx_pend[fh->flags.tx.ac]),
+				credit);
+#endif
+		atomic_sub(credit, &nw->tx_pend[fh->flags.tx.ac]);
+		/* Peel out our headers */
+		skb_pull(skb, nw->fwinfo.tx_head_size);
+
+		ieee80211_tx_status_irqsafe(nw->hw, skb);
+#ifdef CONFIG_USE_TXQ
+		nrc_kick_txq(nw->hw);
+#endif
+		return;
+	}
+
+	/* Other types not created by mac80211 */
+	dev_kfree_skb(skb);
+}
+
+static bool nrc_hif_sleep_find(struct sk_buff *skb, u32 *duration_ms)
+{
+	struct hif *hif = (void *)skb->data;
+	struct wim *wim = (void *)(hif+1);
+	struct wim_sleep_duration *sleep_duration = (void *)(wim + 1);
+
+	if ((hif->type != HIF_TYPE_WIM) ||
+		(hif->subtype != HIF_WIM_SUB_REQUEST)) {
+		return false;
+	}
+
+	if (wim->cmd == WIM_CMD_SLEEP &&
+		sleep_duration->h.type == WIM_TLV_SLEEP_DURATION) {
+		*duration_ms = sleep_duration->v.sleep_ms;
+		return true;
+	}
+
+	return false;
+}
+
+static int nrc_hif_ctrl_ps(struct nrc_hif_device *hdev, struct sk_buff *skb)
+{
+	struct nrc *nw;
+	int ret;
+	u32 sleep_ms = 0;
+	const u32 wakeup_ms = 10;
+
+	if (!nrc_hif_sleep_find(skb, &sleep_ms))
+		return HIF_TX_PASSOVER;
+
+	nw = to_nw(hdev);
+	nrc_hif_disable_irq(hdev);
+
+	ret = nrc_hif_xmit(hdev, skb);
+	nrc_hif_set_gpio(hdev, 0);
+	msleep(sleep_ms+wakeup_ms);
+
+	hdev->hif_ops->update(hdev);
+	hdev->hif_ops->enable_irq(hdev);
+	nrc_hif_set_gpio(hdev, 1);
+	return HIF_TX_COMPLETE;
+}
+
+static void nrc_hif_work(struct work_struct *work)
+{
+	struct nrc *nw;
+	struct nrc_hif_device *hdev;
+	struct sk_buff *skb, *skb_frame = NULL;
+	int i, ret = 0;
+
+	hdev = container_of(work, struct nrc_hif_device, work);
+	nw = to_nw(hdev);
+
+	for (i = ARRAY_SIZE(hdev->queue)-1; i >= 0; i--) {
+		for (;;) {
+			/*
+			 * [CB#12004][NRC7292 Host Mode] Deauth Fail on WPA3-SAE and OWE
+			 * the deauth frame should be transferred first even though
+			 * the current for-loop is for the queue of WIM.
+			 */
+			if (i) { // WIM
+				skb = skb_dequeue(&hdev->queue[i]);
+				if (skb && !skb_frame) {
+					skb_frame = skb_dequeue(&hdev->queue[0]);
+					if (skb_frame) {
+						u8 *p;
+						struct ieee80211_hdr *mh;
+						p = (u8*)skb_frame->data;
+						mh = (void*)(p + sizeof(struct hif) + sizeof(struct frame_hdr));
+						if (ieee80211_is_deauth(mh->frame_control)) {
+							skb_queue_head(&hdev->queue[i], skb);
+							skb = skb_frame;
+							skb_frame = NULL;
+						}
+					}
+				}	
+			} else { // Frame
+				if (skb_frame) {
+					skb = skb_frame;
+					skb_frame = NULL;
+				} else
+					skb = skb_dequeue(&hdev->queue[i]);
+			}
+			if (!skb)
+				break;
+
+			if (hdev->hif_ops->xmit) {
+				if (nrc_hif_wait_for_xmit(hdev, skb) < 0) {
+					nrc_hif_free_skb(nw, skb);
+					return;
+				}
+				SYNC_LOCK(hdev);
+				ret = nrc_hif_ctrl_ps(hdev, skb);
+				if (ret == HIF_TX_PASSOVER) {
+#if defined(DEBUG)
+					struct hif_lb_hdr *hif = (struct hif_lb_hdr*)skb->data;
+					if (hif->type == HIF_TYPE_LOOPBACK) {
+						tx_time_last = ktime_to_us(ktime_get());
+						if (hif->index == 0) {
+							tx_time_first = tx_time_last;
+						}
+						if (hif->subtype != LOOPBACK_MODE_RX_ONLY) {
+							(time_info_array + hif->index)->_i = hif->index;
+							(time_info_array + hif->index)->_txt = tx_time_last;
+						}
+					}
+#endif
+					ret = nrc_hif_xmit(hdev, skb);
+				}
+				SYNC_UNLOCK(hdev);
+			} else {
+				ret = nrc_hif_write(hdev, skb->data, skb->len);
+				ret = HIF_TX_COMPLETE;
+			}
+			WARN_ON(ret < 0);
+
+			if (ret != HIF_TX_QUEUED)
+				nrc_hif_free_skb(nw, skb);
+		}
+	}
+}
+
+static void nrc_hif_ps_work(struct work_struct *work)
+{
+	struct nrc *nw;
+	struct nrc_hif_device *hdev;
+	struct wim_pm_param *p;
+	struct sk_buff *skb;
+	struct nrc_txq *ntxq;
+	int i, ret = 0;
+
+	hdev = container_of(work, struct nrc_hif_device, ps_work);
+	nw = to_nw(hdev);
+
+	if (nw->ps_enabled) {
+		if (nw->drv_state == NRC_DRV_PS) {
+			/*
+			 * if the current state is already NRC_DRV_PS,
+			 * there's nothing to do in here even if mac80211 notifies wake-up.
+			 * the actual action to wake up for target will be done by
+			 * nrc_wake_tx_queue() with changing gpio signal.
+			 * (when driver receives a data frame.)
+			 */
+			nrc_ps_dbg("Target is already in deepsleep...\n");
+			return;
+		}
+		skb = nrc_wim_alloc_skb(nw, WIM_CMD_SET, WIM_MAX_SIZE);
+		p = nrc_wim_skb_add_tlv(skb, WIM_TLV_PS_ENABLE,
+				sizeof(struct wim_pm_param), NULL);
+		memset(p, 0, sizeof(struct wim_pm_param));
+		p->ps_mode = power_save;
+		p->ps_enable = true;
+		p->ps_wakeup_pin = TARGET_GPIO_FOR_WAKEUP;
+		nw->ps_drv_state = nw->ps_enabled;
+
+		if (power_save >= NRC_PS_DEEPSLEEP_TIM) {
+			if (!disable_cqm) {
+				del_timer(&nw->bcn_mon_timer);
+			}
+			p->ps_duration = (uint64_t) sleep_duration[0] * (sleep_duration[1] ? 1000 : 1);
+			ieee80211_stop_queues(nw->hw);
+			for (i = 0; i < NRC_QUEUE_MAX; i++) {
+				ntxq = &nw->ntxq[i];
+				skb_queue_purge(&ntxq->queue);
+#ifdef CONFIG_CHECK_DATA_SIZE
+				ntxq->data_size = 0;
+#endif
+			}
+			nrc_ps_dbg("Enter DEEPSLEEP!!!\n");
+			nrc_ps_dbg("sleep_duration: %lld ms\n", p->ps_duration);
+		} else {
+			nrc_ps_dbg("Enter MODEMSLEEP!!!\n");
+		}
+
+		gpio_set_value(RPI_GPIO_FOR_PS, 0);
+		nrc_hif_suspend_rx_thread(nw->hif);
+		ret = nrc_xmit_wim_request(nw, skb);
+		if (power_save >= NRC_PS_DEEPSLEEP_TIM &&
+			(nw->drv_state != NRC_DRV_PS)) {
+			nrc_hif_suspend(nw->hif);
+			msleep(100);
+		}
+		nrc_hif_resume_rx_thread(nw->hif);
+		ieee80211_wake_queues(nw->hw);
+	}
+}
+
+#if defined (CONFIG_TXQ_ORDER_CHANGE_NRC_DRV)
+/**************************************************************************//**
+* FunctionName : is_tcp_ack
+* Description : Check if the skb is a tcp ack frame (the relative sequence number of tcp ack is 1 )
+* Parameters : skb(socket buffer)
+* Returns : T/F (bool) T:TCP ACK, F:not TCP ACK
+*******************************************************************************/
+bool is_tcp_ack(struct sk_buff *skb)
+{
+	struct hif *hif;
+	struct ieee80211_hdr *mhdr;
+	struct iphdr *ip_header = ip_hdr(skb);
+	struct tcphdr *tcp_header = tcp_hdr(skb);
+
+	static __u32 raw_seq_num;
+
+	u8 *p;
+	p = (u8*)skb->data;
+	hif = (void*)p;
+	mhdr = (void*)(p+sizeof(struct hif)+ sizeof(struct frame_hdr));
+
+	if (ieee80211_is_data(mhdr->frame_control)){
+		if ((ip_header->protocol == IPPROTO_TCP) && (tcp_header->syn) && (tcp_header->ack)){
+			raw_seq_num = ntohl (tcp_header->seq);
+		}
+		if ((ip_header->protocol == IPPROTO_TCP) && (tcp_header->ack) && ((ntohl(tcp_header->seq) - raw_seq_num) == 1)) {
+			return true;
+		}
+	}
+	return false;
+}
+
+/**************************************************************************//**
+* FunctionName : is_urgent_frame
+* Description : Check if the frame is urgent
+* Parameters : skb(socket buffer)
+* Returns : T/F (bool)
+*******************************************************************************/
+bool is_urgent_frame(struct sk_buff *skb)
+{
+	bool ret = false;
+	if (is_tcp_ack(skb)){
+		ret = true;
+	}
+	return ret;
+}
+
+/**************************************************************************//**
+* FunctionName : skb_change_ac
+* Description : force change the access category of the skb
+* Parameters : nw, skb, ac(aceess category want to change)
+						ac:0 is for BK. ac:1 is BE, ac:2 is VI, ac:3 is VO)
+* Returns : -1 Not change aceess category
+			 0 access category change done
+*******************************************************************************/
+int skb_change_ac(struct nrc *nw, struct sk_buff *skb, uint8_t ac)
+{
+	struct hif *hif;
+	struct frame_hdr *fh;
+	int credit;
+
+	u8 *p;
+	p = (u8*)skb->data;
+	hif = (void*)p;
+	fh = (void*)(p+sizeof(struct hif));
+
+	if (ac>3)
+		return -1;
+
+	credit = DIV_ROUND_UP(skb->len, nw->fwinfo.buffer_size);
+
+	atomic_sub(credit, &nw->tx_pend[fh->flags.tx.ac]);
+	fh->flags.tx.ac = (hif->vifindex == 0 ? ac : ac+6);
+	atomic_add(credit, &nw->tx_pend[fh->flags.tx.ac]);
+
+	return 0;
+}
+#endif
+
+static int nrc_hif_enqueue_skb(struct nrc *nw, struct sk_buff *skb)
+{
+	struct hif *hif = (void *)skb->data;
+	struct nrc_hif_device *hdev = nw->hif;
+
+	if ((int)atomic_read(&nw->fw_state) != NRC_FW_ACTIVE) {
+		return -1;
+	}
+
+	if ((hif == NULL) || (hdev == NULL)) {
+		return -1;
+	}
+
+	if (hif->type != HIF_TYPE_FRAME && hif->type != HIF_TYPE_WIM
+		&& hif->type != HIF_TYPE_LOOPBACK) {
+		WARN_ON(true);
+		return -1;
+	}
+
+#if defined (CONFIG_TXQ_ORDER_CHANGE_NRC_DRV)
+	if (is_urgent_frame(skb)) {
+		// Change AC to  -  0: AC_BK, 1: AC_BE, 2: AC_VI, 3: AC_VO
+		// return -1 when AC is not changed (4: Beacon , 5: GP)
+		if (skb_change_ac(nw, skb, 3) < 0) {
+			//Case 1: change nothing.
+			skb_queue_tail(&hdev->queue[hif->type], skb);
+		} else {
+			//Case 2: AC is changed and enqueue to the head
+			skb_queue_head(&hdev->queue[hif->type], skb);
+			//Case 3: AC is changed and enqueue to the tail
+			//skb_queue_tail(&hdev->queue[hif->type], skb);
+		}
+	} else {
+		if (hif->type == HIF_TYPE_LOOPBACK) {
+			skb_queue_tail(&hdev->queue[HIF_TYPE_WIM], skb);
+		} else {
+			skb_queue_tail(&hdev->queue[hif->type], skb);
+		}
+	}
+#else
+	/*
+	 * HIF_TYPE_WIM and HIF_TYPE_LOOPBACK are using the same queue.
+	 */
+	if (hif->type == HIF_TYPE_LOOPBACK) {
+		skb_queue_tail(&hdev->queue[HIF_TYPE_WIM], skb);
+	} else {
+		skb_queue_tail(&hdev->queue[hif->type], skb);
+	}
+#endif
+
+	if (nw->workqueue == NULL) {
+		return -1;
+	}
+
+	queue_work(nw->workqueue, &hdev->work);
+	return 0;
+}
+
+/**
+ * nrc_hif_tx_wim - trasmit a wim message to target
+ */
+int nrc_xmit_wim(struct nrc *nw, struct sk_buff *skb, enum HIF_SUBTYPE stype)
+{
+	struct hif *hif;
+	struct ieee80211_tx_info *txi = IEEE80211_SKB_CB(skb);
+	struct ieee80211_vif *vif = txi->control.vif;
+	int len = skb->len;
+	int ret = 0;
+
+	if ((nw->drv_state == NRC_DRV_PS) &&
+		atomic_read(&nw->d_deauth.delayed_deauth)) {
+		dev_kfree_skb(skb);
+		return 0;
+	}
+
+	/* Prepend HIF header */
+	hif = (struct hif *)skb_push(skb, sizeof(struct hif));
+	memset(hif, 0, sizeof(*hif));
+	hif->type = HIF_TYPE_WIM;
+	hif->subtype = stype;
+	hif->len = len;
+	if (atomic_read(&nw->d_deauth.delayed_deauth))
+		hif->vifindex = nw->d_deauth.vif_index;
+	else
+		hif->vifindex = hw_vifindex(vif);
+
+#if defined(CONFIG_NRC_HIF_PRINT_TX_DATA)
+	nrc_dump_wim(skb);
+	print_hex_dump(KERN_DEBUG, "wim: ", DUMP_PREFIX_NONE, 16, 1,
+		       skb->data, skb->len, false);
+#endif
+
+	if (!nw->loopback)
+		ret = nrc_hif_enqueue_skb(nw, skb);
+	else
+		nrc_hif_free_skb(nw, skb);
+
+	if (ret < 0)
+		nrc_hif_free_skb(nw, skb);
+
+	return ret;
+}
+
+int nrc_xmit_wim_request(struct nrc *nw, struct sk_buff *skb)
+{
+	return nrc_xmit_wim(nw, skb, HIF_WIM_SUB_REQUEST);
+}
+
+struct sk_buff *nrc_xmit_wim_request_wait(struct nrc *nw,
+		struct sk_buff *skb, int timeout)
+{
+	nw->last_wim_responded = NULL;
+
+	if (nrc_xmit_wim(nw, skb, HIF_WIM_SUB_REQUEST) < 0)
+		return NULL;
+
+	if (nw->last_wim_responded) {
+		pr_err("received already");
+		return nw->last_wim_responded;
+	}
+
+	reinit_completion(&nw->wim_responded);
+	if (wait_for_completion_timeout(&nw->wim_responded,
+			timeout) == 0)
+		return NULL;
+
+	return nw->last_wim_responded;
+}
+
+int nrc_xmit_wim_response(struct nrc *nw, struct sk_buff *skb)
+{
+	return nrc_xmit_wim(nw, skb, HIF_WIM_SUB_RESPONSE);
+}
+
+/**
+ * nrc_skb_append_tx_info - Appends tx meta data to the end of skb
+ *
+ */
+static u32 nrc_skb_append_tx_info(struct nrc *nw, u16 aid,
+			struct sk_buff *skb,
+			bool frame_injection)
+{
+	struct ieee80211_tx_info *txi = IEEE80211_SKB_CB(skb);
+	struct frame_tx_info_param *p;
+
+	if (skb_tailroom(skb) < tlv_len(sizeof(*p))) {
+		if (WARN_ON(pskb_expand_head(skb, 0, tlv_len(sizeof(*p)),
+					GFP_ATOMIC)))
+			return 0;
+	}
+
+	p = nrc_wim_skb_add_tlv(skb, WIM_TLV_EXTRA_TX_INFO, sizeof(*p), NULL);
+#ifdef CONFIG_SUPPORT_TX_CONTROL
+	p->use_rts = txi->control.use_rts;
+	p->use_11b_protection = txi->control.use_cts_prot;
+	p->short_preamble = txi->control.short_preamble;
+#endif
+	p->ampdu = !!(txi->flags & IEEE80211_TX_CTL_AMPDU);
+	p->after_dtim = !!(txi->flags & IEEE80211_TX_CTL_SEND_AFTER_DTIM);
+	p->no_ack = !!(txi->flags & IEEE80211_TX_CTL_NO_ACK);
+	p->eosp = 0;
+	p->inject = !!(frame_injection || wlantest);
+	p->aid = aid;
+
+#if defined(CONFIG_NRC_HIF_PRINT_TX_INFO)
+	nrc_dbg(NRC_DBG_TX,
+			"rts:%d cts_prot:%d sp:%d amdpu:%d noack:%d eosp:%d",
+			p->use_rts, p->use_cts_prot,
+			p->short_preamble, p->ampdu, p->no_ack, p->eosp);
+#endif
+
+	return tlv_len(sizeof(*p));
+}
+
+/**
+ * nrc_xmit_injected_frame - transmit a injected 802.11 frame
+ */
+int nrc_xmit_injected_frame(struct nrc *nw,
+			struct ieee80211_vif *vif,
+			struct ieee80211_sta *sta,
+			struct sk_buff *skb)
+{
+	struct ieee80211_hdr *hdr = (void *)skb->data;
+	struct frame_hdr *fh;
+	struct hif *hif;
+	__le16 fc = hdr->frame_control;
+	struct ieee80211_tx_info *txi = IEEE80211_SKB_CB(skb);
+	int extra_len, ret = 0;
+	int credit;
+
+	extra_len = nrc_skb_append_tx_info(nw, (!!sta ? sta->aid : 0), skb, true);
+
+	/* Prepend a HIF and frame header */
+	hif = (void *)skb_push(skb, nw->fwinfo.tx_head_size);
+	memset(hif, 0, nw->fwinfo.tx_head_size);
+	hif->type = HIF_TYPE_FRAME;
+	hif->len = skb->len - sizeof(*hif);
+	hif->vifindex = hw_vifindex(vif);
+
+	/* Frame header */
+	fh = (void *)(hif + 1);
+	fh->info.tx.tlv_len = extra_len;
+	fh->info.tx.cipher = WIM_CIPHER_TYPE_NONE;
+#ifdef CONFIG_SUPPORT_TX_CONTROL
+	fh->flags.tx.ac = txi->hw_queue;
+#endif
+
+	if (ieee80211_is_data(fc)) {
+		hif->subtype = HIF_FRAME_SUB_DATA_BE;
+	} else if (ieee80211_is_mgmt(fc)) {
+		hif->subtype = HIF_FRAME_SUB_MGMT;
+		if(enable_usn)
+			fh->flags.tx.ac = (hif->vifindex == 0 ? 1 : 7);
+		else
+			fh->flags.tx.ac = (hif->vifindex == 0 ? 3 : 9);
+	} else if (ieee80211_is_ctl(fc)) {
+		hif->subtype = HIF_FRAME_SUB_CTRL;
+		fh->flags.tx.ac = (hif->vifindex == 0 ? 3 : 9);
+	} else {
+		WARN_ON(true);
+	}
+
+	credit = DIV_ROUND_UP(skb->len, nw->fwinfo.buffer_size);
+#ifdef CONFIG_NRC_HIF_PRINT_FLOW_CONTROL
+	nrc_dbg(NRC_DBG_HIF, "%s ac:%d, pend:%d, credit:%d\n", __func__,
+			fh->flags.tx.ac,
+			atomic_read(&nw->tx_pend[fh->flags.tx.ac]), credit);
+#endif
+	atomic_add(credit, &nw->tx_pend[fh->flags.tx.ac]);
+	ret = nrc_hif_enqueue_skb(nw, skb);
+	if (ret < 0)
+		nrc_hif_free_skb(nw, skb);
+
+	return ret;
+}
+
+/**
+ * nrc_xmit_frame - transmit a 802.11 frame
+ */
+int nrc_xmit_frame(struct nrc *nw, s8 vif_index, u16 aid,
+			struct sk_buff *skb)
+{
+	struct ieee80211_hdr *hdr = (void *)skb->data;
+	struct frame_hdr *fh;
+	struct hif *hif;
+	__le16 fc = hdr->frame_control;
+	struct ieee80211_tx_info *txi = IEEE80211_SKB_CB(skb);
+	struct ieee80211_key_conf *key = txi->control.hw_key;
+	int extra_len, ret = 0;
+	int credit;
+#if defined(CONFIG_SUPPORT_KEY_RESERVE_TAILROOM)
+	int crypto_tail_len = 0;
+#endif
+
+	if (atomic_read(&nw->d_deauth.delayed_deauth)) {
+		if (key) {
+			key = &nw->d_deauth.p;
+		}
+	}
+
+#if defined(CONFIG_SUPPORT_KEY_RESERVE_TAILROOM)
+	if ((key && (key->flags & IEEE80211_KEY_FLAG_RESERVE_TAILROOM))
+			&& (nw->cap.cap_mask & WIM_SYSTEM_CAP_HWSEC_OFFL)) {
+		switch (key->cipher) {
+		case WLAN_CIPHER_SUITE_WEP40:
+		case WLAN_CIPHER_SUITE_WEP104:
+			crypto_tail_len = IEEE80211_WEP_ICV_LEN;
+			break;
+		case WLAN_CIPHER_SUITE_TKIP:
+			crypto_tail_len = IEEE80211_TKIP_ICV_LEN;
+			break;
+		case WLAN_CIPHER_SUITE_CCMP:
+			crypto_tail_len = IEEE80211_CCMP_MIC_LEN;
+			break;
+#ifdef CONFIG_SUPPORT_CCMP_256
+		case WLAN_CIPHER_SUITE_CCMP_256:
+			crypto_tail_len = IEEE80211_CCMP_256_MIC_LEN;
+			break;
+#endif
+		default:
+			nrc_dbg(NRC_DBG_MAC,
+				"%s: Unknown cipher detected.(%d)"
+					, __func__);
+		}
+		skb_put(skb, crypto_tail_len);
+	}
+#endif
+
+	extra_len = nrc_skb_append_tx_info(nw, aid, skb, false);
+
+	/* Prepend a HIF and frame header */
+	hif = (void *)skb_push(skb, nw->fwinfo.tx_head_size);
+	memset(hif, 0, nw->fwinfo.tx_head_size);
+	hif->type = HIF_TYPE_FRAME;
+	hif->len = skb->len - sizeof(*hif);
+	hif->vifindex = vif_index;
+
+	/* Frame header */
+	fh = (void *)(hif + 1);
+	fh->info.tx.tlv_len = extra_len;
+	fh->info.tx.cipher = WIM_CIPHER_TYPE_NONE;
+#ifdef CONFIG_SUPPORT_TX_CONTROL
+	fh->flags.tx.ac = txi->hw_queue;
+#endif
+
+	if (key) {
+		if (!ieee80211_has_protected(fc))
+			nrc_dbg(NRC_DBG_TX, "Key found but protected frame bit is 0.");
+		fh->info.tx.cipher = nrc_to_wim_cipher_type(key->cipher);
+		if (fh->info.tx.cipher == (uint8_t) WIM_CIPHER_TYPE_INVALID) {
+			if (ieee80211_has_protected(fc)) {
+				nrc_dbg(NRC_DBG_TX, "protected frame bit is 1 but invalid cipher type(%d).",
+						 key->cipher);
+				dev_kfree_skb(skb);
+				return ret;
+			}
+			fh->info.tx.cipher = WIM_CIPHER_TYPE_NONE;
+		}
+	}
+
+	/*
+	 * TODO:
+	 * - vif index
+	 */
+	if (ieee80211_is_data(fc)) {
+		hif->subtype = HIF_FRAME_SUB_DATA_BE;
+		/* temporarily use a BE hw_queue instead of the invalid value. */
+		if (fh->flags.tx.ac > 9) {
+			nrc_dbg(NRC_DBG_TX, "%s vif(%d): Invaid ac(%d) from mac80211\n",
+				__func__, hif->vifindex, fh->flags.tx.ac);
+			fh->flags.tx.ac = (hif->vifindex == 0 ? 1 : 7);
+		}
+	} else if (ieee80211_is_mgmt(fc)) {
+		hif->subtype = HIF_FRAME_SUB_MGMT;
+		if(enable_usn)
+			fh->flags.tx.ac = (hif->vifindex == 0 ? 1 : 7);
+		else
+			fh->flags.tx.ac = (hif->vifindex == 0 ? 3 : 9);
+	} else if (ieee80211_is_ctl(fc)) {
+		hif->subtype = HIF_FRAME_SUB_CTRL;
+		fh->flags.tx.ac = (hif->vifindex == 0 ? 3 : 9);
+	} else {
+		WARN_ON(true);
+	}
+
+	if (nullfunc_enable) {
+		if (ieee80211_is_pspoll(fc)) {
+			print_hex_dump(KERN_DEBUG, "tx ps-poll ", DUMP_PREFIX_NONE, 16, 1,
+				fh, 20, false);
+		}
+	}
+#if defined(CONFIG_NRC_HIF_PRINT_TX_DATA)
+	print_hex_dump(KERN_DEBUG, "frame: ", DUMP_PREFIX_NONE, 16, 1,
+		skb->data, skb->len, false);
+#endif
+	credit = DIV_ROUND_UP(skb->len, nw->fwinfo.buffer_size);
+#ifdef CONFIG_NRC_HIF_PRINT_FLOW_CONTROL
+	nrc_dbg(NRC_DBG_HIF, "%s ac:%d, pend:%d, credit:%d\n", __func__,
+			fh->flags.tx.ac,
+			atomic_read(&nw->tx_pend[fh->flags.tx.ac]), credit);
+#endif
+	atomic_add(credit, &nw->tx_pend[fh->flags.tx.ac]);
+
+	if (!nw->loopback)
+		ret = nrc_hif_enqueue_skb(nw, skb);
+	else
+		nrc_hif_free_skb(nw, skb);
+
+	if (ret < 0)
+		nrc_hif_free_skb(nw, skb);
+
+	return ret;
+}
+
+static int lb_cnt;
+int nrc_hif_rx(struct nrc_hif_device *dev, const u8 *data, const u32 len)
+{
+	struct nrc *nw = to_nw(dev);
+	struct sk_buff *skb;
+	struct hif *hif = (void *)data;
+
+	WARN_ON(len < sizeof(struct hif));
+
+	if (nw->loopback) {
+		int i;
+		uint8_t *ptr;
+
+		nrc_dbg(NRC_DBG_HIF, "[%s] loopback receive success.\n",
+				__func__);
+		lb_cnt++;
+		for (i = 0; i < len; i++)
+			nrc_dbg(NRC_DBG_HIF, "%02X ", *(data + i));
+
+		skb = dev_alloc_skb(len);
+		if (!skb)
+			return 0;
+
+		ptr = (uint8_t *)skb_put(skb, len);
+		memcpy(ptr, data, len);
+		nrc_hif_debug_send(nw, skb);
+
+		return 0;
+	}
+
+	skb = dev_alloc_skb(hif->len);
+	memcpy(skb_put(skb, hif->len), data + sizeof(*hif), hif->len);
+
+	switch (hif->type) {
+	case HIF_TYPE_FRAME:
+		nrc_mac_rx(nw, skb);
+		break;
+	case HIF_TYPE_WIM:
+		nrc_wim_rx(nw, skb, hif->subtype);
+		break;
+	default:
+		dev_kfree_skb(skb);
+		BUG();
+	}
+	return 0;
+}
+
+void nrc_hif_debug_send(struct nrc *nw, struct sk_buff *skb)
+{
+	int ret = 0;
+
+	ret = nrc_hif_enqueue_skb(nw, skb);
+	if (ret < 0)
+		nrc_hif_free_skb(nw, skb);
+}
+
+int nrc_hif_debug_rx(void)
+{
+	nrc_dbg(NRC_DBG_HIF, "Disabled HIF Loopback mode.(%d)\n", lb_cnt);
+	return lb_cnt;
+}
+
+static int hif_receive_skb(struct nrc_hif_device *dev, struct sk_buff *skb)
+{
+	struct nrc *nw = to_nw(dev);
+	struct hif *hif = (void *)skb->data;
+#if defined(DEBUG)
+	struct hif_lb_hdr *hif_new;
+	ktime_t *t;
+	u8 *str[] = {"LOOPBACK ", "", "DATA "};
+	u8 *p;
+	u32 *d;
+#endif
+
+	WARN_ON(skb->len != hif->len + sizeof(*hif));
+
+	if (nw->drv_state < NRC_DRV_START) {
+		dev_kfree_skb(skb);
+		return -EIO;
+	}
+	skb_pull(skb, sizeof(*hif));
+
+	//nrc_recovery_wdt_kick(nw);
+
+	switch (hif->type) {
+	case HIF_TYPE_FRAME:
+		/*nrc_handle_frame(nw, skb);*/
+		nrc_mac_rx(nw, skb);
+		break;
+	case HIF_TYPE_WIM:
+		nrc_wim_rx(nw, skb, hif->subtype);
+		break;
+	case HIF_TYPE_LOG:
+		nrc_netlink_rx(nw, skb, hif->subtype);
+		break;
+	case HIF_TYPE_DUMP:
+		nrc_dbg(NRC_DBG_HIF, "HIF_TYPE_DUMP - lenth: %d", hif->len);
+		/* print_hex_dump(KERN_DEBUG, "core dump ", DUMP_PREFIX_NONE,
+		 *		16, 1, skb->data, hif->len, false);
+		 */
+		nrc_dump_store((char *)skb->data, hif->len);
+		dev_kfree_skb(skb);
+		break;
+#if defined(DEBUG)
+	case HIF_TYPE_LOOPBACK:
+		t = (ktime_t*)(skb->data + 36);
+		hif_new = (struct hif_lb_hdr*)(skb->data - sizeof(struct hif));
+
+		rcv_time_last = ktime_to_us(ktime_get());
+		if (hif_new->subtype == LOOPBACK_MODE_RX_ONLY) {
+			(time_info_array + hif_new->index)->_i = hif_new->index;
+		}
+		if (hif_new->subtype != LOOPBACK_MODE_TX_ONLY) {
+			(time_info_array + hif_new->index)->_rxt = rcv_time_last;
+		}
+		if (hif_new->index == 0) {
+			rcv_time_first = rcv_time_last;
+			pr_err("[Loopback Test] First frame received time: %llu", rcv_time_first);
+		}
+
+		if (hif_new->subtype == LOOPBACK_MODE_TX_ONLY) {
+			d = (u32*)(skb->data);
+			arv_time_first = *d;
+			arv_time_last = *(d + 2);
+			pr_err("[Loopback Test][TX only] -- test done --\n\n\n\n\n");
+		} else {
+			if (hif_new->index > hif_new->count - 4) {
+				if (lb_hexdump) {
+					print_hex_dump(KERN_DEBUG, "HIF ", DUMP_PREFIX_NONE,
+							16, 1, skb->data - sizeof(struct hif), 8, false);
+					p = skb->data + 36;
+					print_hex_dump(KERN_DEBUG, str[hif_new->subtype], DUMP_PREFIX_NONE,
+							16, 1, skb->data, skb->len, false);
+				}
+				d = (u32*)(skb->data);
+				arv_time_first = *d;
+				arv_time_last = *(d + 2);
+			}
+			if (hif_new->index == hif_new->count - 1) {
+				pr_err("[Loopback Test] Last frame received time: %llu\n\n", rcv_time_last);
+				if (hif_new->subtype == LOOPBACK_MODE_ROUNDTRIP) {
+					pr_err("[Loopback Test][Round-trip] -- test done --\n\n\n\n\n");
+				} else if (hif_new->subtype == LOOPBACK_MODE_RX_ONLY) {
+					pr_err("[Loopback Test][RX only] -- test done --\n\n\n\n\n");
+				}
+			}
+		}
+		dev_kfree_skb(skb);
+		break;
+#endif
+	default:
+		print_hex_dump(KERN_DEBUG, "hif type err ", DUMP_PREFIX_NONE,
+				16, 1, skb->data, skb->len > 32 ? 32 : skb->len, false);
+		dev_kfree_skb(skb);
+	}
+	return 0;
+}
+
+int nrc_hif_wakeup_device(struct nrc_hif_device *dev)
+{
+	if (dev->hif_ops->wakeup) {
+		dev->hif_ops->wakeup(dev);
+		return 0;
+	}
+
+	return -1;
+}
+
+int nrc_hif_reset_device(struct nrc_hif_device *dev)
+{
+	if (dev->hif_ops->reset) {
+		dev->hif_ops->reset(dev);
+		return 0;
+	}
+
+	return -1;
+}
+
+int nrc_hif_test_status(struct nrc_hif_device *dev)
+{
+	if (dev->hif_ops->test)
+		dev->hif_ops->test(dev);
+	return 0;
+}
+
+void nrc_hif_sync_lock(struct nrc_hif_device *dev)
+{
+	if (dev->hif_ops->sync_lock && !dev->hif_ops->sync_auto)
+		dev->hif_ops->sync_lock(dev);
+}
+
+void nrc_hif_sync_unlock(struct nrc_hif_device *dev)
+{
+	if (dev->hif_ops->sync_unlock && !dev->hif_ops->sync_auto)
+		dev->hif_ops->sync_unlock(dev);
+}
+
+/**
+ * nrc_hif_cleanup - cleanup skb in hdev queue
+ *
+ * This function is called from nrc_hif_exit()
+ */
+
+void nrc_hif_cleanup(struct nrc_hif_device *dev)
+{
+	struct sk_buff *skb;
+	int i;
+
+	for (i = ARRAY_SIZE(dev->queue)-1; i >= 0; i--) {
+		for (;;) {
+			skb = skb_dequeue(&dev->queue[i]);
+			if (!skb)
+				break;
+			dev_kfree_skb(skb);
+		}
+	}
+}
+
+void nrc_hif_flush_wq(struct nrc_hif_device *dev)
+{
+	struct nrc *nw;
+
+	BUG_ON(dev == NULL);
+	nw = to_nw(dev);
+	BUG_ON(nw == NULL);
+
+	nrc_hif_cleanup(dev);
+	if (nw->workqueue != NULL)
+		flush_work(&dev->work);
+}
+
+int nrc_hif_close(struct nrc_hif_device *dev)
+{
+	if (dev->hif_ops->close)
+		dev->hif_ops->close(dev);
+	return 0;
+}
+
+int nrc_hif_exit(struct nrc_hif_device *dev)
+{
+	struct nrc *nw;
+	struct nrc_txq *ntxq;
+	int i;
+
+	if (dev == NULL)
+		return 0;
+
+	nw = to_nw(dev);
+
+	BUG_ON(dev == NULL);
+	BUG_ON(nw == NULL);
+
+	for (i = 0; i < NRC_QUEUE_MAX; i++) {
+		ntxq = &nw->ntxq[i];
+		skb_queue_purge(&ntxq->queue);
+#ifdef CONFIG_CHECK_DATA_SIZE
+		ntxq->data_size = 0;
+#endif
+	}
+
+	if (nw->workqueue != NULL)
+		flush_work(&dev->work);
+
+	nrc_hif_stop(dev);
+	nrc_hif_cleanup(dev);
+
+#if defined(CONFIG_NRC_HIF_SSP)
+	return nrc_hif_ssp_exit(dev);
+#elif defined(CONFIG_NRC_HIF_UART)
+	return nrc_hif_uart_exit(dev);
+#elif defined(CONFIG_NRC_HIF_DEBUG)
+	return nrc_hif_debug_exit(dev);
+#elif defined(CONFIG_NRC_HIF_CSPI)
+	return nrc_hif_cspi_exit(dev);
+#elif defined(CONFIG_NRC_HIF_SDIO)
+	return nrc_hif_sdio_exit(dev);
+#else
+	return 0;
+#endif
+}
diff --git a/drivers/staging/nrc/mac80211-ext.c b/drivers/staging/nrc/mac80211-ext.c
new file mode 100755
index 000000000000..a9098276cd20
--- /dev/null
+++ b/drivers/staging/nrc/mac80211-ext.c
@@ -0,0 +1,186 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <net/mac80211.h>
+#include "nrc-mac80211.h"
+#include "nrc-debug.h"
+#include "mac80211-ext.h"
+#include "compat.h"
+
+
+/**
+ * ieee80211_find_all_sta() - finds a sta which has not been uploaded.
+ *
+ * @vif: pointers to vif currently being searched against.
+ * @addr: sta address
+ *
+ * This is an extension to ieee80211_find_sta() which only returns
+ * 'uploaded' sta. This function searches for all sta that the driver
+ * has seen.
+ *
+ * NOTE:
+ * - This function should be called under RCU lock, and the resulting
+ *   pointer is only valid under RCU lock as well.
+ */
+struct ieee80211_sta *ieee80211_find_all_sta(struct ieee80211_vif *vif,
+					     u8 *addr)
+{
+	struct ieee80211_sta *sta;
+	struct nrc_vif *i_vif = to_i_vif(vif);
+	struct nrc_sta *i_sta = NULL, *tmp = NULL;
+	unsigned long flags;
+
+	/* First find the 'uploaded' sta */
+	sta = ieee80211_find_sta(vif, addr);
+	if (sta)
+		return sta;
+
+	spin_lock_irqsave(&i_vif->preassoc_sta_lock, flags);
+
+	list_for_each_entry_safe(i_sta, tmp, &i_vif->preassoc_sta_list, list) {
+		sta = to_ieee80211_sta(i_sta);
+
+		if (ether_addr_equal(sta->addr, addr))
+			goto out;
+
+	}
+
+	sta = NULL;
+ out:
+	spin_unlock_irqrestore(&i_vif->preassoc_sta_lock, flags);
+
+	return sta;
+}
+
+u8 *ieee80211_append_ie(struct sk_buff *skb, u8 eid, u8 len)
+{
+	u8 *pos;
+
+	if (WARN_ON(skb_tailroom(skb) < len + 2))
+		return NULL;
+
+	pos = skb_put(skb, len + 2);
+	*pos++ = eid;
+	*pos++ = len;
+
+	return pos;
+}
+
+struct sk_buff *ieee80211_deauth_get(struct ieee80211_hw *hw,
+				     u8 *da, u8 *sa, u8 *bssid,
+				     __le16 reason, struct ieee80211_sta *sta, bool tosta)
+{
+	struct nrc *nw = hw->priv;
+	struct sk_buff *skb;
+	struct ieee80211_mgmt *deauth;
+	struct ieee80211_rx_status *status;
+	struct nrc_sta *i_sta;
+	struct ieee80211_tx_info *txi;
+
+	__le16 fc;
+	u32 ccmp_mic_len = 0;
+	u16 *reason_code;
+	u8 ccmp_hdr[8] = {0xfe,0x00,0x00,0x20,0x00,0x00,0x00,0x00};
+
+	if (nw == NULL || sta == NULL)
+		return NULL;
+
+	nrc_mac_dbg("%s: cipher_pairwise:%d\n", __func__, nw->cipher_pairwise);
+	if (nw->cipher_pairwise == WLAN_CIPHER_SUITE_AES_CMAC) {
+		/* PMF Handling */
+		if(tosta) ccmp_mic_len = 8; /* only need CCMP hdr. MIC will appended on Target */
+		else ccmp_mic_len = 16; /* need CCMP + MIC hdr */
+	}
+
+	nrc_mac_dbg("%s: ccmp_mic_len:%d\n", __func__, ccmp_mic_len);
+
+	/* Normal Deauth (TRX) : MAC HDR (24B) + REASON(2B)
+	  PMF Deauth (RX): MAC HDR (24B) + CCMP(8B) + REASON(2B) + MIC (8B)
+	  PMF Deauth (TX): MAC HDR (24B) + CCMP(8B) + REASON(2B) */
+	skb = dev_alloc_skb(hw->extra_tx_headroom + 26 + ccmp_mic_len);
+	if (!skb)
+		return NULL;
+
+	skb_reserve(skb, hw->extra_tx_headroom);
+
+	deauth = (struct ieee80211_mgmt *) skb_put(skb, 26 + ccmp_mic_len);
+	memset(deauth, 0, 26 + ccmp_mic_len);
+
+	deauth->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
+						IEEE80211_STYPE_DEAUTH);
+
+	if (ccmp_mic_len) {
+		/* add protected bit in FC for PMF */
+		deauth->frame_control |= cpu_to_le16(IEEE80211_FCTL_PROTECTED);
+	}
+
+	ether_addr_copy(deauth->da, da);
+	ether_addr_copy(deauth->sa, sa);
+	ether_addr_copy(deauth->bssid, bssid);
+
+	fc = deauth->frame_control;
+	if (ieee80211_has_protected(fc)) {
+		memcpy ((u8 *)(((u8 *) deauth) + 24), ccmp_hdr, 8);
+		reason_code = (u16 *)(((u8 *) deauth) + 32);
+		*reason_code = reason;
+
+		if (tosta) {
+			i_sta = to_i_sta(sta);
+			txi = IEEE80211_SKB_CB(skb);
+			if (txi) {
+				txi->control.hw_key = i_sta->ptk;
+				//nrc_mac_dbg("%s: set txi\n", __func__);
+			}
+		} else {
+			status = IEEE80211_SKB_RXCB(skb);
+			status->flag |= RX_FLAG_DECRYPTED;
+			status->flag |= RX_FLAG_MMIC_STRIPPED;
+			status->flag |= RX_FLAG_PN_VALIDATED;
+		}
+	} else {
+		deauth->u.deauth.reason_code = reason;
+	}
+
+#if 0
+	status = IEEE80211_SKB_RXCB(skb);
+	nrc_mac_dbg("%s: status->flag:%d\n", __func__, status->flag);
+	print_hex_dump(KERN_DEBUG, "deauth frame: ", DUMP_PREFIX_NONE, 16, 1,
+			skb->data, skb->len, false);
+#endif
+
+	return skb;
+}
+
+/**
+ * ieee80211_iterate_netdev - iterate active net_device
+ */
+void ieee80211_iterate_active_netdev(struct ieee80211_hw *hw,
+				     void (*iterator)(void *data,
+						      struct net_device *dev),
+				     void *data)
+{
+	struct net_device *dev = NULL;
+
+	for_each_netdev_rcu(wiphy_net(hw->wiphy), dev) {
+
+		if (dev->dev.parent != wiphy_dev(hw->wiphy) ||
+		    !netif_running(dev))
+			continue;
+
+		iterator(data, dev);
+	}
+}
diff --git a/drivers/staging/nrc/mac80211-ext.h b/drivers/staging/nrc/mac80211-ext.h
new file mode 100755
index 000000000000..6c8befc87fd9
--- /dev/null
+++ b/drivers/staging/nrc/mac80211-ext.h
@@ -0,0 +1,84 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * mac80211 extension
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef __MAC80211_EXT_H__
+#define __MAC80211_EXT_H__
+
+#include <net/mac80211.h>
+
+struct bss_max_idle_period_ie {
+	__le16 max_idle_period;
+	u8 idle_option;
+} __packed;
+
+#ifdef CONFIG_SUPPORT_AFTER_KERNEL_3_0_36
+#else
+static inline void eth_zero_addr(u8 *addr)
+{
+	memset(addr, 0x00, ETH_ALEN);
+}
+
+static inline bool ether_addr_equal(const u8 *addr1, const u8 *addr2)
+{
+#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)
+	u32 fold = ((*(const u32 *)addr1) ^ (*(const u32 *)addr2)) |
+		   ((*(const u16 *)(addr1 + 4)) ^ (*(const u16 *)(addr2 + 4)));
+
+	return fold == 0;
+#else
+	const u16 *a = (const u16 *)addr1;
+	const u16 *b = (const u16 *)addr2;
+
+	return ((a[0] ^ b[0]) | (a[1] ^ b[1]) | (a[2] ^ b[2])) == 0;
+#endif
+}
+
+static inline void ether_addr_copy(u8 *dst, const u8 *src)
+{
+#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)
+	*(u32 *)dst = *(const u32 *)src;
+	*(u16 *)(dst + 4) = *(const u16 *)(src + 4);
+#else
+	u16 *a = (u16 *)dst;
+	const u16 *b = (const u16 *)src;
+
+	a[0] = b[0];
+	a[1] = b[1];
+	a[2] = b[2];
+#endif
+}
+#endif
+
+static inline u32 ieee80211_usf_to_sf(u8 usf)
+{
+	return (usf == 1) ? 10 : (usf == 2) ? 1000 : (usf == 3) ? 10000 : 1;
+}
+
+struct ieee80211_sta *ieee80211_find_all_sta(struct ieee80211_vif *vif,
+					     u8 *adddr);
+
+u8 *ieee80211_append_ie(struct sk_buff *skb, u8 eid, u8 len);
+
+struct sk_buff *ieee80211_deauth_get(struct ieee80211_hw *hw, u8 *da, u8 *sa,
+				     u8 *bssid, __le16 reason, struct ieee80211_sta *sta, bool tosta);
+
+void ieee80211_iterate_active_netdev(struct ieee80211_hw *hw,
+				     void (*iterator)(void *data,
+						      struct net_device *dev),
+				     void *data);
+
+#endif
diff --git a/drivers/staging/nrc/make_qsdk.sh b/drivers/staging/nrc/make_qsdk.sh
new file mode 100755
index 000000000000..f78be79fd131
--- /dev/null
+++ b/drivers/staging/nrc/make_qsdk.sh
@@ -0,0 +1,13 @@
+#!/bin/sh
+#export KDIR=/mnt/sdb1/qsdk/qca/src/linux-3.14
+export KDIR=/mnt/sdb1/qsdk/build_dir/target-arm_cortex-a7_uClibc-1.0.14_eabi/linux-ipq806x/linux-3.14.77
+export NRCLINUXHOSTIDR=/mnt/sdb1/qsdk/build_dir/target-arm_cortex-a7_uClibc-1.0.14_eabi/linux-ipq806x/backports-20161201-3.14.77-9ab3068
+export ARCH=arm
+export STAGING_DIR=/mnt/sdb1/qsdk/staging_dir
+export CROSS_COMPILE=/mnt/sdb1/qsdk/staging_dir/toolchain-arm_cortex-a7_gcc-4.8-linaro_uClibc-1.0.14_eabi/bin/arm-openwrt-linux-
+echo $KDIR
+echo $NRCLINUXHOSTIDR
+echo $STAGING_DIR
+echo $ARCH
+echo $CROSS_COMPILE
+make
diff --git a/drivers/staging/nrc/nrc-bd.c b/drivers/staging/nrc/nrc-bd.c
new file mode 100755
index 000000000000..e35421d990ae
--- /dev/null
+++ b/drivers/staging/nrc/nrc-bd.c
@@ -0,0 +1,827 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/syscalls.h>
+#include <linux/fcntl.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/stat.h>
+#include <asm/uaccess.h>
+#include "nrc.h"
+#include "nrc-bd.h"
+#include "nrc-debug.h"
+#include "nrc-wim-types.h"
+
+#if defined(CONFIG_SUPPORT_BD)
+
+#define NRC_BD_FILE_MAX_LENGTH	4096
+#define NRC_BD_MAX_DATA_LENGTH	546
+#define NRC_BD_HEADER_LENGTH	16
+char g_bd_buf[NRC_BD_FILE_MAX_LENGTH] = {0, };
+int g_bd_size=0;
+
+enum {
+	CC_US=1,
+	CC_JP,
+	CC_KR,
+	CC_TW,
+	CC_EU,
+	CC_CN,
+	CC_NZ,
+	CC_AU,
+	CC_MAX,
+}CC_TYPE;
+
+const struct bd_ch_table *g_bd_ch_table_base;
+struct bd_supp_param g_supp_ch_list;
+
+static const struct bd_ch_table g_bd_ch_table[CC_MAX][NRC_BD_MAX_CH_LIST] = {
+	{
+		/* US */
+		{9025,	2412,	1,	1},
+		{9035,	2422,	3,	3},
+		{9045,	2432,	5,	5},
+		{9055,	2442,	7,	7},
+		{9065,	2452,	9,	9},
+		{9075,	2462,	11,	11},
+		{9085,	5180,	13,	36},
+		{9095,	5185,	15,	37},
+		{9105,	5190,	17,	38},
+		{9115,	5195,	19,	39},
+		{9125,	5200,	21,	40},
+		{9135,	5205,	23,	41},
+		{9145,	5210,	25,	42},
+		{9155,	5215,	27,	43},
+		{9165,	5220,	29,	44},
+		{9175,	5225,	31,	45},
+		{9185,	5230,	33,	46},
+		{9195,	5235,	35,	47},
+		{9205,	5240,	37,	48},
+		{9215,	5745,	39,	149},
+		{9225,	5750,	41,	150},
+		{9235,	5755,	43,	151},
+		{9245,	5760,	45,	152},
+		{9255,	5500,	47,	100},
+		{9265,	5520,	49,	104},
+		{9275,	5540,	51,	108},
+		{9030,	2417,	2,	2},
+		{9050,	2437,	6,	6},
+		{9070,	2457,	10,	10},
+		{9090,	5765,	14,	153},
+		{9110,	5770,	18,	154},
+		{9130,	5775,	22,	155},
+		{9150,	5780,	26,	156},
+		{9170,	5785,	30,	157},
+		{9190,	5790,	34,	158},
+		{9210,	5795,	38,	159},
+		{9230,	5800,	42,	160},
+		{9250,	5805,	46,	161},
+		{9270,	5560,	50,	112},
+		{9060,	2447,	8,	8},
+		{9100,	5810,	16,	162},
+		{9140,	5815,	24,	163},
+		{9180,	5820,	32,	164},
+		{9220,	5825,	40,	165},
+		{9260,	5580,	48,	116}
+	},
+	{
+		/* New Japan */
+		{9210,  5200,   9,   40},
+		{9230,  5210,   13,  42},
+		{9240,  5215,   15,  43},
+		{9250,  5220,   17,  44},
+		{9260,  5225,   19,  45},
+		{9270,  5230,   21,  46},
+		{9235,  5180,   2,   36},
+		{9245,  5185,   4,   37},
+		{9255,  5190,   6,   38},
+		{9265,  5195,   8,   39},
+		{9245,  5235,   36,  47},
+		{9255,  5240,   38,  48}
+	},
+	{
+		// Korea MIC Band (925MH~931MHz)
+		{9255,  5180,   1,      36},
+		{9265,  5185,   3,      37},
+		{9275,  5190,   5,      38},
+		{9285,  5195,   7,      39},
+		{9295,  5200,   9,      40},
+		{9305,  5205,   11,     41},
+		{9280,  5210,   4,      42},
+		{9300,  5215,   8,      43}
+	},
+	{
+		/*  Taiwan */
+		{8390,  5180,    1, 36},
+		{8400,  5185,    3, 37},
+		{8410,  5190,    5, 38},
+		{8420,  5195,    7, 39},
+		{8430,  5200,    9, 40},
+		{8440,  5205,   11, 41},
+		{8450,  5210,   13, 42},
+		{8460,  5215,   15, 43},
+		{8470,  5220,   17, 44},
+		{8480,  5225,   19, 45},
+		{8490,  5230,   21, 46},
+		{8500,  5235,   23, 47},
+		{8510,  5240,   25, 48},
+		{8395,  5745,    2, 149},
+		{8415,  5750,    6, 150},
+		{8435,  5755,   10, 151},
+		{8455,  5760,   14, 152},
+		{8475,  5765,   18, 153},
+		{8495,  5770,   22, 154},
+		{8405,  5775,    4, 155},
+		{8445,  5780,   12, 156},
+		{8485,  5785,   20, 157}
+	},
+	{
+		/* EU */
+		{8635,  5180,   1, 36},
+		{8645,  5185,   3, 37},
+		{8655,  5190,   5, 38},
+		{8665,  5195,   7, 39},
+		{8675,  5200,   9, 40},
+		{8640,  5205,   2, 41},
+		{8660,  5210,   6, 42},
+	},
+	{
+		/* CN */
+		{7555,	5180,	1,	36},
+		{7565,	5185,	3,	37},
+		{7575,	5190,	5,	38},
+		{7585,	5195,	7,	39},
+		{7595,	5200,	9,	40},
+		{7605,	5205,	11,	41},
+		{7615,	5210,	13,	42},
+		{7625,	5215,	15,	43},
+		{7635,	5220,	17,	44},
+		{7645,	5225,	19,	45},
+		{7655,	5230,	21,	46},
+		{7665,	5235,	23,	47},
+		{7675,	5240,	25,	48},
+		{7685,	5745,	27,	149},
+		{7695,	5750,	29,	150},
+		{7705,	5755,	31,	151},
+		{7795,	5760,	16,	152},
+		{7805,	5765,	18,	153},
+		{7815,	5770,	20,	154},
+		{7825,	5775,	22,	155},
+		{7835,	5780,	24,	156},
+		{7845,	5785,	26,	157},
+		{7855,	5790,	28,	158},
+		{7865,	5795,	30,	159},
+		{7800,	5800,	2,	160},
+		{7820,	5805,	6,	161},
+		{7840,	5810,	10,	162},
+		{7860,	5815,	14,	163},
+		{7810,	5820,	4,	164},
+		{7850,	5825,	12,	165}
+	},
+	{
+		/* NZ */
+		{9155,	5180,	27, 36},
+		{9165,	5185,	29, 37},
+		{9175,	5190,	31, 38},
+		{9185,	5195,	33, 39},
+		{9195,	5200,	35, 40},
+		{9205,	5205,	37, 41},
+		{9215,	5210,	39, 42},
+		{9225,	5215,	41, 43},
+		{9235,	5220,	43, 44},
+		{9245,	5225,	45, 45},
+		{9255,	5230,	47, 46},
+		{9265,	5235,	49, 47},
+		{9275,	5240,	51, 48},
+		{9170,	5765,	30, 153},
+		{9190,	5770,	34, 154},
+		{9210,	5775,	38, 155},
+		{9230,	5780,	42, 156},
+		{9250,	5785,	46, 157},
+		{9270,	5790,	50, 158},
+		{9180,	5810,	32, 162},
+		{9220,	5815,	40, 163},
+		{9260,	5820,	48, 164}
+	},
+	{
+		/* AU */
+		{9155,	5180,	27, 36},
+		{9165,	5185,	29, 37},
+		{9175,	5190,	31, 38},
+		{9185,	5195,	33, 39},
+		{9195,	5200,	35, 40},
+		{9205,	5205,	37, 41},
+		{9215,	5210,	39, 42},
+		{9225,	5215,	41, 43},
+		{9235,	5220,	43, 44},
+		{9245,	5225,	45, 45},
+		{9255,	5230,	47, 46},
+		{9265,	5235,	49, 47},
+		{9275,	5240,	51, 48},
+		{9170,	5765,	30, 153},
+		{9190,	5770,	34, 154},
+		{9210,	5775,	38, 155},
+		{9230,	5780,	42, 156},
+		{9250,	5785,	46, 157},
+		{9270,	5790,	50, 158},
+		{9180,	5810,	32, 162},
+		{9220,	5815,	40, 163},
+		{9260,	5820,	48, 164}
+	},
+};
+
+static const struct bd_ch_table g_bd_ch_table_usn[CC_MAX][NRC_BD_MAX_CH_LIST] = {
+	{
+		/* US */
+		{9025,	2412,	1,	1},
+		{9035,	2422,	3,	3},
+		{9045,	2432,	5,	5},
+		{9055,	2442,	7,	7},
+		{9065,	2452,	9,	9},
+		{9075,	2462,	11,	11},
+		{9085,	5180,	13,	36},
+		{9095,	5185,	15,	37},
+		{9105,	5190,	17,	38},
+		{9115,	5195,	19,	39},
+		{9125,	5200,	21,	40},
+		{9135,	5205,	23,	41},
+		{9145,	5210,	25,	42},
+		{9155,	5215,	27,	43},
+		{9165,	5220,	29,	44},
+		{9175,	5225,	31,	45},
+		{9185,	5230,	33,	46},
+		{9195,	5235,	35,	47},
+		{9205,	5240,	37,	48},
+		{9215,	5745,	39,	149},
+		{9225,	5750,	41,	150},
+		{9235,	5755,	43,	151},
+		{9245,	5760,	45,	152},
+		{9255,	5500,	47,	100},
+		{9265,	5520,	49,	104},
+		{9275,	5540,	51,	108},
+		{9030,	2417,	2,	2},
+		{9050,	2437,	6,	6},
+		{9070,	2457,	10,	10},
+		{9090,	5765,	14,	153},
+		{9110,	5770,	18,	154},
+		{9130,	5775,	22,	155},
+		{9150,	5780,	26,	156},
+		{9170,	5785,	30,	157},
+		{9190,	5790,	34,	158},
+		{9210,	5795,	38,	159},
+		{9230,	5800,	42,	160},
+		{9250,	5805,	46,	161},
+		{9270,	5560,	50,	112},
+		{9060,	2447,	8,	8},
+		{9100,	5810,	16,	162},
+		{9140,	5815,	24,	163},
+		{9180,	5820,	32,	164},
+		{9220,	5825,	40,	165},
+		{9260,	5580,	48,	116}
+	},
+	{
+		/* New Japan */
+		{9210,  5200,   9,   40},
+		{9230,  5210,   13,  42},
+		{9240,  5215,   15,  43},
+		{9250,  5220,   17,  44},
+		{9260,  5225,   19,  45},
+		{9270,  5230,   21,  46},
+		{9235,  5180,   2,   36},
+		{9245,  5185,   4,   37},
+		{9255,  5190,   6,   38},
+		{9265,  5195,   8,   39},
+		{9245,  5235,   36,  47},
+		{9255,  5240,   38,  48}
+	},
+	{
+		// Korea USN band (921MH~923MH)
+		{9215,  5220,   1,      44},
+		{9225,  5225,   3,      45}
+	},
+	{
+		/*  Taiwan */
+		{8390,  5180,    1, 36},
+		{8400,  5185,    3, 37},
+		{8410,  5190,    5, 38},
+		{8420,  5195,    7, 39},
+		{8430,  5200,    9, 40},
+		{8440,  5205,   11, 41},
+		{8450,  5210,   13, 42},
+		{8460,  5215,   15, 43},
+		{8470,  5220,   17, 44},
+		{8480,  5225,   19, 45},
+		{8490,  5230,   21, 46},
+		{8500,  5235,   23, 47},
+		{8510,  5240,   25, 48},
+		{8395,  5745,    2, 149},
+		{8415,  5750,    6, 150},
+		{8435,  5755,   10, 151},
+		{8455,  5760,   14, 152},
+		{8475,  5765,   18, 153},
+		{8495,  5770,   22, 154},
+		{8405,  5775,    4, 155},
+		{8445,  5780,   12, 156},
+		{8485,  5785,   20, 157}
+	},
+	{
+		/* EU */
+		{8635,  5180,   1, 36},
+		{8645,  5185,   3, 37},
+		{8655,  5190,   5, 38},
+		{8665,  5195,   7, 39},
+		{8675,  5200,   9, 40},
+		{8640,  5205,   2, 41},
+		{8660,  5210,   6, 42},
+	},
+	{
+		/* CN */
+		{7555,	5180,	1,	36},
+		{7565,	5185,	3,	37},
+		{7575,	5190,	5,	38},
+		{7585,	5195,	7,	39},
+		{7595,	5200,	9,	40},
+		{7605,	5205,	11,	41},
+		{7615,	5210,	13,	42},
+		{7625,	5215,	15,	43},
+		{7635,	5220,	17,	44},
+		{7645,	5225,	19,	45},
+		{7655,	5230,	21,	46},
+		{7665,	5235,	23,	47},
+		{7675,	5240,	25,	48},
+		{7685,	5745,	27,	149},
+		{7695,	5750,	29,	150},
+		{7705,	5755,	31,	151},
+		{7795,	5760,	16,	152},
+		{7805,	5765,	18,	153},
+		{7815,	5770,	20,	154},
+		{7825,	5775,	22,	155},
+		{7835,	5780,	24,	156},
+		{7845,	5785,	26,	157},
+		{7855,	5790,	28,	158},
+		{7865,	5795,	30,	159},
+		{7800,	5800,	2,	160},
+		{7820,	5805,	6,	161},
+		{7840,	5810,	10,	162},
+		{7860,	5815,	14,	163},
+		{7810,	5820,	4,	164},
+		{7850,	5825,	12,	165}
+	},
+	{
+		/* NZ */
+		{9155,	5180,	27, 36},
+		{9165,	5185,	29, 37},
+		{9175,	5190,	31, 38},
+		{9185,	5195,	33, 39},
+		{9195,	5200,	35, 40},
+		{9205,	5205,	37, 41},
+		{9215,	5210,	39, 42},
+		{9225,	5215,	41, 43},
+		{9235,	5220,	43, 44},
+		{9245,	5225,	45, 45},
+		{9255,	5230,	47, 46},
+		{9265,	5235,	49, 47},
+		{9275,	5240,	51, 48},
+		{9170,	5765,	30, 153},
+		{9190,	5770,	34, 154},
+		{9210,	5775,	38, 155},
+		{9230,	5780,	42, 156},
+		{9250,	5785,	46, 157},
+		{9270,	5790,	50, 158},
+		{9180,	5810,	32, 162},
+		{9220,	5815,	40, 163},
+		{9260,	5820,	48, 164}
+	},
+	{
+		/* AU */
+		{9155,	5180,	27, 36},
+		{9165,	5185,	29, 37},
+		{9175,	5190,	31, 38},
+		{9185,	5195,	33, 39},
+		{9195,	5200,	35, 40},
+		{9205,	5205,	37, 41},
+		{9215,	5210,	39, 42},
+		{9225,	5215,	41, 43},
+		{9235,	5220,	43, 44},
+		{9245,	5225,	45, 45},
+		{9255,	5230,	47, 46},
+		{9265,	5235,	49, 47},
+		{9275,	5240,	51, 48},
+		{9170,	5765,	30, 153},
+		{9190,	5770,	34, 154},
+		{9210,	5775,	38, 155},
+		{9230,	5780,	42, 156},
+		{9250,	5785,	46, 157},
+		{9270,	5790,	50, 158},
+		{9180,	5810,	32, 162},
+		{9220,	5815,	40, 163},
+		{9260,	5820,	48, 164}
+	},
+};
+
+static uint16_t nrc_checksum_16(uint16_t len, uint8_t* buf)
+{
+	uint32_t checksum = 0;
+	int i = 0;
+
+	//len = Total num of bytes
+	while(len > 0)
+	{
+		//get two bytes at a time and  add previous calculated checsum value
+		checksum = ((buf[i]) + (buf[i+1]<<8)) + checksum;
+
+		//decrease by 2 for 2 byte boundaries
+		len -= 2;
+		i += 2;
+	}
+
+	//Add the carryout
+	checksum = (checksum>>16) + checksum;
+
+	// if 1's complement
+	//checksum = (unsigned int)~checksum;
+
+	return checksum;
+}
+
+static void * nrc_dump_load(int len)
+{
+	struct file *filp;
+	loff_t pos=0;
+	mm_segment_t old_fs;
+	char filepath[64];
+	char *buf = NULL;
+#if BD_DEBUG
+	int i;
+#endif
+
+	sprintf(filepath, "/lib/firmware/%s", bd_name);
+#if KERNEL_VERSION(5,0,0) > NRC_TARGET_KERNEL_VERSION
+	old_fs = get_fs();
+	set_fs( get_ds() );
+#elif KERNEL_VERSION(5,10,0) > NRC_TARGET_KERNEL_VERSION
+	old_fs = get_fs();
+	set_fs( KERNEL_DS );
+#else
+	old_fs = force_uaccess_begin();
+#endif
+
+	filp = filp_open(filepath, O_RDONLY, 0);
+	if (IS_ERR(filp)) {
+		pr_err("Failed to load board data, error:%d",IS_ERR(filp));
+#if KERNEL_VERSION(5,10,0) > NRC_TARGET_KERNEL_VERSION
+	set_fs(old_fs);
+#else
+	force_uaccess_end(old_fs);
+#endif
+		return NULL;
+	}
+
+	buf = (char *) kmalloc(len, GFP_KERNEL);
+	if (!buf) {
+		pr_err("malloc input buf error!\n");
+		return NULL;
+	}
+
+#if KERNEL_VERSION(4, 14, 0) <= NRC_TARGET_KERNEL_VERSION
+	kernel_read(filp, buf, len, &pos);
+#else
+	kernel_read(filp, pos, buf, len);
+#endif
+
+	filp_close(filp, NULL);
+#if KERNEL_VERSION(5,10,0) > NRC_TARGET_KERNEL_VERSION
+	set_fs(old_fs);
+#else
+	force_uaccess_end(old_fs);
+#endif
+
+#if BD_DEBUG
+	for(i=0; i < len;) {
+		nrc_dbg(NRC_DBG_STATE,"%02X %02X %02X %02X %02X %02X %02X %02X",
+				buf[i + 0],
+				buf[i + 1],
+				buf[i + 2],
+				buf[i + 3],
+				buf[i + 4],
+				buf[i + 5],
+				buf[i + 6],
+				buf[i + 7]);
+		i += 8;
+	}
+#endif
+
+	return buf;
+}
+
+uint16_t nrc_get_non_s1g_freq(uint8_t cc_index, uint8_t s1g_ch_index)
+{
+	int i;
+	uint16_t ret = 0;
+
+	if (enable_usn) {
+		g_bd_ch_table_base = &g_bd_ch_table_usn[cc_index - 1][0];
+	} else {
+		g_bd_ch_table_base = &g_bd_ch_table[cc_index - 1][0];
+	}
+	for(i=0; i < NRC_BD_MAX_CH_LIST; i++) {
+		if(s1g_ch_index == g_bd_ch_table_base[i].s1g_freq_index) {
+			ret = g_bd_ch_table_base[i].nons1g_freq;
+			break;
+		}
+	}
+	return ret;
+}
+
+bool nrc_set_supp_ch_list(struct wim_bd_param *bd)
+{
+	int i, j;
+	bool ret = false;
+	int length = (int)bd->length - 4;
+	uint8_t *pos = bd->value;
+	uint8_t cc_idx = bd->type;
+	uint8_t s1g_ch_idx = 0;
+
+	memset(&g_supp_ch_list, 0, sizeof(struct bd_supp_param));
+
+	if(!(*pos))
+		return ret;
+	else
+		ret = true;
+
+	for(i=0; i < NRC_BD_MAX_CH_LIST; i++) {
+		if((*pos) && (length > 0)) {
+			g_supp_ch_list.num_ch++;
+			g_supp_ch_list.s1g_ch_index[i] = *pos;
+			length -= 12;
+			pos += 12;
+		} else {
+			break;
+		}
+	}
+
+	for(j=0; j < g_supp_ch_list.num_ch; j++) {
+		s1g_ch_idx = g_supp_ch_list.s1g_ch_index[j];
+		g_supp_ch_list.nons1g_ch_freq[j] = 
+			nrc_get_non_s1g_freq(cc_idx, s1g_ch_idx);
+	}
+
+#if BD_DEBUG
+	nrc_dbg(NRC_DBG_STATE,"Supported Channel(%u) Index",g_supp_ch_list.num_ch);
+	for(i=0; i < g_supp_ch_list.num_ch; i++) {
+		nrc_dbg(NRC_DBG_STATE,"%u %u",
+				g_supp_ch_list.s1g_ch_index[i],
+				g_supp_ch_list.nons1g_ch_freq[i]);
+	}
+#endif
+
+	return ret;
+}
+
+struct wim_bd_param * nrc_read_bd_tx_pwr(struct nrc *nw, uint8_t *country_code)
+{
+	uint8_t cc_index = CC_US;
+	uint16_t len = 0;
+	uint8_t type = 0;
+	int i, j;
+	struct BDF *bd;
+	uint8_t cc[2] = {0,0};
+	struct wim_bd_param *bd_sel;
+	bool check_bd_flag=false;
+	uint16_t target_version;
+
+	if(!g_bd_size)
+		return NULL;
+	else
+		nrc_dbg(NRC_DBG_STATE,"size of bd file is %d",g_bd_size);
+
+	cc[0] = *country_code;
+	cc[1] = *(country_code + 1);
+
+	if(cc[0] == 'U' && cc[1] == 'S')
+		cc_index = CC_US;
+	else if(cc[0] == 'J' && cc[1] == 'P')
+		cc_index = CC_JP;
+	else if(cc[0] == 'K' && cc[1] == 'R')
+		cc_index = CC_KR;
+	else if(cc[0] == 'T' && cc[1] == 'W')
+		cc_index = CC_TW;
+	else if(cc[0] == 'D' && cc[1] == 'E')
+		cc_index = CC_EU;
+	else if(cc[0] == 'C' && cc[1] == 'N')
+		cc_index = CC_CN;
+	else if(cc[0] == 'N' && cc[1] == 'Z')
+		cc_index = CC_NZ;
+	else if(cc[0] == 'A' && cc[1] == 'U')
+		cc_index = CC_AU;
+	else {
+		nrc_dbg(NRC_DBG_STATE,
+				"[ERR] Invalid country code(%c%c). Set default value(%d)",
+				cc[0], cc[1], cc_index);
+		return NULL;
+	}
+
+	bd = (struct BDF *)nrc_dump_load(g_bd_size);
+	if(!bd) {
+		nrc_dbg(NRC_DBG_STATE,"bd is NULL");
+		return NULL;
+	}
+
+	nrc_dbg(NRC_DBG_STATE, "Major %02X Minor %02X Total len %04X Num_Data_Groups %04X Checksum %04X",
+			bd->ver_major, bd->ver_minor, bd->total_len, bd->num_data_groups, bd->checksum_data);
+
+#if BD_DEBUG
+	for(i=0; i < bd->total_len;) {
+		nrc_dbg(NRC_DBG_STATE,"%02X %02X %02X %02X %02X %02X %02X %02X",
+				bd->data[i + 0],
+				bd->data[i + 1],
+				bd->data[i + 2],
+				bd->data[i + 3],
+				bd->data[i + 4],
+				bd->data[i + 5],
+				bd->data[i + 6],
+				bd->data[i + 7]);
+		i += 8;
+	}
+#endif
+
+	bd_sel = kmalloc(sizeof(*bd_sel), GFP_KERNEL);
+	if (!bd_sel) {
+		nrc_dbg(NRC_DBG_STATE,"[ERROR] bd_sel is NULL");
+		kfree(bd);
+		return NULL;
+	}
+	memset(bd_sel, 0, sizeof(*bd_sel));
+
+	//find target version from board data file and compare it with one getting from serial flash 
+	target_version = nw->fwinfo.hw_version;
+
+	// if a value of h/w version is invalid, then set it to 0
+	if(target_version > 0x7FF)
+		target_version = 0;
+
+	for(i = 0; i < bd->num_data_groups; i++)
+	{
+		type = bd->data[len + 4*i];
+		//nrc_dbg(NRC_DBG_STATE, "type : %u, cc_index: %u",type, cc_index);
+		if(type == cc_index) {
+			// copy data for specific country code
+			//nrc_dbg(NRC_DBG_STATE, "cc_index is matched(%u : %u)",type, cc_index);
+			bd_sel->type = (uint16_t)type;
+
+			bd_sel->hw_version = (uint16_t)(bd->data[6 + len + 4*i] +
+					(bd->data[7 + len + 4*i]<<8));
+
+			// Add a condition if target version is initial value(65535)
+			if(target_version == bd_sel->hw_version) {
+				nrc_dbg(NRC_DBG_STATE, "target version is matched(%u : %u)",
+						target_version, bd_sel->hw_version);
+
+				bd_sel->length = (uint16_t)(bd->data[2 + len + 4*i] +
+						(bd->data[3 + len + 4*i]<<8));
+				bd_sel->checksum = (uint16_t)(bd->data[4 + len + 4*i] +
+						(bd->data[5 + len + 4*i]<<8));
+
+				for(j=0; j < bd_sel->length -2; j++) {
+					bd_sel->value[j] = bd->data[8 + len + 4*i + j];
+				}
+				check_bd_flag = true;
+				nrc_dbg(NRC_DBG_STATE, "type %04X, len %04X, checksum %04X target_ver %04X",
+						bd_sel->type, bd_sel->length, bd_sel->checksum, bd_sel->hw_version);
+				break;
+			} else {
+				nrc_dbg(NRC_DBG_STATE, "target version is not matched(%u : %u)",
+						target_version, bd_sel->hw_version);
+
+				
+			}
+		}
+		len += (uint16_t)(bd->data[2 + len + 4*i] +
+				(bd->data[3 + len + 4*i]<<8));
+	}
+
+	kfree(bd);
+
+	if(check_bd_flag && nrc_set_supp_ch_list(bd_sel)) {
+		return bd_sel;
+	} else {
+		kfree(bd_sel);
+		return NULL;
+	}
+}
+
+int nrc_check_bd(void)
+{
+	struct BDF *bd;
+	struct file *filp;
+	loff_t pos=0;
+#if KERNEL_VERSION(5, 10, 0) <= NRC_TARGET_KERNEL_VERSION
+	int rc;
+#endif
+
+	struct kstat *stat;
+	char *buf;
+	size_t length;
+	int ret;
+	mm_segment_t old_fs;
+	char filepath[64];
+
+	sprintf(filepath, "/lib/firmware/%s", bd_name);
+#if KERNEL_VERSION(5,0,0) > NRC_TARGET_KERNEL_VERSION
+	old_fs = get_fs();
+	set_fs(get_ds());
+#elif KERNEL_VERSION(5,10,0) > NRC_TARGET_KERNEL_VERSION
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+#else
+	old_fs = force_uaccess_begin();
+#endif
+
+	filp = filp_open(filepath, O_RDONLY, 0);
+	if (IS_ERR(filp)) {
+		pr_err("Failed to load board data :error: %d",IS_ERR(filp));
+#if KERNEL_VERSION(5,10,0) > NRC_TARGET_KERNEL_VERSION
+		set_fs(old_fs);
+#else
+		force_uaccess_end(old_fs);
+#endif
+		return -EIO;
+	}
+
+	stat = (struct kstat *) kmalloc(sizeof(struct kstat), GFP_KERNEL);
+	if(!stat)
+		return -ENOMEM;
+
+#if KERNEL_VERSION(5, 10, 0) <= NRC_TARGET_KERNEL_VERSION
+	rc = vfs_getattr(&filp->f_path, stat, STATX_SIZE, AT_STATX_SYNC_AS_STAT);
+	if(rc != 0){
+        nrc_common_dbg("vfs_getattr Error");
+    }
+	length = (size_t)stat->size;
+#else
+	vfs_stat(filepath, stat);
+	length = (size_t)stat->size;
+#endif
+
+	buf = (char *) kmalloc((int)length, GFP_KERNEL);
+	if(!buf) {
+		kfree(stat);
+		pr_err("buf is NULL");
+		return -ENOMEM;
+	}
+
+#if KERNEL_VERSION(4, 14, 0) <= NRC_TARGET_KERNEL_VERSION
+	g_bd_size = kernel_read(filp, buf, (int)length, &pos);
+#else
+	g_bd_size = kernel_read(filp, pos, buf, (int)length);
+#endif
+	filp_close(filp, NULL);
+#if KERNEL_VERSION(5,10,0) > NRC_TARGET_KERNEL_VERSION
+	set_fs(old_fs);
+#else
+	force_uaccess_end(old_fs);
+#endif
+	kfree(stat);
+
+	if(g_bd_size < NRC_BD_HEADER_LENGTH) {
+		pr_err("Invalid data size(%d)", g_bd_size);
+		kfree(buf);
+		return -EINVAL;
+	}
+
+	bd = (struct BDF *)buf;
+
+	if((bd->total_len > g_bd_size-NRC_BD_HEADER_LENGTH) || (bd->total_len < NRC_BD_HEADER_LENGTH)) {
+		pr_err("Invalid total length(%d)", bd->total_len);
+		kfree(buf);
+		return -EINVAL;
+	}
+
+	ret = nrc_checksum_16(bd->total_len, (uint8_t *)&bd->data[0]);
+	if(bd->checksum_data != ret) {
+		pr_err("Invalid checksum(%u : %u)", bd->checksum_data, ret);
+		kfree(buf);
+		return -EINVAL;
+	}
+
+	kfree(buf);
+
+	return 0;
+}
+#endif /* #if defined(CONFIG_SUPPORT_BD) */
diff --git a/drivers/staging/nrc/nrc-bd.h b/drivers/staging/nrc/nrc-bd.h
new file mode 100755
index 000000000000..fe98cf8504d5
--- /dev/null
+++ b/drivers/staging/nrc/nrc-bd.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _NRC_BD_H_
+#define _NRC_BD_H_
+
+#define NRC_BD_MAX_CH_LIST		45
+
+#define BD_DEBUG	0
+
+struct BDF {
+	uint8_t	ver_major;
+	uint8_t	ver_minor;
+	uint16_t total_len;
+	
+	uint16_t num_data_groups;
+	uint16_t reserved[4];
+	uint16_t checksum_data;
+	
+	uint8_t data[0];
+};
+
+struct bd_ch_table {
+	uint16_t    s1g_freq;
+	uint16_t    nons1g_freq;
+	uint8_t     s1g_freq_index;
+	uint16_t    nons1g_freq_index;
+};
+
+struct bd_supp_param {
+	uint8_t num_ch;
+	uint8_t s1g_ch_index[NRC_BD_MAX_CH_LIST];
+	uint16_t nons1g_ch_freq[NRC_BD_MAX_CH_LIST];
+};
+
+#if defined(CONFIG_SUPPORT_BD)
+extern struct bd_supp_param g_supp_ch_list;
+extern bool g_bd_valid;
+
+struct wim_bd_param * nrc_read_bd_tx_pwr(struct nrc *nw, uint8_t *cc);
+int nrc_check_bd(void);
+#endif /* defined(CONFIG_SUPPORT_BD) */
+
+#endif //_NRC_BD_H_
diff --git a/drivers/staging/nrc/nrc-build-config.h b/drivers/staging/nrc/nrc-build-config.h
new file mode 100755
index 000000000000..930e507b3001
--- /dev/null
+++ b/drivers/staging/nrc/nrc-build-config.h
@@ -0,0 +1,161 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _NRC_BUILD_CONFIG_H_
+#define _NRC_BUILD_CONFIG_H_
+
+#include <linux/version.h>
+
+#define NRC_BUILD_USE_HWSCAN
+/* #define CONFIG_NRC_HIF_PRINT_BEACON */
+/* #define CONFIG_NRC_HIF_PRINT_RX_AUTH */
+/* #define CONFIG_NRC_HIF_PRINT_RX_DATA */
+/* #define CONFIG_NRC_HIF_PRINT_TX_MGMT */
+/* #define CONFIG_NRC_HIF_PRINT_TX_DATA */
+/* #define CONFIG_NRC_HIF_PRINT_FLOW_CONTROL */
+/* #define CONFIG_NRC_HIF_DUMP_S1G_RXINFO */
+
+/*#define NRC_TEST_SUPPRESS_STA_KEEEP_ALIVE*/
+
+/*#define CONFIG_SPI_HALF_DUPLEX*/
+
+/*
+ * README This is a temporary feature.
+ * Use only NRC7392
+ */
+#ifndef CONFIG_SPI_HALF_DUPLEX
+#define CONFIG_CHECK_READY
+#endif
+
+/*
+ * README This is a temporary feature.
+ * Use only 11n certification
+ */
+/* #define CONFIG_TRX_BACKOFF */
+
+/*
+ * README This is a temporary feature.
+ * To change the transmission order of txq in the nrc driver.
+ */
+/* #define CONFIG_TXQ_ORDER_CHANGE_NRC_DRV */
+
+
+/*
+ * These depend on kernel version.
+ */
+/*
+ * #define NRC_TARGET_KERNEL_VERSION KERNEL_VERSION(4, 4, 1)
+ */
+#define NRC_TARGET_KERNEL_VERSION LINUX_VERSION_CODE
+
+#if KERNEL_VERSION(4, 10, 0) <= NRC_TARGET_KERNEL_VERSION
+#define GENL_ID_GENERATE 0
+#endif
+#if KERNEL_VERSION(4, 8, 0) <= NRC_TARGET_KERNEL_VERSION
+#define CONFIG_USE_CFG80211_SCAN_INFO
+#endif
+#if KERNEL_VERSION(4, 7, 0) <= NRC_TARGET_KERNEL_VERSION
+#define CONFIG_USE_NEW_BAND_ENUM
+#endif
+#if KERNEL_VERSION(4, 6, 0) <= NRC_TARGET_KERNEL_VERSION
+#define CONFIG_USE_IEEE80211_AMPDU_PARAMS
+#endif
+#if KERNEL_VERSION(4, 4, 0) <= NRC_TARGET_KERNEL_VERSION
+#define CONFIG_SUPPORT_NEW_AMPDU_ACTION
+#endif
+#if KERNEL_VERSION(4, 3, 0) <= NRC_TARGET_KERNEL_VERSION
+#define CONFIG_USE_IFF_NO_QUEUE_FLAG
+#endif
+#if KERNEL_VERSION(4, 2, 0) <= NRC_TARGET_KERNEL_VERSION
+#define CONFIG_SUPPORT_LONG_HWFLAG
+#endif
+#if KERNEL_VERSION(4, 1, 0) <= NRC_TARGET_KERNEL_VERSION
+#define CONFIG_USE_TXQ
+#define CONFIG_USE_IFACE_ITER
+#define CONFIG_USE_CHANNEL_CONTEXT
+#endif
+#if KERNEL_VERSION(4, 0, 0) <= NRC_TARGET_KERNEL_VERSION
+#define CONFIG_SUPPORT_CCMP_256
+#define CONFIG_SUPPORT_KEY_RESERVE_TAILROOM
+#endif
+#if KERNEL_VERSION(3, 19, 0) <= NRC_TARGET_KERNEL_VERSION
+#define CONFIG_SUPPORT_IFTYPE_OCB
+#define CONFIG_SUPPORT_HWDEV_NAME
+#endif
+#if KERNEL_VERSION(3, 17, 0) <= NRC_TARGET_KERNEL_VERSION
+#define CONFIG_USE_NEW_SCAN_REQ
+#define CONFIG_USE_NEW_ALLOC_NETDEV
+#endif
+#if KERNEL_VERSION(3, 16, 0) <= NRC_TARGET_KERNEL_VERSION
+#define CONFIG_SUPPORT_BEACON_TEMPLATE
+#define CONFIG_SUPPORT_NEW_FLUSH
+#endif
+#if KERNEL_VERSION(3, 15, 0) <= NRC_TARGET_KERNEL_VERSION
+#define CONFIG_SUPPORT_BSS_MAX_IDLE_PERIOD
+#endif
+#if KERNEL_VERSION(3, 0, 37) <= NRC_TARGET_KERNEL_VERSION
+#define CONFIG_SUPPORT_AFTER_KERNEL_3_0_36
+#define CONFIG_SUPPORT_TX_CONTROL
+#define CONFIG_SUPPORT_CHANNEL_INFO
+#define CONFIG_SUPPORT_ITERATE_INTERFACE
+#define CONFIG_SUPPORT_GENLMSG_DEFAULT
+#define CONFIG_SUPPORT_SPI_SYNC_TRANSFER
+#define CONFIG_NEW_REG_NOTIFIER
+#define CONFIG_USE_HW_QUEUE
+#define CONFIG_USE_MONITOR_VIF
+#define CONFIG_SUPPORT_NEW_NETLINK
+#define CONFIG_SUPPORT_PS
+#define CONFIG_SUPPORT_NEW_MAC_TX
+#define CONFIG_SUPPORT_P2P
+#define CONFIG_SUPPORT_BD
+/* To use JPPC board data file & FW */
+#undef CONFIG_SUPPORT_JPPC
+#endif
+#if KERNEL_VERSION(3, 0, 0) <= NRC_TARGET_KERNEL_VERSION
+#define CONFIG_SUPPORT_TX_FRAMES_PENDING
+#endif
+#if KERNEL_VERSION(2, 6, 30) <= NRC_TARGET_KERNEL_VERSION
+#define CONFIG_SUPPORT_THREADED_IRQ
+#endif
+
+#if KERNEL_VERSION(4, 10, 0) > NRC_TARGET_KERNEL_VERSION
+/* WDS was deprecated and re-enabled with CONFIG_WIRELESS_WDS since 4.10 */
+#define CONFIG_WIRELESS_WDS
+#endif
+
+#if KERNEL_VERSION(4, 2, 0) > NRC_TARGET_KERNEL_VERSION
+#define ieee80211_hw_check(hw, flg) (hw->flags & IEEE80211_HW_##flg)
+#endif
+
+#if defined(CONFIG_WIRELESS_WDS) || defined(CONFIG_USE_CHANNEL_CONTEXT)
+/* Cannot use CONFIG_USE_CHANNEL_CONTEXT) */
+#undef CONFIG_USE_CHANNEL_CONTEXT
+#endif
+
+/* for backports */
+/*
+ * #ifdef CONFIG_USE_IFF_NO_QUEUE_FLAG
+ * #undef CONFIG_USE_IFF_NO_QUEUE_FLAG
+ * #endif
+ */
+
+/* Check tx queue total data size, not just queue length */
+#define CONFIG_CHECK_DATA_SIZE
+
+/* uncomment define below to set tx power via iw */
+/* #define CONFIG_SUPPORT_IW_TXPWR */
+
+#endif
diff --git a/drivers/staging/nrc/nrc-debug.c b/drivers/staging/nrc/nrc-debug.c
new file mode 100755
index 000000000000..b621e9c36934
--- /dev/null
+++ b/drivers/staging/nrc/nrc-debug.c
@@ -0,0 +1,708 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/seq_file.h>
+#include <linux/math64.h>
+#include "nrc-debug.h"
+#include "nrc-hif.h"
+#include "nrc-wim-types.h"
+#include "nrc-stats.h"
+#include "wim.h"
+#include "nrc-hif-cspi.h"
+
+unsigned long nrc_debug_mask;
+static struct nrc *nrc_nw;
+
+void nrc_dbg_init(struct nrc *nw)
+{
+	if (debug_level_all) {
+		nrc_debug_mask = DEFAULT_NRC_DBG_MASK_ALL;
+	} else {
+		nrc_debug_mask = DEFAULT_NRC_DBG_MASK;
+	}
+	nrc_nw = nw;
+}
+
+void nrc_dbg_enable(enum NRC_DEBUG_MASK mk)
+{
+	set_bit(mk, &nrc_debug_mask);
+}
+
+void nrc_dbg_disable(enum NRC_DEBUG_MASK mk)
+{
+	clear_bit(mk, &nrc_debug_mask);
+}
+
+void nrc_dbg(enum NRC_DEBUG_MASK mk, const char *fmt, ...)
+{
+	va_list args;
+	int i;
+	static char buf[512] = {0,};
+
+	if (WARN_ON(!nrc_nw))
+		return;
+
+	if (!test_bit(mk, &nrc_debug_mask))
+		return;
+
+	va_start(args, fmt);
+	i = vsprintf(buf, fmt, args);
+	va_end(args);
+
+	if (!nrc_nw || nrc_nw->loopback || !nrc_nw->pdev)
+		pr_info("%s\n", buf);
+	else
+		dev_dbg(&nrc_nw->pdev->dev, "%s\n", buf);
+}
+
+/* TODO: steve
+ *
+ * Let's move to trace framework.
+ */
+void nrc_mac_dump_frame(struct nrc *nw, struct sk_buff *skb, const char *prefix)
+{
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
+	__le16 fc = hdr->frame_control;
+
+	return;
+
+	if (ieee80211_is_nullfunc(fc) || ieee80211_is_qos_nullfunc(fc)) {
+		nrc_dbg(NRC_DBG_MAC, "%s %snullfunc (%c)",
+			prefix,
+			ieee80211_is_nullfunc(fc) ? "" : "qos",
+			ieee80211_has_pm(fc) ? 'P' : '.');
+	} else if (ieee80211_is_data(fc)) {
+		nrc_dbg(NRC_DBG_MAC, "%s %sdata (%c%c%c%c)", prefix,
+			is_multicast_ether_addr(hdr->addr1) ? "mc-" : "",
+			(fc & cpu_to_le16(IEEE80211_FCTL_TODS)) ? 'T' : '.',
+			(fc & cpu_to_le16(IEEE80211_FCTL_FROMDS)) ? 'F' : '.',
+			(fc & cpu_to_le16(IEEE80211_FCTL_MOREDATA)) ? 'M' : '.',
+			(fc & cpu_to_le16(IEEE80211_FCTL_PM)) ? 'P' : '.');
+	} else if (ieee80211_is_probe_resp(fc)) {
+		nrc_dbg(NRC_DBG_MAC, "%s probe-rsp", prefix);
+	} else if (ieee80211_is_probe_req(fc)) {
+		nrc_dbg(NRC_DBG_MAC, "%s probe-req", prefix);
+	} else if (ieee80211_is_pspoll(fc)) {
+		struct ieee80211_pspoll *pspoll;
+
+		pspoll = (struct ieee80211_pspoll *)hdr;
+		nrc_dbg(NRC_DBG_MAC, "%s ps-poll (aid=%d)", prefix,
+			pspoll->aid & ~0xc000);
+	} else if (ieee80211_is_beacon(fc)) {
+		struct ieee80211_mgmt *mgmt = (void *)skb->data;
+		const u8 *tim;
+		u8 *start, *end;
+		char *str = "";
+
+		start = (u8 *)mgmt->u.beacon.variable;
+		end = skb->data + skb->len;
+		tim = cfg80211_find_ie(WLAN_EID_TIM, start, end - start);
+		if (tim &&
+		    ieee80211_check_tim((struct ieee80211_tim_ie *)&tim[2],
+					tim[1], nw->aid))
+			str = "(tim)";
+
+		nrc_dbg(NRC_DBG_MAC, "%s beacon %s", prefix, str);
+	}
+}
+
+static char *wim_cmd_str[] = {
+	[WIM_CMD_INIT] = "cmd=init",
+	[WIM_CMD_START] = "cmd=start",
+	[WIM_CMD_STOP] = "cmd=stop",
+	[WIM_CMD_SCAN_START] = "cmd=scan-start",
+	[WIM_CMD_SCAN_STOP] = "cmd=scan-stop",
+	[WIM_CMD_SET_KEY] = "cmd=set-key",
+	[WIM_CMD_DISABLE_KEY] = "cmd=disable-key",
+	[WIM_CMD_STA_CMD] = "cmd=sta-cmd",
+	[WIM_CMD_SET] = "cmd=set",
+	[WIM_CMD_REQ_FW] = "cmd=firmware",
+	[WIM_CMD_FW_RELOAD] = "cmd=fw-reload",
+	[WIM_CMD_AMPDU_ACTION] = "cmd=ampd-action",
+	[WIM_CMD_SHELL] = "cmd=shell",
+	[WIM_CMD_SLEEP] = "cmd=sleep",
+};
+
+static char *wim_event_str[] = {
+	[WIM_EVENT_SCAN_COMPLETED] = "event=scan-complete",
+	[WIM_EVENT_READY] = "event=ready",
+	[WIM_EVENT_CREDIT_REPORT] = "event=credit",
+	[WIM_EVENT_PS_READY] = "event=ps-ready",
+};
+
+void nrc_dump_wim(struct sk_buff *skb)
+{
+	struct hif *hif = (void *) skb->data;
+	struct wim *wim = (void *) (hif + 1);
+	u8 stype = hif->subtype;
+
+	nrc_dbg(NRC_DBG_MAC, "wim: %s, vif=%d, seqno=%d, len=%d",
+		stype == HIF_WIM_SUB_REQUEST ? wim_cmd_str[wim->cmd] :
+		stype == HIF_WIM_SUB_EVENT ? wim_event_str[wim->event] :
+		"resp",
+		hif->vifindex, wim->seqno, hif->len);
+}
+
+/* Debugfs */
+
+/* Debug message mask
+ * - TODO: make it more human friendly
+ */
+
+static int nrc_debugfs_debug_read(void *data, u64 *val)
+{
+	*val = nrc_debug_mask;
+	return 0;
+}
+
+static int nrc_debugfs_debug_write(void *data, u64 val)
+{
+	nrc_debug_mask = val;
+
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(nrc_debugfs_debug_fops,
+			nrc_debugfs_debug_read,
+			nrc_debugfs_debug_write,
+			"%llu\n");
+
+static int nrc_debugfs_cspi_status_read(void *data, u64 *val)
+{
+	struct nrc *nw = (struct nrc *)data;
+	struct nrc_hif_device *hdev = nw->hif;
+
+	*val = nrc_hif_test_status(hdev);
+	return 0;
+}
+
+static int nrc_debugfs_cspi_status_write(void *data, u64 val)
+{
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(nrc_debugfs_cspi,
+			nrc_debugfs_cspi_status_read,
+			nrc_debugfs_cspi_status_write,
+			"%llu\n");
+
+static int nrc_debugfs_hif_read(void *data, u64 *val)
+{
+	*val = nrc_hif_debug_rx();
+	return 0;
+}
+
+static int nrc_debugfs_hif_write(void *data, u64 val)
+{
+	struct nrc *nw = (struct nrc *)data;
+	struct sk_buff *skb;
+	struct hif *hif;
+	uint8_t *ptr;
+	int i = 0;
+
+	skb = dev_alloc_skb(val + sizeof(struct hif));
+	if (!skb)
+		return 0;
+
+	ptr = (uint8_t *)skb_put(skb, val);
+	for (i = 0; i < val; i++)
+		*ptr = i;
+
+	skb_reserve(skb, sizeof(struct hif));
+	hif = (struct hif *)skb_push(skb, sizeof(struct hif));
+	hif->type = HIF_TYPE_FRAME;
+	hif->subtype = 0;
+	hif->len = val;
+
+	nw->loopback = true;
+	nrc_hif_debug_send(nw, skb);
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(nrc_debugfs_hif,
+			nrc_debugfs_hif_read,
+			nrc_debugfs_hif_write,
+			"%llu\n");
+
+static int nrc_debugfs_wakeup_device_read(void *data, u64 *val)
+{
+	*val = 0;
+	return 0;
+}
+
+static int nrc_debugfs_wakeup_device_write(void *data, u64 val)
+{
+	struct nrc *nw = (struct nrc *)data;
+	struct nrc_hif_device *hdev = nw->hif;
+
+	nrc_hif_wakeup_device(hdev);
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(nrc_debugfs_wakeup_device,
+			nrc_debugfs_wakeup_device_read,
+			nrc_debugfs_wakeup_device_write,
+			"%llu\n");
+
+
+static int nrc_debugfs_reset_device_read(void *data, u64 *val)
+{
+	*val = 0;
+	return 0;
+}
+
+static int nrc_debugfs_reset_device_write(void *data, u64 val)
+{
+	struct nrc *nw = (struct nrc *)data;
+	struct nrc_hif_device *hdev = nw->hif;
+
+	nrc_hif_reset_device(hdev);
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(nrc_debugfs_reset_device,
+			nrc_debugfs_reset_device_read,
+			nrc_debugfs_reset_device_write,
+			"%llu\n");
+
+static int nrc_debugfs_snr_read(void *data, u64 *val)
+{
+	*val = nrc_stats_snr();
+	return 0;
+}
+
+static int nrc_debugfs_snr_write(void *data, u64 val)
+{
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(nrc_debugfs_snr,
+			nrc_debugfs_snr_read,
+			nrc_debugfs_snr_write,
+			"%llu\n");
+
+static int nrc_debugfs_rssi_read(void *data, u64 *val)
+{
+	*val = nrc_stats_rssi();
+	return 0;
+}
+
+static int nrc_debugfs_rssi_write(void *data, u64 val)
+{
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(nrc_debugfs_rssi,
+			nrc_debugfs_rssi_read,
+			nrc_debugfs_rssi_write,
+			"%lld\n");
+
+#if defined(DEBUG)
+static struct dentry *hspi_debugfs_root;
+#endif
+static struct sk_buff *g_skb;
+static u32 g_skb_len;
+static u32 bunch = 0;
+static u8 lb_subtype;
+static u32 lb_count = 1;
+u32 lb_hexdump = 0;
+s64 tx_time_first;
+s64 tx_time_last;
+s64 rcv_time_first;
+s64 rcv_time_last;
+u32 arv_time_first;
+u32 arv_time_last;
+struct lb_time_info *time_info_array = NULL;
+
+#define TX_SLOT_SIZE	456
+#define RX_SLOT_SIZE	492
+
+static int nrc_debugfs_hexdump_read(void *data, u64 *val)
+{
+	*val = (u64)lb_hexdump;
+	return 0;
+}
+
+static int nrc_debugfs_hexdump_write(void *data, u64 val)
+{
+	lb_hexdump = (u32)val;
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(nrc_debugfs_hexdump,
+			nrc_debugfs_hexdump_read,
+			nrc_debugfs_hexdump_write,
+			"%llu\n");
+
+static int nrc_debugfs_loopback_read(void *data, u64 *val)
+{
+	*val = (u64)lb_subtype;
+	return 0;
+}
+
+static int nrc_debugfs_loopback_write(void *data, u64 val)
+{
+	struct nrc *nw = (struct nrc *)data;
+	struct nrc_hif_device *hdev = nw->hif;
+	struct sk_buff *skb;
+	struct hif_lb_hdr *hif;
+	u32 c = 0;
+
+	lb_subtype = (u8)val;
+	if (lb_subtype >= LOOPBACK_MODE_MAX) {
+		lb_subtype = LOOPBACK_MODE_ROUNDTRIP;
+	}
+
+	if (!g_skb)
+		return 0;
+
+	if (time_info_array) {
+		kfree(time_info_array);
+		time_info_array = NULL;
+	}
+
+	time_info_array = (struct lb_time_info*)kzalloc(sizeof(struct lb_time_info) * lb_count, GFP_KERNEL);
+	if (!time_info_array) {
+		pr_err("Failed to alloc buffers...\n");
+		return 0;
+	}
+	hif = (struct hif_lb_hdr *)g_skb->data;
+
+	if (lb_subtype < LOOPBACK_MODE_RX_ONLY) {
+		while(c < lb_count) {
+			skb = skb_copy(g_skb, GFP_ATOMIC);
+			hif = (struct hif_lb_hdr *)skb->data;
+			hif->index = c++;
+			hif->subtype = lb_subtype;
+			if (c == 1 && lb_hexdump) {
+				print_hex_dump(KERN_DEBUG, "HIF ", DUMP_PREFIX_NONE,
+					16, 1, skb->data, sizeof(struct hif_lb_hdr), false);
+				print_hex_dump(KERN_DEBUG, "ORIGIN ", DUMP_PREFIX_NONE,
+					16, 1, skb->data + sizeof(struct hif_lb_hdr), skb->len - sizeof(struct hif_lb_hdr), false);
+			}
+			skb_queue_tail(&hdev->queue[(hif->type) % 2], skb);
+			if (nw->workqueue == NULL) {
+				return -1;
+			}
+			if (c < 5) {
+				queue_work(nw->workqueue, &hdev->work);
+			}
+		}
+	} else if (lb_subtype == LOOPBACK_MODE_RX_ONLY) {
+		skb = skb_copy(g_skb, GFP_ATOMIC);
+		/*
+		 * In rx only mode, it's not necessary to send all slots.
+		 */
+		skb_trim(skb, 400);
+		hif = (struct hif_lb_hdr *)skb->data;
+		hif->subtype = lb_subtype;
+		if (c == 0 && lb_hexdump) {
+			print_hex_dump(KERN_DEBUG, "HIF ", DUMP_PREFIX_NONE,
+				16, 1, skb->data, sizeof(struct hif_lb_hdr), false);
+			//print_hex_dump(KERN_DEBUG, "ORIGIN ", DUMP_PREFIX_NONE,
+			//	16, 1, skb->data + sizeof(struct hif_lb_hdr), skb->len - sizeof(struct hif_lb_hdr), false);
+		}
+		skb_queue_tail(&hdev->queue[(hif->type) % 2], skb);
+		if (nw->workqueue == NULL) {
+			return -1;
+		}
+		queue_work(nw->workqueue, &hdev->work);
+	}
+	nrc_hif_test_status(hdev);
+	pr_err("[Loopback Test] TX Done.\n");
+
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(nrc_debugfs_loopback,
+			nrc_debugfs_loopback_read,
+			nrc_debugfs_loopback_write,
+			"%llu\n");
+
+static int nrc_debugfs_lb_count_read(void *data, u64 *val)
+{
+	*val = (u64)lb_count;
+	return 0;
+}
+
+static int nrc_debugfs_lb_count_write(void *data, u64 val)
+{
+	lb_count = (u32)val;
+	if (g_skb) {
+		struct hif_lb_hdr *h = (struct hif_lb_hdr*)g_skb->data;
+		h->count = lb_count;
+	}
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(nrc_debugfs_lb_count,
+			nrc_debugfs_lb_count_read,
+			nrc_debugfs_lb_count_write,
+			"%llu\n");
+
+static int nrc_debugfs_hspi_sample_skb(struct seq_file *s, void *data)
+{
+	int i = 0;
+	u8 *p;
+
+	if (!g_skb || g_skb_len == 0) {
+		seq_puts(s, "the sample data is not created yet.\n");
+		return 0;
+	}
+
+	p = (void*)g_skb->data + sizeof(struct hif_lb_hdr);
+	seq_printf(s, "\n* Total length: %d\n", g_skb_len);
+	seq_puts(s, "----------------------------------------------------");
+	while(i < g_skb_len) {
+		if (i % 16 == 0) {
+			seq_printf(s, "\n%03d | ", i / 16 + 1);
+		}
+		seq_printf(s, "%02x ", *(p + i++));
+	}
+	seq_puts(s, "\n\n");
+
+	return 0;
+}
+
+static ssize_t nrc_debugfs_hspi_sample_write(struct file *file, const char __user *ubuf,
+						size_t count, loff_t *ppos)
+{
+	long ret;
+	struct hif_lb_hdr *hif;
+	u8 *p;
+	int i;
+
+	ret = kstrtol_from_user(ubuf, count, 10, (long int*)&g_skb_len);
+	if (ret)
+		return ret;
+	ret = count;
+
+	if (g_skb && g_skb_len > 0 && (g_skb->len != g_skb_len)) {
+		dev_kfree_skb(g_skb);
+	}
+
+	/*
+	 * Maximum length is 1600 bytes.
+	 */
+	if (g_skb_len > 1600) {
+		g_skb_len = 1600;
+	}
+
+	if (g_skb_len) {
+		g_skb = dev_alloc_skb(g_skb_len + sizeof(struct hif_lb_hdr));
+		if (!g_skb)
+			return ret;
+	} else {
+		pr_err("[Loopback Teat] the length of sample data must be bigger than %d.\n", g_skb_len);
+		return ret;
+	}
+
+	p = (u8 *)skb_put(g_skb, (g_skb_len + sizeof(struct hif)));
+	for (i = 0; i < g_skb_len; i++) {
+		*(p + sizeof(struct hif_lb_hdr) + i) = i;
+	}
+
+	hif = (struct hif_lb_hdr *)p;
+	hif->type = HIF_TYPE_LOOPBACK;
+	hif->count = lb_count;
+	hif->subtype = 0;
+	/*
+	 * hif->len: sample size
+	 * skb->len: sample size + sizeof(struct hif)
+	 */
+	hif->len = g_skb_len;
+
+	return ret;
+}
+
+static int nrc_debugfs_hspi_sample_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, nrc_debugfs_hspi_sample_skb, NULL);
+}
+
+static const struct file_operations hspi_sample_ops = {
+	.open		= nrc_debugfs_hspi_sample_open,
+	.read		= seq_read,
+	.write		= nrc_debugfs_hspi_sample_write,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static ssize_t nrc_debugfs_hspi_report_write(struct file *file, const char __user *ubuf,
+						size_t count, loff_t *ppos)
+{
+	long ret;
+
+	ret = kstrtol_from_user(ubuf, count, 10, (long int*)&bunch);
+	if (ret)
+		return ret;
+	ret = count;
+
+	return ret;
+}
+
+#define TIMESTAMP_SUB(x, y)	((x) - (y))
+#define RESET_VARS()	(c = sum_tx = sum_rx = 0)
+#define LB_INFO(x)		((time_info_array + i)->_##x)
+#define LB_INFO_(x)		((time_info_array + i - 1)->_##x)
+#define LB_SUB(x)		((unsigned long)TIMESTAMP_SUB(LB_INFO(x), LB_INFO_(x)))
+
+static int nrc_debugfs_hspi_report(struct seq_file *s, void *data)
+{
+	unsigned int i, slots, tx, rx, c, rl;
+	unsigned long diff;
+	unsigned long long t;
+	unsigned long long sum_tx, sum_rx;
+	u8 *str_type[] = {"Round-trip", "TX only", "RX only"};
+
+	seq_printf(s, "########## SUMMARY (%s) ##########\n", str_type[lb_subtype]);
+	slots = DIV_ROUND_UP(g_skb_len, TX_SLOT_SIZE);
+	seq_printf(s, "1. Total frame counts: %d\n", lb_count);
+	seq_printf(s, "2. Frame length: %d bytes (%d slots)\n", g_skb_len, slots);
+
+	if (lb_subtype == LOOPBACK_MODE_ROUNDTRIP || lb_subtype >= LOOPBACK_MODE_MAX) {
+		rl = (g_skb_len > RX_SLOT_SIZE) ? g_skb_len : RX_SLOT_SIZE;
+		seq_printf(s, "   => Actual tx bytes: %d, Actual rx bytes: %d\n\n", slots * TX_SLOT_SIZE, rl);
+		seq_printf(s, "3. Total tx bytes (HOST -> TARGET): %d bytes\n", tx = lb_count * slots * TX_SLOT_SIZE);
+		seq_printf(s, "4. Total rx bytes (TARGET -> HOST): %d bytes\n", rx = lb_count * rl);
+		seq_printf(s, "   => Total transferred bytes (No.3 + No.4): %llu bytes\n\n", t = (unsigned long long)(tx + rx));
+		seq_printf(s, "5. First frame transmit time: %llu us\n", tx_time_first);
+		seq_printf(s, "6. Last frame transmit time: %llu us\n", tx_time_last);
+		seq_printf(s, "   (diff: %lu us)\n", (unsigned long)TIMESTAMP_SUB(tx_time_last, tx_time_first));
+		seq_printf(s, "7. First frame received time: %llu us\n", rcv_time_first);
+		seq_printf(s, "8. Last frame received time: %llu us\n", rcv_time_last);
+		seq_printf(s, "   (diff: %lu us)\n", (unsigned long)TIMESTAMP_SUB(rcv_time_last, rcv_time_first));
+		seq_printf(s, "   --------------------------------------------\n");
+		seq_printf(s, "   => First frame RTT (No.7 - No.5) : %lu us\n", (unsigned long)TIMESTAMP_SUB(rcv_time_first, tx_time_first));
+		seq_printf(s, "   => Last frame RTT (No.8 - No.6) : %lu us\n", (unsigned long)TIMESTAMP_SUB(rcv_time_last, tx_time_last));
+		seq_printf(s, "   => Time diff (No.8 - No.5) : %lu us\n", diff = (unsigned long)TIMESTAMP_SUB(rcv_time_last, tx_time_first));
+		t *= 7812; // 8(bit) / 1024(kbit) * 1000000(sec) = 7812.5
+		seq_printf(s, "   => Throughput: %llu kbps\n", div_u64(t, diff));
+	} else if (lb_subtype == LOOPBACK_MODE_TX_ONLY) {
+		seq_printf(s, "   => Actual tx bytes: %d\n\n", slots * TX_SLOT_SIZE);
+		seq_printf(s, "3. Total tx bytes (HOST -> TARGET): %lld bytes\n\n", t = (lb_count - 1) * slots * TX_SLOT_SIZE);
+		seq_printf(s, "4. First frame transmit time: %llu us\n", tx_time_first);
+		seq_printf(s, "5. Last frame transmit time: %llu us\n", tx_time_last);
+		seq_printf(s, "   (diff: %lu us)\n", (unsigned long)TIMESTAMP_SUB(tx_time_last, tx_time_first));
+		seq_printf(s, "6. First frame arrival time(TSF in target): %u us\n", arv_time_first);
+		seq_printf(s, "7. Last frame arrival time(TSF in target): %u us\n", arv_time_last);
+		seq_printf(s, "   (diff: %lu us)\n", diff = (arv_time_last - arv_time_first));
+		seq_printf(s, "   --------------------------------------------\n");
+		t *= 7812; // 8(bit) / 1024(kbit) * 1000000(sec) = 7812.5
+		seq_printf(s, "   => Throughput: %llu kbps\n", div_u64(t, diff));
+	} else if (lb_subtype == LOOPBACK_MODE_RX_ONLY) {
+		rl = (g_skb_len > RX_SLOT_SIZE) ? g_skb_len : RX_SLOT_SIZE;
+		seq_printf(s, "   => Actual rx bytes: %d\n\n", rl);
+		seq_printf(s, "3. Total rx bytes (TARGET -> HOST): %lld bytes\n\n", t = (lb_count - 1) * rl);
+		seq_printf(s, "7. First frame received time: %llu us\n", rcv_time_first);
+		seq_printf(s, "8. Last frame received time: %llu us\n", rcv_time_last);
+		seq_printf(s, "   (diff: %lu us)\n", diff = (unsigned long)TIMESTAMP_SUB(rcv_time_last, rcv_time_first));
+		seq_printf(s, "   --------------------------------------------\n");
+		t *= 7812; // 8(bit) / 1024(kbit) * 1000000(sec) = 7812.5
+		seq_printf(s, "   => Throughput: %llu kbps\n", div_u64(t, diff));
+	}
+	if (bunch > 0) {
+		if (time_info_array) {
+			int x = lb_count < 50 ? lb_count : 50;
+			seq_printf(s, "\n########## DETAIL ##########\n");
+			seq_printf(s, "[frame index] [tx time(us)] [time diff with previous(us)] [rx time(us)] [time diff with previous(us)]\n");
+			for (i = 0; i < x; i++) {
+				if (LB_INFO(i) == i) {
+					seq_printf(s, "[%5d] \t%lld \t%lld \t%lld \t%lld\n", i,
+						LB_INFO(txt), (i==0)?0LL:LB_SUB(txt), LB_INFO(rxt), (i==0)?0LL:LB_SUB(rxt));
+				} else {
+					seq_printf(s, "[----] this frame might be lost.\n");
+				}
+			}
+			if (lb_count > 50) {
+				RESET_VARS();
+				for (i = 50; i < lb_count; i++) {
+					if (c < bunch) {
+						sum_tx += LB_SUB(txt);
+						sum_rx += LB_SUB(rxt);
+						++c;
+					}
+					if (c == bunch) {
+						if (bunch == 1) {
+							if (LB_INFO(i) == i) {
+								seq_printf(s, "[%5d] \t%lld \t%ld \t%lld \t%ld\n", i,
+									LB_INFO(txt), LB_SUB(txt), LB_INFO(rxt), LB_SUB(rxt));
+							} else {
+								seq_printf(s, "[----] this frame might be lost.\n");
+							}
+						} else {
+							seq_printf(s, "[%d - %d] \t%llu \t%llu\n", i + 1 - bunch, i, div_u64(sum_tx, bunch), div_u64(sum_rx, bunch));
+						}
+						RESET_VARS();
+					}
+				}
+				if (c != 0) {
+					seq_printf(s, "[%d - %d] \t%llu \t%llu\n", i - c, i, div_u64(sum_tx, c), div_u64(sum_rx, c));
+				}
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int nrc_debugfs_hspi_report_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, nrc_debugfs_hspi_report, NULL);
+}
+
+static const struct file_operations hspi_report_ops = {
+	.open		= nrc_debugfs_hspi_report_open,
+	.read		= seq_read,
+	.write		= nrc_debugfs_hspi_report_write,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+void nrc_init_debugfs(struct nrc *nw)
+{
+
+#define nrc_debugfs_create_file(name, fops) \
+	debugfs_create_file(name, 0664, nw->debugfs, nw, fops)
+
+	nw->debugfs = nw->hw->wiphy->debugfsdir;
+
+	nrc_debugfs_create_file("debug", &nrc_debugfs_debug_fops);
+	nrc_debugfs_create_file("cspi", &nrc_debugfs_cspi);
+	nrc_debugfs_create_file("hif", &nrc_debugfs_hif);
+	nrc_debugfs_create_file("wakeup", &nrc_debugfs_wakeup_device);
+	nrc_debugfs_create_file("reset", &nrc_debugfs_reset_device);
+	nrc_debugfs_create_file("snr", &nrc_debugfs_snr);
+	nrc_debugfs_create_file("rssi", &nrc_debugfs_rssi);
+	//nrc_debugfs_create_file("pm", &nrc_debugfs_pm);
+
+#if defined(DEBUG)
+	hspi_debugfs_root = debugfs_create_dir("hspi", nw->debugfs);
+	debugfs_create_file("report", 0600, hspi_debugfs_root, nw, &hspi_report_ops);
+	debugfs_create_file("sample", 0600, hspi_debugfs_root, nw, &hspi_sample_ops);
+	debugfs_create_file("test", 0600, hspi_debugfs_root, nw, &nrc_debugfs_loopback);
+	debugfs_create_file("count", 0600, hspi_debugfs_root, nw, &nrc_debugfs_lb_count);
+	debugfs_create_file("hexdump", 0600, hspi_debugfs_root, nw, &nrc_debugfs_hexdump);
+#endif
+}
+
+void nrc_exit_debugfs(void)
+{
+	if (time_info_array) {
+		kfree(time_info_array);
+	}
+}
diff --git a/drivers/staging/nrc/nrc-debug.h b/drivers/staging/nrc/nrc-debug.h
new file mode 100755
index 000000000000..fe901596d989
--- /dev/null
+++ b/drivers/staging/nrc/nrc-debug.h
@@ -0,0 +1,84 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _NRC_DEBUG_H_
+#define _NRC_DEBUG_H_
+
+#include <net/mac80211.h>
+#include "nrc.h"
+
+enum NRC_DEBUG_MASK {
+	NRC_DBG_HIF		= 0,
+	NRC_DBG_WIM		= 1,
+	NRC_DBG_TX		= 2,
+	NRC_DBG_RX		= 3,
+	NRC_DBG_MAC		= 4,
+	NRC_DBG_CAPI	= 5,
+	NRC_DBG_PS		= 6,
+	NRC_DBG_STATS	= 7,
+	NRC_DBG_STATE	= 8,
+	NRC_DBG_BD	= 9,
+	NRC_DBG_COMMON	= 10,
+};
+#define NRC_DBG_MASK_ANY   (0xFFFFFFFF)
+
+#define DEFAULT_NRC_DBG_MASK_ALL (NRC_DBG_MASK_ANY)
+#define DEFAULT_NRC_DBG_MASK (BIT(NRC_DBG_PS) | BIT(NRC_DBG_STATE) | BIT(NRC_DBG_COMMON))
+
+#define NRC_DBG_PRINT_FRAME 0 /* print trx frames for debug */
+
+enum LOOPBACK_MODE {
+	LOOPBACK_MODE_ROUNDTRIP,
+	LOOPBACK_MODE_TX_ONLY,
+	LOOPBACK_MODE_RX_ONLY,
+	LOOPBACK_MODE_MAX
+};
+
+struct lb_time_info {
+	int _i;
+	s64 _txt;
+	s64 _rxt;
+};
+
+extern unsigned long nrc_debug_mask;
+extern s64 tx_time_first;
+extern s64 tx_time_last;
+extern s64 rcv_time_first;
+extern s64 rcv_time_last;
+extern u32 arv_time_first;
+extern u32 arv_time_last;
+extern struct lb_time_info *time_info_array;
+extern u32 lb_hexdump;
+
+void nrc_dbg_init(struct nrc *nw);
+void nrc_dbg_enable(enum NRC_DEBUG_MASK mk);
+void nrc_dbg_disable(enum NRC_DEBUG_MASK mk);
+
+void nrc_dbg(enum NRC_DEBUG_MASK mk, const char *fmt, ...);
+
+void nrc_mac_dump_frame(struct nrc *nw, struct sk_buff *skb,
+			const char *prefix);
+
+void nrc_dump_wim(struct sk_buff *skb);
+
+void nrc_init_debugfs(struct nrc *nw);
+void nrc_exit_debugfs(void);
+
+#define nrc_mac_dbg(fmt, ...) nrc_dbg(NRC_DBG_MAC, fmt, ##__VA_ARGS__)
+#define nrc_ps_dbg(fmt, ...) nrc_dbg(NRC_DBG_PS, fmt, ##__VA_ARGS__)
+#define nrc_stats_dbg(fmt, ...) nrc_dbg(NRC_DBG_STATS, fmt, ##__VA_ARGS__)
+#define nrc_common_dbg(fmt, ...) nrc_dbg(NRC_DBG_COMMON, fmt, ##__VA_ARGS__)
+#endif
diff --git a/drivers/staging/nrc/nrc-dump.c b/drivers/staging/nrc/nrc-dump.c
new file mode 100755
index 000000000000..7cfa07f02809
--- /dev/null
+++ b/drivers/staging/nrc/nrc-dump.c
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/syscalls.h>
+#include <linux/fcntl.h>
+#include <linux/file.h>
+#include <asm/uaccess.h>
+#include "nrc-dump.h"
+#include "nrc.h"
+
+static void write_file(char *filename, char *data, int len)
+{
+	struct file *filp;
+	mm_segment_t old_fs;
+
+#if KERNEL_VERSION(5,0,0) > NRC_TARGET_KERNEL_VERSION
+	old_fs = get_fs();
+	set_fs( get_ds() );
+#elif KERNEL_VERSION(5,10,0) > NRC_TARGET_KERNEL_VERSION
+	old_fs = get_fs();
+	set_fs( KERNEL_DS );
+#else
+	old_fs = force_uaccess_begin();
+#endif
+	filp = filp_open(filename, O_CREAT|O_RDWR, 0606);
+	if (IS_ERR(filp)) {
+		pr_err("[%s] error:%d\n", __func__, IS_ERR(filp));
+		return;
+	}
+#if KERNEL_VERSION(4, 14, 0) <= NRC_TARGET_KERNEL_VERSION
+	kernel_write(filp, data, len, &filp->f_pos);
+#else
+	kernel_write(filp, data, len, filp->f_pos);
+#endif
+
+	filp_close(filp, NULL);
+#if KERNEL_VERSION(5,10,0) > NRC_TARGET_KERNEL_VERSION
+	set_fs(old_fs);
+#else
+	force_uaccess_end(old_fs);
+#endif
+}
+
+void nrc_dump_init(void)
+{
+}
+
+static int cnt;
+void nrc_dump_store(char *src, int len)
+{
+	char str[32];
+
+	sprintf(str, "./host_core_dump_%d.bin", cnt);
+	write_file(str, src, len);
+	cnt++;
+}
diff --git a/drivers/staging/nrc/nrc-dump.h b/drivers/staging/nrc/nrc-dump.h
new file mode 100755
index 000000000000..25ad7a401f14
--- /dev/null
+++ b/drivers/staging/nrc/nrc-dump.h
@@ -0,0 +1,22 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _NRC_DUMP_H_
+#define _NRC_DUMP_H_
+
+void nrc_dump_store(char *src, int len);
+
+#endif //_NRC_DUMP_H_
diff --git a/drivers/staging/nrc/nrc-fw.c b/drivers/staging/nrc/nrc-fw.c
new file mode 100755
index 000000000000..f1ed348914cb
--- /dev/null
+++ b/drivers/staging/nrc/nrc-fw.c
@@ -0,0 +1,364 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/kernel.h>
+#include <linux/firmware.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include "nrc.h"
+#include "wim.h"
+#include "nrc-hif.h"
+#include "nrc-debug.h"
+#include "nrc-fw.h"
+#include "fastboot-cm0.h"
+
+#define BOOT_START_ADDR	(0x10480000)
+#define FW_START_ADDR	(0x10400000)
+#define PACKET_START	"NRC["
+#define PACKET_END	"]MSG"
+
+static unsigned int checksum(unsigned char *buf, int size)
+{
+	int sum = 0;
+	int i;
+
+	for (i = 0; i < size; i++)
+		sum += buf[i];
+	return sum;
+}
+
+/*
+ * Firmware download packet format
+ *
+ * | eof (4B) | address (4B) | len (4B) | payload (1KB - 16) | checksum (4B) |
+ *
+ * Last packet with "eof" being 1 may have padding bytes in payload
+ * but checksum will not include padding bytes
+ */
+
+static void nrc_fw_update_frag(struct nrc_fw_priv *priv, struct fw_frag *frag)
+{
+	struct fw_frag_hdr *frag_hdr = &priv->frag_hdr;
+
+	frag_hdr->eof = ((priv->offset > 0) ? 0 :
+			(priv->cur_chunk == (priv->num_chunks - 1)));
+
+	/*
+	 * Work-around for boot rom bug
+	 * if n_chunk is larger than 256, start to send from
+	 * middle of the firmware so that boot rom will
+	 * set correct start address again after wrap around
+	 */
+
+	if (priv->cur_chunk == priv->offset)
+		frag_hdr->address = (priv->start_addr
+				+ (priv->offset * FRAG_BYTES));
+	else
+		frag_hdr->address += frag_hdr->len;
+
+	frag_hdr->len = min_t(u32, FRAG_BYTES, priv->remain_bytes);
+
+	frag->eof = frag_hdr->eof;
+	frag->address = frag_hdr->address;
+	frag->len = frag_hdr->len;
+	memcpy(frag->payload, priv->fw_data_pos, frag_hdr->len);
+
+	frag->checksum = 0;
+	if (priv->csum)
+		frag->checksum = checksum(frag->payload, frag_hdr->len);
+}
+
+static void nrc_fw_send_info(struct nrc *nw, struct nrc_fw_priv *priv)
+{
+	struct nrc_hif_device *hdev = nw->hif;
+	struct sk_buff *skb;
+	uint32_t *p;
+
+	skb = dev_alloc_skb(16);
+	p = (uint32_t *)skb_put(skb, 16);
+	*p = priv->num_chunks;
+	pr_err("n_chunk:%d\n", *p);
+
+	nrc_hif_write(hdev, skb->data, skb->len);
+
+	dev_kfree_skb(skb);
+}
+
+static void nrc_fw_send_bulk(struct nrc *nw, struct nrc_fw_priv *priv)
+{
+	struct nrc_hif_device *hdev = nw->hif;
+	struct sk_buff *skb;
+	uint8_t *p;
+	int len;
+	u8 index;
+
+	skb = dev_alloc_skb(1024);
+	p = (uint8_t *)skb_put(skb, 1024);
+	len = min_t(u32, 1024, priv->remain_bytes);
+	memcpy(p, priv->fw_data_pos+priv->index_fb*1024, len);
+
+	nrc_hif_write(hdev, skb->data, skb->len);
+	priv->index_fb++;
+	priv->remain_bytes -= len;
+
+	if ((priv->index_fb != priv->num_chunks)
+		&& priv->ack) {
+		int ret = nrc_hif_wait_ack(hdev, &index, 1);
+
+		BUG_ON(ret < 0);
+	}
+
+	dev_kfree_skb(skb);
+}
+
+
+static void nrc_fw_send_frag(struct nrc *nw, struct nrc_fw_priv *priv)
+{
+	struct nrc_hif_device *hdev = nw->hif;
+	struct sk_buff *skb, *skb_fw;
+	int skb_len;
+	struct hif *hif;
+
+	skb = nrc_wim_alloc_skb(nw, WIM_CMD_REQ_FW,
+			tlv_len(sizeof(struct fw_frag)));
+
+	nrc_fw_update_frag(priv, nrc_wim_skb_add_tlv(skb,
+			WIM_TLV_FIRMWARE, sizeof(struct fw_frag), NULL));
+	skb_len = skb->len;
+	skb_fw = skb_copy_expand(skb, (4 + sizeof(struct hif)),
+			4, GFP_ATOMIC);
+
+	/* Prepend HIF header */
+	hif = (struct hif *)skb_push(skb_fw, sizeof(struct hif));
+	hif->type = HIF_TYPE_WIM;
+	hif->subtype = HIF_WIM_SUB_RESPONSE;
+	hif->len = skb_len;
+
+	/* Prepend prefix and append postfix */
+	memcpy(skb_push(skb_fw, 4), PACKET_START, 4);
+	memcpy(skb_put(skb_fw, 4), PACKET_END, 4);
+
+	nrc_hif_write(hdev, skb_fw->data, skb_fw->len);
+
+	dev_kfree_skb(skb);
+	dev_kfree_skb(skb_fw);
+}
+
+static bool nrc_fw_check_next_frag(struct nrc *nw, struct nrc_fw_priv *priv)
+{
+	bool wrap_around = false;
+	struct nrc_hif_device *hdev = nw->hif;
+	u8 index;
+	int ret;
+
+	if (priv->cur_chunk == (priv->num_chunks - 1)) {
+		if (priv->offset == 0)
+			goto last_chuck;
+		wrap_around = true;
+	}
+
+	if (wrap_around) {
+		priv->cur_chunk = 0;
+		priv->num_chunks = priv->offset;
+		priv->offset = 0;
+		priv->fw_data_pos = priv->fw->data;
+		priv->remain_bytes = (priv->num_chunks * FRAG_BYTES);
+		priv->frag_hdr.address = FW_START_ADDR;
+	} else {
+		priv->cur_chunk++;
+		priv->fw_data_pos += priv->frag_hdr.len;
+		priv->remain_bytes -= priv->frag_hdr.len;
+	}
+
+	index = priv->index;
+
+	if (priv->ack) {
+		ret = nrc_hif_wait_ack(hdev, &index, 1);
+		BUG_ON(ret < 0);
+	}
+
+	BUG_ON(index != priv->index);
+	priv->index++;
+
+	return true;
+
+last_chuck:
+	return false;
+}
+
+struct nrc_fw_priv *nrc_fw_init(struct nrc *nw)
+{
+	struct nrc_fw_priv *priv;
+
+	priv = kzalloc(sizeof(struct nrc_fw_priv), GFP_KERNEL);
+	if (!priv) {
+		/*nrc_dbg(NRC_DBG_HIF, "failed to allocate nrc_fw_priv");*/
+		return NULL;
+	}
+
+	return priv;
+}
+
+void nrc_fw_exit(struct nrc_fw_priv *priv)
+{
+	kfree(priv);
+}
+
+/**
+ * nrc_download_boot - download boot binary to the target
+ */
+void nrc_download_boot(struct nrc *nw)
+{
+	struct firmware *fw = nw->fw;
+	struct nrc_fw_priv *priv = nw->fw_priv;
+	struct nrc_hif_device *hdev = nw->hif;
+
+	priv->fw = fw;
+	priv->num_chunks = DIV_ROUND_UP(fb_cm0_len, FRAG_BYTES);
+
+	if (nrc_hif_check_maskrom_war(hdev)) {
+		priv->offset =
+		   ((priv->num_chunks > 256) ? (priv->num_chunks % 256) : 0);
+	} else {
+		priv->offset = 0;
+	}
+
+	priv->fw_data_pos = (fb_cm0 + (priv->offset * FRAG_BYTES));
+	priv->remain_bytes = (fb_cm0_len - (priv->offset * FRAG_BYTES));
+	priv->cur_chunk = priv->offset;
+	priv->index = 0;
+	priv->start_addr = BOOT_START_ADDR;
+	priv->ack = true;
+	priv->csum = true;
+
+	nrc_hif_suspend(hdev);
+	do {
+		nrc_fw_send_frag(nw, priv);
+	} while (nrc_fw_check_next_frag(nw, priv));
+	priv->fw_requested = false;
+}
+
+/**
+ * nrc_download_fw - download firmware binary to the target
+ */
+void nrc_download_fw(struct nrc *nw)
+{
+	struct firmware *fw = nw->fw;
+	struct nrc_fw_priv *priv = nw->fw_priv;
+	struct nrc_hif_device *hdev = nw->hif;
+	int i;
+	bool fastboot = nrc_hif_support_fastboot(hdev);
+
+	nrc_dbg(NRC_DBG_HIF, "FW download....%s\n", fw_name);
+	if (fastboot) {
+		nrc_download_boot(nw);
+		mdelay(1);
+		priv->num_chunks = DIV_ROUND_UP(fw->size, CHUNK_SIZE);
+		priv->csum = false;
+	} else {
+		priv->num_chunks = DIV_ROUND_UP(fw->size, FRAG_BYTES);
+		priv->csum = true;
+	}
+	priv->fw = fw;
+
+	if (nrc_hif_check_maskrom_war(hdev)) {
+		priv->offset = ((priv->num_chunks > 256) ?
+			 (priv->num_chunks % 256) : 0);
+	} else {
+		priv->offset = 0;
+	}
+
+	priv->fw_data_pos = (fw->data + (priv->offset * FRAG_BYTES));
+	priv->remain_bytes = (fw->size - (priv->offset * FRAG_BYTES));
+	priv->cur_chunk = priv->offset;
+	priv->index = 0;
+	priv->index_fb = 0;
+	priv->start_addr = FW_START_ADDR;
+	priv->ack = true;
+
+	nrc_hif_suspend(hdev);
+
+	pr_err("start FW %d\n", priv->num_chunks);
+	if (fastboot) {
+		nrc_fw_send_info(nw, priv);
+		udelay(10);
+		for (i = 0; i < priv->num_chunks; i++)
+			nrc_fw_send_bulk(nw, priv);
+	} else {
+		do {
+			nrc_fw_send_frag(nw, priv);
+		} while (nrc_fw_check_next_frag(nw, priv));
+	}
+	pr_err("end FW\n");
+
+	priv->fw_requested = false;
+}
+
+bool nrc_check_fw_file(struct nrc *nw)
+{
+	int status;
+
+	if (fw_name == NULL)
+		goto err_fw;
+
+	if (nw->fw)
+		return true;
+
+	status = request_firmware((const struct firmware **)&nw->fw,
+			fw_name, &nw->pdev->dev);
+
+	nrc_dbg(NRC_DBG_HIF, "[%s, %d] Checking firmware... (%s)\n",
+			__func__, __LINE__, fw_name);
+
+	if (status != 0) {
+		nrc_dbg(NRC_DBG_HIF, "request_firmware() is failed, status = %d, fw = %p\n",
+				status, nw->fw);
+		goto err_fw;
+	}
+
+	nrc_dbg(NRC_DBG_HIF, "[%s, %d] OK...(%p, 0x%zx)\n",
+			__func__, __LINE__, nw->fw->data, nw->fw->size);
+	return true;
+
+err_fw:
+	nw->fw = NULL;
+	return false;
+}
+
+bool nrc_check_boot_ready(struct nrc *nw)
+{
+	BUG_ON(!nw);
+	BUG_ON(!nw->fw_priv);
+	return (nw->fw_priv->fw_requested ||
+			nrc_hif_check_fw(nw->hif));
+}
+
+void nrc_set_boot_ready(struct nrc *nw)
+{
+	BUG_ON(!nw);
+	BUG_ON(!nw->fw_priv);
+
+	nw->fw_priv->fw_requested = true;
+}
+
+void nrc_release_fw(struct nrc *nw)
+{
+	release_firmware(nw->fw);
+	nw->fw = NULL;
+}
diff --git a/drivers/staging/nrc/nrc-fw.h b/drivers/staging/nrc/nrc-fw.h
new file mode 100755
index 000000000000..d9a683f32d33
--- /dev/null
+++ b/drivers/staging/nrc/nrc-fw.h
@@ -0,0 +1,68 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _NRC_FW_H_
+#define _NRC_FW_H_
+
+#define DEFAULT_FIRMWARE_NAME	"uni.bin"
+
+#define CHUNK_SIZE	(1024) /*(2*1024)*/
+#define FRAG_BYTES (CHUNK_SIZE - 16)
+
+struct fw_frag_hdr {
+	u32 eof;
+	u32 address;
+	u32 len;
+} __packed;
+
+struct fw_frag {
+	u32 eof;
+	u32 address;
+	u32 len;
+	u8 payload[FRAG_BYTES];
+	u32 checksum;
+} __packed;
+
+struct nrc_fw_priv {
+	struct nrc *nw;
+	struct firmware *fw;
+	struct fw_frag_hdr frag_hdr;
+	int offset;
+	/* 0 : inside first 256 chunks, > 0 : inside 256-aligned chunks */
+	const u8 *fw_data_pos;
+	int remain_bytes;
+	int num_chunks;
+	int cur_chunk; /* index of chunck to be transferred */
+
+	bool fw_requested;
+	u8 index;
+	u32 index_fb;
+	uint32_t start_addr;
+	bool ack;
+	bool csum;
+};
+
+extern char *fw_name;
+
+struct nrc_fw_priv *nrc_fw_init(struct nrc *nw);
+void nrc_fw_exit(struct nrc_fw_priv *priv);
+bool nrc_check_fw_file(struct nrc *nw);
+bool nrc_check_boot_ready(struct nrc *nw);
+void nrc_set_boot_ready(struct nrc *nw);
+void nrc_download_fw(struct nrc *nw);
+void nrc_release_fw(struct nrc *nw);
+
+#endif
diff --git a/drivers/staging/nrc/nrc-hif-cspi.c b/drivers/staging/nrc/nrc-hif-cspi.c
new file mode 100644
index 000000000000..380b1386daa7
--- /dev/null
+++ b/drivers/staging/nrc/nrc-hif-cspi.c
@@ -0,0 +1,2325 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/wait.h>
+#include <linux/spi/spi.h>
+#include <linux/gpio.h>
+#include <linux/irqreturn.h>
+#include <linux/interrupt.h>
+#include <net/mac80211.h>
+#include <asm/unaligned.h>
+#include <linux/smp.h>
+#ifdef CONFIG_SUPPORT_AFTER_KERNEL_3_0_36
+#include <linux/timekeeping.h>
+#else
+#include <linux/kthread.h>
+#endif
+
+#include "nrc-fw.h"
+#include "nrc-hif.h"
+#include "nrc-debug.h"
+#include "nrc-recovery.h"
+#include "nrc-vendor.h"
+#include "nrc-mac80211.h"
+#include "nrc-stats.h"
+#include "wim.h"
+
+static bool once;
+static bool cspi_suspend;
+static atomic_t irq_enabled;
+static u16 total_sta=0; /* total number of STA  connected */
+static u16 remain_sta=0; /* number of STA remaining after clearing STA */
+#define TCN  (2*1)
+#define TCNE (0)
+#define CREDIT_AC0	(TCN*2+TCNE)	/* BK (4) */
+#define CREDIT_AC1	(TCN*20+TCNE)	/* BE (40) */
+#define CREDIT_AC1_7292	(TCN*60+TCNE)	/* BE (120) : 7292 has 128 target TX pool */
+#define CREDIT_AC1_7392	(TCN*10+TCNE)	/* BE (20)  : 7392 has small target TX pool */
+#define CREDIT_AC2	(TCN*4+TCNE)	/* VI (8) */
+#define CREDIT_AC3	(TCN*4+TCNE)	/* VO(8) */
+
+/* N-SPI host-side memory map */
+#define C_SPI_WAKE_UP 0x0
+#define C_SPI_DEVICE_STATUS 0x1
+#define C_SPI_CHIP_ID_HIGH 0x2
+#define C_SPI_CHIP_ID_LOW 0x3
+#define C_SPI_MODEM_ID 0x4
+#define C_SPI_SOFTWARE_VERSION 0x8
+#define C_SPI_BOARD_ID 0xc
+#define C_SPI_EIRQ_MODE 0x10
+#define C_SPI_EIRQ_ENABLE 0x11
+#define C_SPI_EIRQ_STATUS_LATCH 0x12
+#define C_SPI_EIRQ_STATUS 0x13
+#define C_SPI_QUEUE_STATUS 0x14 /* 0x1f */
+#define C_SPI_MESSAGE 0x20 /* 0x2f */
+
+#define C_SPI_RXQ_THRESHOLD 0x30
+#define C_SPI_RXQ_WINDOW 0x31
+
+#define C_SPI_TXQ_THRESHOLD 0x40
+#define C_SPI_TXQ_WINDOW 0x41
+
+#define SW_MAGIC_FOR_BOOT	(0x01020716)
+#define SW_MAGIC_FOR_FW		(0x01210630)
+
+#define CSPI_EIRQ_MODE 0x05
+#define CSPI_EIRQ_ENABLE 0x1f /* enable tx/rx que */
+/*#define CSPI_EIRQ_ENABLE 0x16*/ /* disable tx/rx que */
+
+struct spi_sys_reg {
+	u8 wakeup;	/* 0x0 */
+	u8 status;	/* 0x1 */
+	u16 chip_id;	/* 0x2-0x3 */
+	u32 modem_id;	/* 0x4-0x7 */
+	u32 sw_id;	/* 0x8-0xb */
+	u32 board_id;	/* 0xc-0xf */
+} __packed;
+
+struct spi_status_reg {
+	struct {
+		u8 mode;
+		u8 enable;
+		u8 latched_status;
+		u8 status;
+	} eirq;
+	u8 txq_status[6];
+	u8 rxq_status[6];
+	u32 msg[4];
+
+#define EIRQ_IO_ENABLE	(1<<2)
+#define EIRQ_EDGE	(1<<1)
+#define EIRQ_ACTIVE_LO	(1<<0)
+
+#define EIRQ_DEV_SLEEP	(1<<3)
+#define EIRQ_DEV_READY	(1<<2)
+#define EIRQ_RXQ	(1<<1)
+#define EIRQ_TXQ	(1<<0)
+
+#define TXQ_ERROR	(1<<7)
+#define TXQ_SLOT_COUNT	(0x7F)
+#define RXQ_SLOT_COUNT	(0x7F)
+
+} __packed;
+
+#define SPI_BUFFER_SIZE (496-20)
+
+/* C-SPI command
+ *
+ * [31:24]: start byte (0x50)
+ * [23:23]: burst (0: single, 1: burst)
+ * [22:22]: direction (0: read, 1: write)
+ * [21:21]: fixed (0: incremental, 1: fixed)
+ * [20:13]: address
+ * [12:0]: length (for multi-word transfer)
+ * [7:0]: wdata (for single write)
+ */
+#define C_SPI_READ	0x50000000
+#define C_SPI_WRITE	0x50400000
+#define C_SPI_BURST	0x00800000
+#define C_SPI_FIXED	0x00200000
+#define C_SPI_ADDR(x)	(((x) & 0xff) << 13)
+#define C_SPI_LEN(x)	((x) & 0x1fff)
+#define C_SPI_WDATA(x)	((x) & 0xff)
+#define C_SPI_ACK	0x47
+
+#define TX_SLOT 0
+#define RX_SLOT 1
+
+#define CREDIT_QUEUE_MAX (12)
+
+/*#define SPI_DBG (13)*/
+
+/* Object prepended to strut nrc_hif_device */
+struct nrc_spi_priv {
+	struct spi_device *spi;
+
+	/* work, kthread, ... */
+	struct delayed_work work;
+	struct task_struct *kthread;
+	wait_queue_head_t wait; /* wait queue */
+
+#if !defined(CONFIG_SUPPORT_THREADED_IRQ)
+	struct workqueue_struct *irq_wq;
+	struct work_struct irq_work;
+#endif
+
+	struct {
+		struct spi_sys_reg sys;
+		struct spi_status_reg status;
+	} hw;
+
+	spinlock_t lock;
+	struct {
+		u16 head;
+		u16 tail;
+		u16 size;
+		u16 count;
+	} slot[2];
+	/* VIF0(AC0~AC3), BCN, CONC, VIF1(AC0~AC3), padding*/
+	u8 front[CREDIT_QUEUE_MAX];
+	u8 rear[CREDIT_QUEUE_MAX];
+	u8 credit_max[CREDIT_QUEUE_MAX];
+#ifdef CONFIG_TRX_BACKOFF
+	atomic_t trx_backoff;
+#endif
+	bool fastboot;
+	unsigned long loopback_prev_cnt;
+	unsigned long loopback_total_cnt;
+	unsigned long loopback_last_jiffies;
+	unsigned long loopback_read_usec;
+	unsigned long loopback_write_usec;
+	unsigned long loopback_measure_cnt;
+	struct mutex bus_lock_mutex;
+	struct nrc_cspi_ops *ops;
+
+	int polling_interval;
+	struct task_struct *polling_kthread;
+};
+
+struct nrc_cspi_ops {
+	int (*read_regs)(struct spi_device *spi,
+		u8 addr, u8 *buf, ssize_t size);
+	int (*write_reg)(struct spi_device *spi, u8 addr, u8 data);
+	ssize_t (*read)(struct spi_device *spi, u8 *buf, ssize_t size);
+	ssize_t (*write)(struct spi_device *spi, u8 *buf, ssize_t size);
+};
+
+int spi_test(struct nrc_hif_device *hdev);
+void spi_reset(struct nrc_hif_device *hdev);
+static int spi_update_status(struct spi_device *spi);
+static void c_spi_enable_irq(struct spi_device *spi, bool enable);
+static void c_spi_config(struct spi_device *spi);
+static void spi_config_fw(struct nrc_hif_device *dev);
+
+static u8 crc7(u8 seed, u8 data)
+{
+	int i;
+	const u8 g = 0x89;
+
+	seed ^= data;
+	for (i = 0; i < 8; i++) {
+		if (seed & 0x80)
+			seed ^= g;
+		seed <<= 1;
+	}
+	return seed;
+}
+
+static u8 compute_crc7(const u8 *data, ssize_t len)
+{
+	int i;
+	u8 crc = 0;
+
+	for (i = 0; i < len; i++)
+		crc = crc7(crc, data[i]);
+
+	return crc >> 1;
+}
+
+static void get_sta_cnt(void *data,  struct ieee80211_sta *sta)
+{
+	struct ieee80211_vif *vif = data;
+
+	if (!sta || !vif) {
+		nrc_dbg(NRC_DBG_STATE, "%s Invalid argument", __func__);
+		return;
+	}
+	++remain_sta;
+	nrc_dbg(NRC_DBG_STATE, "(AP Recovery) remaining sta_cnt:%d", remain_sta);
+}
+
+static void prepare_deauth_sta(void *data,  struct ieee80211_sta *sta)
+{
+	struct nrc_sta *i_sta = to_i_sta(sta);
+	struct ieee80211_hw *hw = i_sta->nw->hw;
+	struct ieee80211_vif *vif = data;
+	struct sk_buff *skb = NULL;
+
+	if (!sta || !vif) {
+		nrc_dbg(NRC_DBG_STATE, "%s Invalid argument", __func__);
+		return;
+	}
+
+	/* (AP Recovery) Delete BSS Max Idle timer if exist */
+	if (i_sta->max_idle.idle_period > 0 &&
+		timer_pending(&i_sta->max_idle.timer)) {
+		nrc_dbg(NRC_DBG_STATE, "(AP Recovery) Delete STA(%pM)'s bss_max_idle timer(%u)",
+			sta->addr,i_sta->max_idle.idle_period);
+		del_timer_sync(&i_sta->max_idle.timer);
+		i_sta->max_idle.idle_period = 0;
+	}
+
+	/* (AP Recovry) Pretend to receive a deauth from @sta */
+	skb = ieee80211_deauth_get(hw, vif->addr, sta->addr, vif->addr,
+			WLAN_REASON_DEAUTH_LEAVING, sta, false);
+	if (!skb) {
+		nrc_dbg(NRC_DBG_STATE, "%s Fail to alloc skb", __func__);
+		return;
+	}
+	nrc_dbg(NRC_DBG_STATE, "(AP Recovery) Disconnect STA(%pM) by force", sta->addr);
+	ieee80211_rx_irqsafe(hw, skb);
+
+	++total_sta;
+}
+
+static inline void spi_set_transfer(struct spi_transfer *xfer,
+				void *tx, void *rx, int len)
+{
+	xfer->tx_buf = tx;
+	xfer->rx_buf = rx;
+	xfer->len = len;
+}
+
+#ifdef CONFIG_SUPPORT_SPI_SYNC_TRANSFER
+#else
+static inline void
+spi_message_init_with_transfers(struct spi_message *m,
+				struct spi_transfer *xfers, unsigned int num_xfers)
+{
+	unsigned int i;
+
+	spi_message_init(m);
+	for (i = 0; i < num_xfers; ++i)
+		spi_message_add_tail(&xfers[i], m);
+}
+
+static inline int
+spi_sync_transfer(struct spi_device *spi, struct spi_transfer *xfers,
+	unsigned int num_xfers)
+{
+	struct spi_message msg;
+
+	spi_message_init_with_transfers(&msg, xfers, num_xfers);
+
+	return spi_sync(spi, &msg);
+}
+#endif
+
+static int _c_spi_write_dummy(struct spi_device *spi)
+{
+	struct spi_transfer xfer[2] = {{0},};
+	u32 dummy=0xffffffff;
+	u8 tx[8];
+#ifndef CONFIG_SPI_HALF_DUPLEX
+	u8 rx[8];
+#endif
+	ssize_t status;
+
+	memset(tx, 0xff, sizeof(tx));
+#ifndef CONFIG_SPI_HALF_DUPLEX
+	spi_set_transfer(&xfer[0], tx, rx, 8);
+#else
+	spi_set_transfer(&xfer[0], tx, NULL, 8);
+#endif
+	dummy = 0xffffffff;
+	spi_set_transfer(&xfer[1], &dummy, NULL, sizeof(dummy));
+
+	status = spi_sync_transfer(spi, xfer, 2);
+
+	return 0;
+}
+
+static int _c_spi_read_regs(struct spi_device *spi,
+		u8 addr, u8 *buf, ssize_t size)
+{
+	struct spi_transfer xfer[4] = {{0},};
+	u32 cmd, crc, dummy;
+	u8 tx[8];
+#ifndef CONFIG_SPI_HALF_DUPLEX
+	u8 rx[8];
+#endif
+	ssize_t status;
+	int arr_len;
+
+	if (size == 0 || buf == NULL)
+		return -EINVAL;
+
+	cmd = C_SPI_READ | C_SPI_ADDR(addr);
+	if (size > 1)
+		cmd |= C_SPI_BURST | C_SPI_LEN(size);
+	else
+		cmd |= C_SPI_FIXED | C_SPI_LEN(0);
+
+	put_unaligned_be32(cmd, (u32 *)tx);
+	tx[4] = (compute_crc7(tx, 4) << 1) | 0x1;
+
+#ifndef CONFIG_SPI_HALF_DUPLEX
+	spi_set_transfer(&xfer[0], tx, rx, 8);
+#else
+	spi_set_transfer(&xfer[0], tx, NULL, 8);
+#endif
+	spi_set_transfer(&xfer[1], NULL, buf, size);
+	spi_set_transfer(&xfer[2], NULL, &crc, sizeof(crc));
+
+	dummy = 0xffffffff;
+	if (size > 1)
+		spi_set_transfer(&xfer[3], &dummy, NULL, sizeof(dummy));
+	else
+		spi_set_transfer(&xfer[1], &dummy, NULL, sizeof(dummy));
+
+	arr_len = (size > 1) ? ARRAY_SIZE(xfer) : 2;
+	status = spi_sync_transfer(spi, xfer, arr_len);
+
+#ifndef CONFIG_SPI_HALF_DUPLEX
+	if (status < 0 || WARN_ON(rx[7] != C_SPI_ACK))
+#else
+	if (status < 0)
+#endif
+		return -EIO;
+#ifndef CONFIG_SPI_HALF_DUPLEX
+	if (size == 1)
+		buf[0] = rx[6];
+#else
+	/* Half duplex can't handle size 1 and 2 */
+	if (size <= 2)
+		nrc_common_dbg("[%s] Half duplex can't handle size 1 and 2...\n", __func__);
+#endif
+	return 0;
+}
+
+static int _c_spi_write_reg(struct spi_device *spi, u8 addr, u8 data)
+{
+	struct spi_transfer xfer[2] = {{0},};
+	u32 cmd, dummy;
+	u8 tx[8];
+#ifndef CONFIG_SPI_HALF_DUPLEX
+	u8 rx[8];
+#endif
+	ssize_t status;
+
+	cmd = C_SPI_WRITE | C_SPI_FIXED | C_SPI_ADDR(addr) | C_SPI_WDATA(data);
+	put_unaligned_be32(cmd, (u32 *)tx);
+	tx[4] = (compute_crc7(tx, 4) << 1) | 0x1;
+#ifndef CONFIG_SPI_HALF_DUPLEX
+	spi_set_transfer(&xfer[0], tx, rx, 8);
+#else
+	spi_set_transfer(&xfer[0], tx, NULL, 8);
+#endif
+	dummy = 0xffffffff;
+	spi_set_transfer(&xfer[1], &dummy, NULL, sizeof(dummy));
+
+	status = spi_sync_transfer(spi, xfer, 2);
+
+	/* In case of spi reset, skip a process for confirming spi ack */
+	if (C_SPI_WDATA(data) == 0xC8) {
+		if (status < 0)
+			return -EIO;
+	} else {
+#ifndef CONFIG_SPI_HALF_DUPLEX
+		if (status < 0 || WARN_ON(rx[7] != C_SPI_ACK))
+#else
+		if (status < 0)
+#endif
+			return -EIO;
+	}
+
+	return 0;
+}
+
+static ssize_t _c_spi_read(struct spi_device *spi, u8 *buf, ssize_t size)
+{
+	struct spi_transfer xfer[4] = {{0},};
+	u32 cmd, crc, dummy;
+	u8 tx[8];
+#ifndef CONFIG_SPI_HALF_DUPLEX
+	u8 rx[8];
+#endif
+	ssize_t status;
+
+	if (size == 0 || buf == NULL)
+		return -EINVAL;
+
+	cmd = C_SPI_READ | C_SPI_BURST | C_SPI_FIXED;
+	cmd |= C_SPI_ADDR(C_SPI_TXQ_WINDOW) | C_SPI_LEN(size);
+	put_unaligned_be32(cmd, (u32 *)tx);
+	tx[4] = (compute_crc7(tx, 4) << 1) | 0x1;
+	tx[5] = 0xff;
+
+#ifndef CONFIG_SPI_HALF_DUPLEX
+	spi_set_transfer(&xfer[0], tx, rx, 8);
+#else
+	spi_set_transfer(&xfer[0], tx, NULL, 8);
+#endif
+	spi_set_transfer(&xfer[1], NULL, buf, size);
+	spi_set_transfer(&xfer[2], NULL, &crc, sizeof(crc));
+
+	dummy = 0xffffffff;
+	spi_set_transfer(&xfer[3], &dummy, NULL, sizeof(dummy));
+	status = spi_sync_transfer(spi, xfer, ARRAY_SIZE(xfer));
+
+#ifndef CONFIG_SPI_HALF_DUPLEX
+	if (status < 0 || WARN_ON(rx[7] != C_SPI_ACK))
+#else
+	if (status < 0)
+#endif
+		return -EIO;
+
+	return size;
+}
+
+static ssize_t _c_spi_write(struct spi_device *spi, u8 *buf, ssize_t size)
+{
+
+	struct spi_transfer xfer[4] = {{0},};
+	u32 cmd, dummy = 0xffffffff;
+	u8 tx[8];
+#ifndef CONFIG_SPI_HALF_DUPLEX
+	u8 rx[8];
+#endif
+	ssize_t status;
+
+	if (size == 0 || buf == NULL)
+		return -EINVAL;
+
+	cmd = C_SPI_WRITE | C_SPI_BURST | C_SPI_FIXED;
+	cmd |= C_SPI_ADDR(C_SPI_RXQ_WINDOW) | C_SPI_LEN(size);
+	put_unaligned_be32(cmd, (u32 *)tx);
+	tx[4] = (compute_crc7(tx, 4) << 1) | 0x1;
+	tx[5] = 0xff;
+
+#ifndef CONFIG_SPI_HALF_DUPLEX
+	spi_set_transfer(&xfer[0], tx, rx, 8);
+#else
+	spi_set_transfer(&xfer[0], tx, NULL, 8);
+#endif
+	spi_set_transfer(&xfer[1], buf, NULL, size);
+	spi_set_transfer(&xfer[2], &dummy, NULL, sizeof(dummy));
+	dummy = 0xffffffff;
+	spi_set_transfer(&xfer[3], &dummy, NULL, sizeof(dummy));
+
+	status = spi_sync_transfer(spi, xfer, ARRAY_SIZE(xfer));
+#ifndef CONFIG_SPI_HALF_DUPLEX
+	if (status < 0 || WARN_ON(rx[7] != C_SPI_ACK))
+#else
+	if (status < 0)
+#endif
+		return -EIO;
+
+	return size;
+}
+
+static struct nrc_cspi_ops cspi_ops = {
+	.read_regs = _c_spi_read_regs,
+	.write_reg = _c_spi_write_reg,
+	.read = _c_spi_read,
+	.write = _c_spi_write,
+};
+
+static int c_spi_read_regs(struct spi_device *spi,
+		u8 addr, u8 *buf, ssize_t size)
+{
+	struct nrc_hif_device *hdev = spi->dev.platform_data;
+	struct nrc_spi_priv *priv = hdev->priv;
+
+	WARN_ON(!priv->ops);
+	WARN_ON(!priv->ops->read_regs);
+
+	return (*priv->ops->read_regs)(spi, addr, buf, size);
+}
+
+static int c_spi_write_reg(struct spi_device *spi, u8 addr, u8 data)
+{
+	struct nrc_hif_device *hdev = spi->dev.platform_data;
+	struct nrc_spi_priv *priv = hdev->priv;
+
+	WARN_ON(!priv->ops);
+	WARN_ON(!priv->ops->write_reg);
+
+	return (*priv->ops->write_reg)(spi, addr, data);
+}
+
+static ssize_t c_spi_read(struct spi_device *spi, u8 *buf, ssize_t size)
+{
+	struct nrc_hif_device *hdev = spi->dev.platform_data;
+	struct nrc_spi_priv *priv = hdev->priv;
+
+	WARN_ON(!priv->ops);
+	WARN_ON(!priv->ops->read);
+
+	return (*priv->ops->read)(spi, buf, size);
+}
+
+static ssize_t c_spi_write(struct spi_device *spi, u8 *buf, ssize_t size)
+{
+	struct nrc_hif_device *hdev = spi->dev.platform_data;
+	struct nrc_spi_priv *priv = hdev->priv;
+
+	WARN_ON(!priv->ops);
+	WARN_ON(!priv->ops->write);
+
+	return (*priv->ops->write)(spi, buf, size);
+}
+
+static inline struct spi_device *hifdev_to_spi(struct nrc_hif_device *hdev)
+{
+	struct nrc_spi_priv *priv = (void *)(hdev + 1);
+
+	return priv->spi;
+}
+
+static inline u16 c_spi_num_slots(struct nrc_spi_priv *priv, int dir)
+{
+	return (priv->slot[dir].head - priv->slot[dir].tail);
+}
+
+/**
+ * spi_rx_skb - fetch a single hif packet from the target
+ */
+
+static struct sk_buff *spi_rx_skb(struct spi_device *spi,
+				struct nrc_spi_priv *priv)
+{
+	struct sk_buff *skb;
+	struct hif *hif;
+	ssize_t size;
+	u32 nr_slot;
+	int ret;
+	u32 second_length = 0;
+	struct nrc_hif_device *hdev = spi_get_drvdata(spi);
+#ifdef CONFIG_TRX_BACKOFF
+	struct nrc *nw = hdev->nw;
+	int backoff;
+#endif
+	static uint cnt1 = 0;
+	static uint cnt2 = 0;
+	static const int def_slot = 4;
+
+	skb = dev_alloc_skb(priv->slot[RX_SLOT].size * def_slot);
+	if (!skb)
+		goto fail;
+
+	if (c_spi_num_slots(priv, RX_SLOT) == 0)
+		spi_update_status(priv->spi);
+
+	/* Wait until at least one rx slot is non-empty */
+	ret = wait_event_interruptible(priv->wait,
+			((c_spi_num_slots(priv, RX_SLOT) > 0) ||
+			 kthread_should_stop()));
+	if (ret < 0)
+		goto fail;
+
+	if (kthread_should_stop())
+		goto fail;
+
+#ifdef CONFIG_TRX_BACKOFF
+	if (!nw->ampdu_supported) {
+		backoff = atomic_inc_return(&priv->trx_backoff);
+
+		if ((backoff % 3) != 0) {
+#ifdef CONFIG_NRC_HIF_PRINT_FLOW_CONTROL
+			nrc_dbg(NRC_DBG_HIF, "rx-irq: backoff=%d", backoff);
+#endif
+			usleep_range(800, 1000);
+		}
+	}
+#endif
+	SYNC_LOCK(hdev);
+
+	if (c_spi_num_slots(priv, RX_SLOT) > 32) {
+		SYNC_UNLOCK(hdev);
+		if (cnt1++ < 10) {
+			pr_err("!!!!! garbage rx data");
+		}
+		goto fail;
+	}
+	cnt1 = 0;
+
+	/*
+	 * For the first time, the slot should be read entirely
+	 * since we cannot know the data size until the hif->len is checked.
+	 * And, the current RX_SLOT size is already word aligned(456 bytes).
+	 */
+	size = c_spi_read(spi, skb->data, priv->slot[RX_SLOT].size);
+	SYNC_UNLOCK(hdev);
+	if (size < 0)
+		goto fail;
+
+	/* Calculate how many more slot to read for this hif packet */
+	hif = (void *)skb->data;
+
+	if (hif->type >= HIF_TYPE_MAX || hif->len == 0) {
+		nrc_dbg(NRC_DBG_HIF, "rxslot:(h=%d,t=%d)",
+				priv->slot[RX_SLOT].head, priv->slot[RX_SLOT].tail);
+		print_hex_dump(KERN_DEBUG, "rxskb ", DUMP_PREFIX_NONE, 16, 1,
+				skb->data, 480, false);
+		priv->slot[RX_SLOT].tail++;
+		mdelay(100);
+		goto fail;
+	}
+
+	nr_slot = DIV_ROUND_UP(sizeof(*hif) + hif->len, priv->slot[RX_SLOT].size);
+	priv->slot[RX_SLOT].tail++;
+
+	if (nr_slot >= def_slot) {
+		struct sk_buff *skb2 = dev_alloc_skb(
+				priv->slot[RX_SLOT].size * (nr_slot+1));
+
+		memcpy(skb2->data, skb->data, priv->slot[RX_SLOT].size);
+		dev_kfree_skb(skb);
+		skb = skb2;
+		hif = (void *)skb->data;
+	}
+
+	nr_slot--;
+
+	if (nr_slot == 0)
+		goto out;
+
+	if (c_spi_num_slots(priv, RX_SLOT) < nr_slot)
+		spi_update_status(priv->spi);
+
+	/*
+	 * Block until priv->nr_rx_slot >= nr_slot).
+	 * The irq thread will wake me up.
+	 */
+	ret = wait_event_interruptible(priv->wait,
+				(c_spi_num_slots(priv, RX_SLOT) >= nr_slot) ||
+				kthread_should_stop());
+	if (ret < 0)
+		goto fail;
+
+	if (kthread_should_stop())
+		goto fail;
+
+	priv->slot[RX_SLOT].tail += nr_slot;
+
+	second_length = hif->len + sizeof(*hif) - priv->slot[RX_SLOT].size;
+	/*
+	 * If it's necessary to read more data over other slots,
+	 * the size to read must be a multiple of 4.
+	 * because the HSPI HW stores the data length as a word unit.
+	 */
+	if (second_length & 0x3) {
+		second_length = (second_length + 4) & 0xFFFFFFFC;
+	}
+
+	SYNC_LOCK(hdev);
+	if (c_spi_num_slots(priv, RX_SLOT) > 32) {
+		SYNC_UNLOCK(hdev);
+		if (cnt2++ < 10) {
+			pr_err("@@@@@@ garbage rx data");
+		}
+		goto fail;
+	}
+	cnt2 = 0;
+	size = c_spi_read(spi, skb->data + priv->slot[RX_SLOT].size,
+			second_length);
+	SYNC_UNLOCK(hdev);
+
+	if (size < 0)
+		goto fail;
+
+out:
+	skb_put(skb, sizeof(*hif) + hif->len);
+#ifdef CONFIG_NRC_HIF_PRINT_FLOW_CONTROL
+	nrc_dbg(NRC_DBG_HIF, "rx-irq: skb=%p len:%d, hif_type=%d",
+			skb, skb->len, hif->type);
+#endif
+	return skb;
+
+fail:
+	if (skb)
+		dev_kfree_skb(skb);
+	return NULL;
+}
+
+
+static void spi_credit_skb(struct spi_device *spi)
+{
+	struct nrc_hif_device *hdev = spi_get_drvdata(spi);
+	struct nrc_spi_priv *priv = hdev->priv;
+	struct sk_buff *skb;
+	struct hif *hif;
+	struct wim *wim;
+	struct wim_credit_report *cr;
+	u8 *p;
+	int i;
+	int size = sizeof(*hif) + sizeof(*wim) + sizeof(*cr);
+
+	if (!once) {
+		once = true;
+		return;
+	}
+
+	skb = dev_alloc_skb(size);
+
+	p = skb->data;
+	hif = (void *)p;
+	hif->type = HIF_TYPE_WIM;
+	hif->subtype = HIF_WIM_SUB_EVENT;
+	hif->vifindex = 0;
+	hif->len = sizeof(*wim) + sizeof(*cr);
+
+	p += sizeof(*hif);
+	wim = (void *)p;
+	wim->event = WIM_EVENT_CREDIT_REPORT;
+
+	p += sizeof(*wim);
+	cr = (void *)p;
+	cr->h.type = WIM_TLV_AC_CREDIT_REPORT;
+	cr->h.len = sizeof(struct wim_credit_report_param);
+
+	cr->v.change_index = 0;
+
+	for (i = 0; i < CREDIT_QUEUE_MAX; i++) {
+		u8 room = 0;
+		if (priv->front[i] >= priv->rear[i]) {
+			room = priv->front[i] - priv->rear[i];
+		} else {
+			room = (255 - priv->rear[i]) + priv->front[i];
+		}
+
+		room = min(priv->credit_max[i], room);
+		cr->v.ac[i] = priv->credit_max[i] - room;
+
+#ifdef CONFIG_NRC_HIF_PRINT_FLOW_CONTROL
+		nrc_dbg(NRC_DBG_HIF, "credit[%d] %d f:%d, r:%d",
+				i, cr->v.ac[i], priv->front[i],
+				priv->rear[i]);
+#endif
+	}
+
+	skb_put(skb, hif->len+sizeof(*hif));
+
+	hdev->hif_ops->receive(hdev, skb);
+}
+
+/**
+ * spi_loopback - fetch a single hif packet from the target
+ *                and send it back
+ */
+
+static unsigned long get_tod_usec(void)
+{
+#if KERNEL_VERSION(5, 0, 0) > LINUX_VERSION_CODE
+	struct timeval tv;
+
+	do_gettimeofday(&tv);
+	return tv.tv_usec;
+#else
+	return (unsigned long) ktime_to_us(ktime_get());
+#endif
+
+}
+
+static int spi_loopback(struct spi_device *spi,
+				struct nrc_spi_priv *priv, int lb_cnt)
+{
+	struct sk_buff *skb;
+	ssize_t size;
+	u32 nr_slot;
+	u32 second_length = 0;
+	int ret = 0;
+	unsigned long t1, t2;
+	struct hif *hif;
+
+	if (priv->loopback_total_cnt == 0) {
+		priv->loopback_last_jiffies = jiffies;
+		priv->loopback_read_usec = 0;
+		priv->loopback_write_usec = 0;
+		priv->loopback_measure_cnt = 0;
+	}
+
+	skb = dev_alloc_skb(priv->slot[RX_SLOT].size * lb_cnt);
+	if (!skb)
+		goto end;
+
+	t1 = get_tod_usec();
+
+	/* Wait until at least one rx slot is non-empty */
+	ret = wait_event_interruptible(priv->wait,
+			(c_spi_num_slots(priv, RX_SLOT) >= lb_cnt
+			 || kthread_should_stop()));
+
+	if (ret < 0)
+		goto end;
+
+	if (kthread_should_stop())
+		goto end;
+
+	size = c_spi_read(spi, skb->data, priv->slot[RX_SLOT].size + 4);
+	if (size < 0)
+		goto end;
+
+	hif = (void*)skb->data;
+
+	nr_slot = DIV_ROUND_UP(sizeof(*hif) + hif->len,
+			priv->slot[RX_SLOT].size);
+	priv->slot[RX_SLOT].tail++;
+
+	t2 = get_tod_usec();
+
+	if (t2 > t1)
+		priv->loopback_read_usec += (t2 - t1);
+
+	t1 = get_tod_usec();
+
+	nr_slot--;
+	if (nr_slot == 0)
+		goto loopback_tx;
+
+	priv->slot[RX_SLOT].tail += nr_slot;
+	second_length = hif->len + sizeof(*hif) - priv->slot[RX_SLOT].size;
+	/* README: align with 4bytes dummy data */
+	second_length = (second_length + 4) & 0xFFFFFFFC;
+	size = c_spi_read(spi, skb->data + priv->slot[RX_SLOT].size,
+			second_length);
+
+loopback_tx:
+	schedule_delayed_work(&priv->work, msecs_to_jiffies(5));
+	ret = wait_event_interruptible(priv->wait,
+			c_spi_num_slots(priv, TX_SLOT) >= lb_cnt);
+	if (ret < 0)
+		goto end;
+
+	cancel_delayed_work_sync(&priv->work);
+	priv->slot[TX_SLOT].tail += lb_cnt;
+
+	ret = c_spi_write(priv->spi, skb->data,
+			(priv->slot[TX_SLOT].size * lb_cnt));
+	if (ret < 0)
+		goto end;
+
+	t2 = get_tod_usec();
+
+	if (t2 > t1)
+		priv->loopback_write_usec += (t2 - t1);
+
+	dev_kfree_skb(skb);
+	priv->loopback_total_cnt += ((priv->slot[TX_SLOT].size * lb_cnt) * 2);
+	priv->loopback_measure_cnt++;
+	if (time_after(jiffies,
+			(priv->loopback_last_jiffies
+			 + msecs_to_jiffies(1000)))) {
+		unsigned long kilo_bits;
+
+		kilo_bits = ((priv->loopback_total_cnt
+					- priv->loopback_prev_cnt) * 8);
+		kilo_bits = (kilo_bits / 1024);
+		priv->loopback_read_usec /= priv->loopback_measure_cnt;
+		priv->loopback_write_usec /= priv->loopback_measure_cnt;
+		nrc_dbg(NRC_DBG_HIF, "loopback throughput(%d kbps @ %d)",
+				kilo_bits, spi->max_speed_hz);
+
+		priv->loopback_last_jiffies = jiffies;
+		priv->loopback_prev_cnt = priv->loopback_total_cnt;
+		priv->loopback_measure_cnt = 0;
+	}
+end:
+	if(skb)
+		dev_kfree_skb(skb);
+
+	return ret;
+}
+
+/**
+ * spi_rx_thread
+ *
+ */
+static int spi_rx_thread(void *data)
+{
+	struct nrc_hif_device *hdev = data;
+	struct nrc_spi_priv *priv = (void *)(hdev + 1);
+	struct spi_device *spi = priv->spi;
+	struct sk_buff *skb;
+	struct hif *hif;
+	struct nrc *nw = hdev->nw;
+	int ret;
+
+	while (!kthread_should_stop()) {
+		if (nw->loopback) {
+			ret = spi_loopback(spi, priv, nw->lb_count);
+			if (ret <= 0)
+				nrc_dbg(NRC_DBG_HIF,
+						"loopback (%d) error.", ret);
+			continue;
+		}
+
+		skb = spi_rx_skb(spi, priv);
+		if (skb) {
+			hif = (void *)skb->data;
+			if (hif->type != HIF_TYPE_LOOPBACK && cspi_suspend) {
+				dev_kfree_skb(skb);
+			} else {
+				hdev->hif_ops->receive(hdev, skb);
+			}
+		}
+	}
+	return 0;
+}
+
+static int spi_read_status(struct spi_device *spi)
+{
+	struct spi_status_reg status;
+	//struct spi_status_reg *priv = &status;
+
+	c_spi_read_regs(spi, C_SPI_EIRQ_MODE, (void *)&status,
+			sizeof(status));
+	//spi_print_status(priv);
+
+	return 0;
+}
+
+static int spi_update_status(struct spi_device *spi)
+{
+	struct nrc_hif_device *hdev = spi_get_drvdata(spi);
+	struct nrc_spi_priv *priv = hdev->priv;
+	struct spi_status_reg *status = &priv->hw.status;
+	struct nrc *nw = hdev->nw;
+	int ret, ac, retry_cnt=0;
+	u32 rear;
+	u16 gap_tx_slot, cleared_sta=0;
+#if defined(CONFIG_SUPPORT_BD)
+	struct regulatory_request request;
+#endif
+
+#ifdef CONFIG_NRC_HIF_PRINT_FLOW_CONTROL
+	int cpuid = smp_processor_id();
+
+	nrc_dbg(NRC_DBG_HIF, "+[%d] %s", cpuid,  __func__);
+#endif
+
+	if (cspi_suspend) return 0;
+
+	SYNC_LOCK(hdev);
+	ret = c_spi_read_regs(spi, C_SPI_EIRQ_MODE, (void *)status,
+			sizeof(*status));
+	SYNC_UNLOCK(hdev);
+	if (ret < 0)
+		return ret;
+
+	if (status->eirq.status & 0x04) {
+#if 0 // for debugging
+		nrc_dbg(NRC_DBG_HIF, "drv_state:%d status:0x%02x mode:0x%02x enable:0x%02x 0x%08X",
+			nw->drv_state, status->eirq.status, status->eirq.mode,
+			status->eirq.enable, status->msg[3]);
+#endif
+#if defined(CONFIG_SUPPORT_BD)
+		request.alpha2[0] = nw->alpha2[0];
+		request.alpha2[1] = nw->alpha2[1];
+		request.initiator = NL80211_REGDOM_SET_BY_DRIVER;
+#endif
+
+		if (ieee80211_hw_check(nw->hw, SUPPORTS_DYNAMIC_PS) &&
+			nw->drv_state >= NRC_DRV_RUNNING &&
+			nw->hw->conf.dynamic_ps_timeout > 0) {
+			mod_timer(&nw->dynamic_ps_timer,
+				jiffies + msecs_to_jiffies(nw->hw->conf.dynamic_ps_timeout));
+		}
+
+		if ((status->msg[3] & 0xffff) == 0x7D) {
+			nw->drv_state = NRC_DRV_REBOOT;
+			nrc_dbg(NRC_DBG_STATE, "init  spi config");
+			spi_config_fw(hdev);
+			nrc_hif_cleanup(nw->hif);
+			nrc_mac_clean_txq(nw);
+		} else if ((status->msg[3] & 0xffff) == 0x9D) {
+			nrc_dbg(NRC_DBG_STATE, "init  spi config");
+			spi_config_fw(hdev);
+			if (nw->vif[0]) {
+				if (nw->vif[0]->type == NL80211_IFTYPE_STATION) {
+					/*
+					 * The target was rebooted due to watchdog.
+					 * Then, driver always requests deauth for trying to reconnect.
+					 */
+					nrc_dbg(NRC_DBG_STATE, "Target (STA) is reset by WDT. Reconnect to AP");
+					mdelay(300);
+					nrc_mac_cancel_hw_scan(nw->hw, nw->vif[0]);
+					nw->drv_state = NRC_DRV_RUNNING;
+					ieee80211_connection_loss(nw->vif[0]);
+				} else if (nw->vif[0]->type == NL80211_IFTYPE_AP) {
+					ieee80211_iterate_stations_atomic(nw->hw, prepare_deauth_sta, (void *)nw->vif[0]);
+					nrc_dbg(NRC_DBG_STATE, "Target (AP) is reset by WDT. Now try to clear all STAs(total cnt:%d)", total_sta);
+					while (1) {
+						//wait for all the sta are locally deauthenticated by mac80211
+						if (!total_sta) break;
+						msleep(2000);
+						remain_sta = 0;
+						ieee80211_iterate_stations_atomic(nw->hw, get_sta_cnt, (void *)nw->vif[0]);
+						cleared_sta = total_sta -remain_sta;
+						if (!remain_sta) {
+							nrc_dbg(NRC_DBG_STATE, "Completed! (Remaining STA cnt:%d)", remain_sta);
+							remain_sta = 0;
+							break;
+						}
+						retry_cnt++;
+						if (retry_cnt > 10) {
+							nrc_dbg(NRC_DBG_STATE, "10 Trials but fail to clear STAs on mac80211. Reset by Force (Remaining STA cnt:%d)",
+								remain_sta);
+							break;
+						}
+						nrc_dbg(NRC_DBG_STATE, "NOT completed yet. Try again. (cleared STA:%d vs remained STA:%d, retry_cnt:%d)",
+							cleared_sta, remain_sta, retry_cnt);
+						total_sta = 0;
+						ieee80211_iterate_stations_atomic(nw->hw, prepare_deauth_sta, (void *)nw->vif[0]);
+					}
+					nrc_dbg(NRC_DBG_STATE, "All STAs are cleared. After 5 seconds, AP will be restarted (retry_cnt:%d remaining sta cnt:%d)",
+						retry_cnt, nrc_stats_report_count());
+					total_sta = 0;
+					mdelay(5000); //it's for STA's reconnect by CQM
+					nrc_free_vif_index(nw, nw->vif[0]);
+					nrc_hif_cleanup(nw->hif);
+					nrc_mac_clean_txq(nw);
+					ieee80211_restart_hw(nw->hw);
+					nw->drv_state = NRC_DRV_RUNNING;
+				}
+			}
+#if defined(CONFIG_SUPPORT_BD)
+			nrc_ps_dbg("[%s,L%d]\n", __func__, __LINE__);
+			nrc_reg_notifier(nw->hw->wiphy, &request);
+#endif
+		} else if ((status->msg[3] & 0xffff) == 0xDC) {
+			/*
+			 * uCode requested the fw downloading.
+			 */
+			msleep(200);
+			atomic_set(&nw->fw_state, NRC_FW_LOADING);
+			//nrc_recovery_wdt_stop(nw);
+			nrc_hif_cleanup(hdev);
+			if (nrc_check_fw_file(nw)) {
+				nrc_download_fw(nw);
+				spi_config_fw(hdev);
+				nrc_release_fw(nw);
+			}
+		} else if ((status->msg[3] & 0xffff) == 0xEC) {
+			/*
+			 * FW notified the target reboot is done.
+			 */
+			atomic_set(&nw->fw_state, NRC_FW_ACTIVE);
+			nrc_hif_resume(hdev);
+#if defined(CONFIG_SUPPORT_BD)
+			nrc_ps_dbg("[%s,L%d]\n", __func__, __LINE__);
+			nrc_reg_notifier(nw->hw->wiphy, &request);
+#endif
+			if (!ieee80211_hw_check(nw->hw, SUPPORTS_DYNAMIC_PS)) {
+				if (power_save >= NRC_PS_DEEPSLEEP_NONTIM) {
+					if (!atomic_read(&nw->d_deauth.delayed_deauth))
+						ieee80211_beacon_loss(nw->vif[0]);
+				}
+				else
+					nw->invoke_beacon_loss = true;
+			} else {
+				if (nw->drv_state >= NRC_DRV_RUNNING &&
+					nw->hw->conf.dynamic_ps_timeout > 0) {
+					mod_timer(&nw->dynamic_ps_timer,
+						jiffies + msecs_to_jiffies(nw->hw->conf.dynamic_ps_timeout));
+				}
+			}
+			if (!disable_cqm) {
+				mod_timer(&nw->bcn_mon_timer,
+					jiffies + msecs_to_jiffies(nw->beacon_timeout));
+			}
+
+			if (atomic_read(&nw->d_deauth.delayed_deauth)) {
+				struct ieee80211_tx_info *txi = IEEE80211_SKB_CB(nw->d_deauth.deauth_frm);
+				struct ieee80211_key_conf *key = txi->control.hw_key;
+				struct sk_buff *skb;
+				int i;
+
+				/* Send deauth frame */
+				nrc_xmit_frame(nw, nw->d_deauth.vif_index, nw->d_deauth.aid, nw->d_deauth.deauth_frm);
+				nw->d_deauth.deauth_frm = NULL;
+				msleep(50);
+
+				/* Finalize data : Common routine */
+				if (nw->d_deauth.p.flags & IEEE80211_KEY_FLAG_PAIRWISE)
+					nrc_wim_install_key(nw, DISABLE_KEY, &nw->d_deauth.v, &nw->d_deauth.s, &nw->d_deauth.p);
+				else if (key)
+					nrc_wim_install_key(nw, DISABLE_KEY, &nw->d_deauth.v, &nw->d_deauth.s, &nw->d_deauth.g);
+				nrc_mac_sta_remove(nw->hw, &nw->d_deauth.v, &nw->d_deauth.s);
+				nrc_mac_bss_info_changed(nw->hw, &nw->d_deauth.v, &nw->d_deauth.b, 0x80309f);
+				for (i=0; i < NRC_QUEUE_MAX; i++) {
+#ifdef CONFIG_SUPPORT_CHANNEL_INFO
+					nrc_mac_conf_tx(nw->hw, &nw->d_deauth.v, i, &nw->d_deauth.tqp[i]);
+#else
+					nrc_mac_conf_tx(nw->hw, i, &nw->d_deauth.tqp[i]);
+#endif
+				}
+				skb = nrc_wim_alloc_skb(nw, WIM_CMD_SET, WIM_MAX_SIZE);
+#ifdef CONFIG_SUPPORT_CHANNEL_INFO
+				nrc_mac_add_tlv_channel(skb, &nw->d_deauth.c);
+#else
+				nrc_mac_add_tlv_channel(skb, &nw->d_deauth.c);
+#endif
+				nrc_xmit_wim_request(nw, skb);
+				if (nw->d_deauth.p.flags & IEEE80211_KEY_FLAG_PAIRWISE && key)
+					nrc_wim_install_key(nw, DISABLE_KEY, &nw->d_deauth.v, &nw->d_deauth.s, &nw->d_deauth.g);
+
+				/* Remove interface : when 'ifconfig wlan0 down' or 'rmmod' */
+				if (nw->d_deauth.removed) {
+					nrc_wim_unset_sta_type(nw, &nw->d_deauth.v);
+					nw->vif[nw->d_deauth.vif_index] = NULL;
+					nw->enable_vif[nw->d_deauth.vif_index] = false;
+					atomic_set(&nw->d_deauth.delayed_deauth, 0);
+					nrc_mac_stop(nw->hw);
+				}
+				while (atomic_read(&nw->d_deauth.delayed_deauth)) {
+					atomic_set(&nw->d_deauth.delayed_deauth, 0);
+				}
+			}
+		}
+	}
+
+	priv->slot[TX_SLOT].count = status->rxq_status[1] & RXQ_SLOT_COUNT;
+	priv->slot[RX_SLOT].count = status->txq_status[1] & TXQ_SLOT_COUNT;
+	priv->slot[RX_SLOT].head = __be32_to_cpu(status->msg[0]) & 0xffff;
+	priv->slot[TX_SLOT].head = __be32_to_cpu(status->msg[0]) >> 16;
+
+	//Workaround (TODO : why the device returns 0x0505)
+	if(priv->slot[RX_SLOT].head == 0x0505 && priv->slot[RX_SLOT].tail == 0) {
+		priv->slot[RX_SLOT].head = 0;
+		nrc_dbg(NRC_DBG_HIF, "[%s,L%d] WRONG HEAD VALUE 0x0505!!!!!!!", __func__, __LINE__);
+	}
+
+	if (nw->loopback)
+		return 0;
+
+	/* Update VIF0 credit */
+	rear = __be32_to_cpu(status->msg[1]);
+	for (ac = 0; ac < 4; ac++)
+		priv->rear[ac] = (rear >> 8*ac) & 0xff;
+
+	/* Update VIF1 credit */
+	rear = __be32_to_cpu(status->msg[2]);
+	for (ac = 0; ac < 4; ac++)
+		priv->rear[6+ac] = (rear >> 8*ac) & 0xff;
+
+
+#ifdef CONFIG_NRC_HIF_PRINT_FLOW_CONTROL
+	nrc_dbg(NRC_DBG_HIF,
+	"* rxslot:(h=%d,t=%d) txslot:(h=%d,t=%d), front:%d,%d,%d,%d,%d,%d,%d,%d rear:%d,%d,%d,%d,%d,%d,%d,%d\n",
+			priv->slot[RX_SLOT].head, priv->slot[RX_SLOT].tail,
+			priv->slot[TX_SLOT].head, priv->slot[TX_SLOT].tail,
+			priv->front[0], priv->front[1],
+			priv->front[2], priv->front[3],
+			priv->front[4], priv->front[5],
+			priv->front[6], priv->front[7],
+			priv->rear[0], priv->rear[1],
+			priv->rear[2], priv->rear[3],
+			priv->rear[4], priv->rear[5],
+			priv->rear[6], priv->rear[7]);
+
+	//if (c_spi_num_slots(priv, RX_SLOT) > 32)
+	//	spi_print_status(status);
+#endif
+
+	gap_tx_slot = c_spi_num_slots(priv, TX_SLOT);
+	if (gap_tx_slot > 32) {
+		WARN_ON(true);
+		nrc_dbg(NRC_DBG_HIF,"* tx slot gap (%d) > 32", gap_tx_slot);
+		/* Workaround : ESL project (fail to recover AP after WDT reset while 300 STAs connect)
+			TX slot gap > 32 when restarting AP by ieee80211_restart_hw after WDT Reset */
+		priv->slot[TX_SLOT].tail += (gap_tx_slot - 32);
+	}
+
+	spi_credit_skb(spi);
+
+#ifdef CONFIG_NRC_HIF_PRINT_FLOW_CONTROL
+	nrc_dbg(NRC_DBG_HIF, "-%s", __func__);
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_SUPPORT_THREADED_IRQ
+/* threaded irq handler */
+static irqreturn_t spi_irq(int irq, void *data)
+{
+	struct nrc_hif_device *hdev = data;
+	struct nrc_spi_priv *priv = (void *)(hdev + 1);
+	struct spi_device *spi = priv->spi;
+	//struct nrc *nw = hdev->nw;
+
+#ifdef CONFIG_NRC_HIF_PRINT_FLOW_CONTROL
+	nrc_dbg(NRC_DBG_HIF, "%s", __func__);
+#endif
+
+	spi_update_status(spi);
+
+	if (c_spi_num_slots(priv, TX_SLOT) > 0 || c_spi_num_slots(priv, RX_SLOT) > 0)
+		wake_up_interruptible(&priv->wait);
+
+	return IRQ_HANDLED;
+}
+#else
+static irqreturn_t spi_irq(int irq, void *data)
+{
+	struct nrc_hif_device *hdev = data;
+	struct nrc_spi_priv *priv = (void *)(hdev + 1);
+
+	queue_work(priv->irq_wq, &priv->irq_work);
+
+	return IRQ_HANDLED;
+}
+
+static void irq_worker(struct work_struct *work)
+{
+	struct nrc_spi_priv *priv = container_of(work,
+			struct nrc_spi_priv, irq_work);
+	struct spi_device *spi = priv->spi;
+
+#ifdef CONFIG_NRC_HIF_PRINT_FLOW_CONTROL
+	nrc_dbg(NRC_DBG_HIF, "%s", __func__);
+#endif
+
+	spi_update_status(spi);
+	wake_up_interruptible(&priv->wait);
+}
+#endif
+
+/* hif lower interface */
+static const char *spi_name(struct nrc_hif_device *dev)
+{
+	return "c-spi";
+}
+
+static bool spi_check_fw(struct nrc_hif_device *hdev)
+{
+	struct nrc_spi_priv *priv = hdev->priv;
+	struct spi_sys_reg sys;
+	int ret;
+
+	nrc_dbg(NRC_DBG_HIF, "[%s++]", __func__);
+	ret = c_spi_read_regs(priv->spi, C_SPI_WAKE_UP, (void *)&sys,
+			sizeof(sys));
+	sys.sw_id = be32_to_cpu(sys.sw_id);
+	nrc_dbg(NRC_DBG_HIF, "[%s, %d] sys.sw_id = 0x%x",
+			__func__, __LINE__, sys.sw_id);
+	if (ret < 0) {
+		nrc_dbg(NRC_DBG_HIF, "failed to read register 0x0");
+		return false;
+	}
+	nrc_dbg(NRC_DBG_HIF, "[%s--]", __func__);
+	return (sys.sw_id == SW_MAGIC_FOR_BOOT);
+}
+
+static int spi_raw_write(struct nrc_hif_device *hdev,
+		const u8 *data, const u32 len)
+{
+	struct nrc_spi_priv *priv = hdev->priv;
+
+	c_spi_write(priv->spi, (u8 *)data, (u32)len);
+	return HIF_TX_COMPLETE;
+}
+
+static int spi_wait_ack(struct nrc_hif_device *hdev, u8 *data, u32 len)
+{
+	struct nrc_spi_priv *priv = hdev->priv;
+	struct spi_status_reg status;
+	int ret;
+
+	do {
+		ret = c_spi_read_regs(priv->spi, C_SPI_EIRQ_MODE,
+				(void *)&status, sizeof(status));
+		if (ret < 0) {
+			nrc_dbg(NRC_DBG_HIF, "[%s, %d] Failed to read regs",
+					__func__, __LINE__);
+			return ret;
+		}
+	} while ((status.rxq_status[1] & RXQ_SLOT_COUNT) < 1);
+	return 0;
+}
+
+static int spi_wait_for_xmit(struct nrc_hif_device *hdev, struct sk_buff *skb)
+{
+	struct nrc_spi_priv *priv = hdev->priv;
+	int nr_slot = DIV_ROUND_UP(skb->len, priv->slot[TX_SLOT].size);
+	int ret;
+
+	if (c_spi_num_slots(priv, TX_SLOT) >= nr_slot)
+		return 0;
+
+	spi_update_status(priv->spi);
+	if (c_spi_num_slots(priv, TX_SLOT) >= nr_slot) {
+		wake_up_interruptible(&priv->wait);
+		return 0;
+	}
+
+//	schedule_delayed_work(&priv->work, msecs_to_jiffies(5));
+
+	ret = wait_event_interruptible(priv->wait,
+			(c_spi_num_slots(priv, TX_SLOT) >= nr_slot) ||
+				kthread_should_stop());
+	if (ret < 0)
+		return ret;
+
+//	cancel_delayed_work_sync(&priv->work);
+
+	return 0;
+}
+
+static int spi_xmit(struct nrc_hif_device *hdev, struct sk_buff *skb)
+{
+	struct nrc *nw = hdev->nw;
+	struct nrc_spi_priv *priv = hdev->priv;
+	//struct spi_device *spi = priv->spi;
+
+	int ret, nr_slot = DIV_ROUND_UP(skb->len, priv->slot[TX_SLOT].size);
+#ifdef CONFIG_TRX_BACKOFF
+	int backoff;
+#endif
+	struct hif_hdr *hif;
+	struct frame_hdr *fh;
+
+	hif = (void *)skb->data;
+	fh = (void *)(hif + 1);
+
+	if (nw->drv_state <= NRC_DRV_CLOSING || nw->loopback)
+		return 0;
+
+	priv->slot[TX_SLOT].tail += nr_slot;
+
+	if ((hif->type == HIF_TYPE_FRAME)
+			&& ((hif->subtype == HIF_FRAME_SUB_DATA_BE)
+				|| (hif->subtype == HIF_FRAME_SUB_MGMT)))
+		priv->front[fh->flags.tx.ac] += nr_slot;
+
+#ifdef CONFIG_TRX_BACKOFF
+	if (!nw->ampdu_supported) {
+		backoff = atomic_inc_return(&priv->trx_backoff);
+
+		if ((backoff % 3) == 0) {
+#ifdef CONFIG_NRC_HIF_PRINT_FLOW_CONTROL
+			nrc_dbg(NRC_DBG_HIF, "%s: backoff=%d",
+				__func__, backoff);
+#endif
+			usleep_range(800, 1000);
+		}
+	}
+#endif
+	//c_spi_write_reg(priv->spi, C_SPI_WAKE_UP, 0x79);
+	/* Yes, I know we are accessing beyound skb->data + skb->len */
+	ret = c_spi_write(priv->spi, skb->data,
+			(nr_slot * priv->slot[TX_SLOT].size));
+#ifdef CONFIG_NRC_HIF_PRINT_FLOW_CONTROL
+	nrc_dbg(NRC_DBG_HIF,
+	"%s ac=%d skb=%p, slot=%d(%d/%d),fwpend:%d/%d, pending=%d",
+			__func__,
+			fh->flags.tx.ac, skb, nr_slot,
+			priv->slot[TX_SLOT].head, priv->slot[TX_SLOT].tail,
+			priv->front[fh->flags.tx.ac],
+			priv->rear[fh->flags.tx.ac],
+			skb_queue_len(&hdev->queue[0]));
+#endif
+
+	return (ret == nr_slot * priv->slot[TX_SLOT].size) ?
+		HIF_TX_COMPLETE : ret;
+}
+
+
+static void spi_poll_status(struct work_struct *work)
+{
+	struct nrc_spi_priv *priv = container_of(to_delayed_work(work),
+			struct nrc_spi_priv, work);
+	struct spi_device *spi = priv->spi;
+
+#ifdef CONFIG_NRC_HIF_PRINT_FLOW_CONTROL
+	nrc_dbg(NRC_DBG_HIF, "%s", __func__);
+#endif
+
+	if (cspi_suspend) return;
+
+	spi_update_status(spi);
+	wake_up_interruptible(&priv->wait);
+}
+
+static int spi_poll_thread (void *data)
+{
+	struct nrc_hif_device *hdev = (struct nrc_hif_device *)data;
+	struct nrc_spi_priv *priv = (struct nrc_spi_priv *)hdev->priv;
+	int gpio = priv->spi->irq;
+	int interval = priv->polling_interval;
+	int ret;
+
+	dev_info(&priv->spi->dev, "%s: gpio=%d interval=%d\n", __func__, gpio, interval);
+
+	if (WARN_ON(interval <= 0))
+		return -1;
+
+	interval *= 1000;
+
+	while (!kthread_should_stop()) {
+		if (gpio < 0) {
+			spi_irq(-1, hdev);
+			wake_up_interruptible(&priv->wait);
+		}
+		else {
+			ret = gpio_get_value_cansleep(gpio);
+
+			if (ret < 0)
+				pr_err("%s: gpio_get_value_cansleep() failed, ret=%d", __func__, ret);
+			else if (ret == !!(CSPI_EIRQ_MODE & 1))
+				spi_irq(gpio, hdev);
+		}
+
+		usleep_range(interval, interval + 100);
+	}
+
+	return 0;
+}
+
+static int spi_start(struct nrc_hif_device *dev)
+{
+	struct nrc_spi_priv *priv = dev->priv;
+	struct spi_device *spi = priv->spi;
+	struct spi_status_reg *status = &priv->hw.status;
+	int ret;
+
+	/* Start rx thread */
+	priv->kthread = kthread_run(spi_rx_thread, dev, "nrc-spi-rx");
+	if (IS_ERR(priv->kthread)) {
+		pr_err("kthread_run() is failed");
+		return PTR_ERR(priv->kthread);
+	}
+
+	INIT_DELAYED_WORK(&priv->work, spi_poll_status);
+
+	atomic_set(&irq_enabled, 0);
+
+	/* Enable interrupt or polling */
+	if (priv->polling_interval > 0) {
+		priv->polling_kthread = kthread_run(spi_poll_thread, dev, "spi-poll");
+		if (IS_ERR(priv->polling_kthread)) {
+			nrc_dbg(NRC_DBG_HIF, "kthread_run() is failed");
+			ret = PTR_ERR(priv->polling_kthread);
+			priv->polling_kthread = NULL;
+			goto kill_kthread;
+		}
+	} else if (spi->irq >= 0) {
+#ifdef CONFIG_SUPPORT_THREADED_IRQ
+		ret = request_threaded_irq(gpio_to_irq(spi->irq), NULL, spi_irq,
+				IRQF_TRIGGER_HIGH | IRQF_ONESHOT,
+				"nrc-spi-irq", dev);
+#else
+		ret = request_irq(gpio_to_irq(spi->irq), spi_irq,
+				IRQF_TRIGGER_HIGH | IRQF_ONESHOT,
+				"nrc-spi-irq", dev);
+#endif
+
+		if (ret < 0) {
+#ifdef CONFIG_SUPPORT_THREADED_IRQ
+			pr_err("request_irq() is failed");
+#else
+			pr_err("request_threaded_irq() is failed");
+#endif
+			goto kill_kthread;
+		}
+
+		atomic_set(&irq_enabled, 1);
+	}
+	else {
+		pr_err("invalid module parameters: spi_gpio_irq < 0 && spi_gpio_poll <= 0 && spi_regs_poll <= 0");
+		goto kill_kthread;
+	}
+
+	ret = spi_update_status(spi);
+
+	/* Restore last state */
+	priv->slot[RX_SLOT].tail = priv->slot[RX_SLOT].head;
+	priv->slot[TX_SLOT].tail = __be32_to_cpu(status->msg[3]) & 0xffff;
+
+	cspi_suspend = false;
+	return ret;
+
+ kill_kthread:
+	kthread_stop(priv->kthread);
+	priv->kthread = NULL;
+
+	return 0;
+}
+
+static int spi_suspend(struct nrc_hif_device *dev)
+{
+	struct nrc_spi_priv *priv = dev->priv;
+	struct spi_device *spi = priv->spi;
+	struct nrc *nw = dev->nw;
+
+	nrc_ps_dbg("[%s] drv_state:%d wowlan_enabled:%x power_save:%d",
+			__func__, nw->drv_state, nw->wowlan_enabled, power_save);
+	if (nw->drv_state == NRC_DRV_RUNNING &&
+		(nw->wowlan_enabled || (power_save >= NRC_PS_DEEPSLEEP_TIM))) {
+		nw->drv_state = NRC_DRV_PS;
+		/**
+		 * this delay is necessary to achive sending WIM meg completly.
+		 * (especially, WIM_TLV_PS_ENABLE)
+		 */
+		usleep_range(20 * 1000, 30 * 1000);
+
+		if (spi->irq >= 0 && priv->polling_interval <= 0) {
+			/* Waits for any pending IRQ handlers for this interrupt to complete */
+			synchronize_irq(gpio_to_irq(spi->irq));
+
+			/**
+			 * The SPI IRQ will be never disabled because it needs to be asserted
+			 * by sending FW ready WIM message from target when uCode received a TIM
+			 * and it has to notify wake-up to the host.
+			 */
+			//disable_irq(gpio_to_irq(spi->irq));
+			//atomic_set(&irq_enabled, 0);
+		}
+
+		nrc_hif_flush_wq(dev);
+		spi_config_fw(dev);
+	} else {
+		cspi_suspend = true;
+	}
+
+	return 0;
+}
+
+static void spi_set_default_credit(struct nrc_spi_priv *priv)
+{
+	int i;
+
+	for (i = 0; i < CREDIT_QUEUE_MAX; i++)
+		priv->credit_max[i] = 0;
+
+	switch (priv->hw.sys.chip_id) {
+	case 0x7291:
+	case 0x7292:
+		priv->credit_max[0] = CREDIT_AC0;
+		priv->credit_max[1] = credit_ac_be;
+		//priv->credit_max[1] = CREDIT_AC1_7292;
+		priv->credit_max[2] = CREDIT_AC2;
+		priv->credit_max[3] = CREDIT_AC3;
+
+		priv->credit_max[6] = CREDIT_AC0;
+		priv->credit_max[7] = CREDIT_AC1;
+		priv->credit_max[8] = CREDIT_AC2;
+		priv->credit_max[9] = CREDIT_AC3;
+
+		/* README: Temporary Disable Fastboot function of CM0.
+		 * To testing BA Encoding Workaround -- swki -- 2020-0518
+		 */
+		priv->fastboot = false;
+		break;
+
+	case 0x7391:
+	case 0x7392:
+	case 0x4791:
+		priv->credit_max[0] = 4;
+		priv->credit_max[1] = CREDIT_AC1_7392;
+		priv->credit_max[2] = 4;
+		priv->credit_max[3] = 4;
+
+		priv->credit_max[6] = 4;
+		priv->credit_max[7] = CREDIT_AC1_7392;
+		priv->credit_max[8] = 4;
+		priv->credit_max[9] = 4;
+		priv->fastboot = false;
+		break;
+
+	case 0x6201:
+		priv->credit_max[0] = CREDIT_AC0;
+		priv->credit_max[1] = CREDIT_AC1;
+		priv->credit_max[2] = CREDIT_AC2;
+		priv->credit_max[3] = CREDIT_AC3;
+
+		priv->credit_max[6] = CREDIT_AC0;
+		priv->credit_max[7] = CREDIT_AC1;
+		priv->credit_max[8] = CREDIT_AC2;
+		priv->credit_max[9] = CREDIT_AC3;
+		priv->fastboot = false;
+		break;
+	}
+
+	for (i = 0; i < CREDIT_QUEUE_MAX; i++)  {
+		nrc_dbg(NRC_DBG_HIF, "credit[%2d] :%3d", i, priv->credit_max[i]);
+	}
+}
+
+static int spi_resume(struct nrc_hif_device *dev)
+{
+	struct nrc_spi_priv *priv = dev->priv;
+	struct spi_device *spi = priv->spi;
+	struct spi_sys_reg *sys = &priv->hw.sys;
+	int ret;
+
+	if (power_save >= NRC_PS_DEEPSLEEP_TIM) {
+		nrc_ps_dbg("[%s] drv_state:%d wowlan_enabled:%x power_save:%d", __func__,
+				dev->nw->drv_state, dev->nw->wowlan_enabled, power_save);
+		if (dev->nw->drv_state == NRC_DRV_PS) {
+			ret = c_spi_read_regs(spi, C_SPI_WAKE_UP, (void *)sys, sizeof(*sys));
+			dev->nw->drv_state = NRC_DRV_RUNNING;
+			ieee80211_wake_queues(dev->nw->hw);
+			gpio_set_value(RPI_GPIO_FOR_PS, 0);
+		} else {
+			cspi_suspend = false;
+
+			if (spi->irq >= 0 && priv->polling_interval <= 0) {
+				/*
+				 * The SPI IRQ will be never disabled because it needs to be asserted
+				 * by sending FW ready WIM message from target when uCode received a TIM
+				 * and it has to notify wake-up to the host.
+				 * So, it is not necessary the codes as below.
+				 */
+				//if (atomic_read(&irq_enabled) == 0) {
+				//	enable_irq(gpio_to_irq(spi->irq));
+				//	atomic_set(&irq_enabled, 1);
+				//}
+
+				/* README:
+				 *  At this point, I assume the firmware has ready to use CSPI.
+				 */
+			}
+
+			/* Read the register */
+			ret = c_spi_read_regs(spi, C_SPI_WAKE_UP, (void *)sys, sizeof(*sys));
+
+			spi_config_fw(dev);
+			c_spi_config(spi);
+			spi_set_default_credit(priv);
+
+			spi_update_status(spi);
+		}
+	} else {
+		cspi_suspend = false;
+		if (dev->nw->wowlan_enabled && dev->nw->drv_state == NRC_DRV_PS) {
+			if (spi->irq >= 0 && priv->polling_interval <= 0) {
+				if (atomic_read(&irq_enabled) == 0) {
+					enable_irq(gpio_to_irq(spi->irq));
+					atomic_set(&irq_enabled, 1);
+				}
+			}
+
+			/* Read the register */
+			ret = c_spi_read_regs(spi, C_SPI_WAKE_UP, (void *)sys, sizeof(*sys));
+			dev->nw->drv_state = NRC_DRV_RUNNING;
+
+			//spi_config_fw(dev);
+			c_spi_config(spi);
+			spi_set_default_credit(priv);
+
+			spi_update_status(spi);
+		}
+	}
+
+	return 0;
+}
+
+void spi_reset(struct nrc_hif_device *hdev)
+{
+	struct nrc_spi_priv *priv = hdev->priv;
+	struct spi_device *spi = priv->spi;
+	int i;
+
+	if (enable_hspi_init) {
+		for(i=0; i<180; i++)
+			_c_spi_write_dummy(spi);
+	}
+	/* 0xC8 is magic number for reset the device */
+	c_spi_write_reg(spi, C_SPI_DEVICE_STATUS, 0xC8);
+}
+
+static int spi_stop(struct nrc_hif_device *dev)
+{
+	//struct nrc_spi_priv *priv = dev->priv;
+	//struct spi_device *spi = priv->spi;
+	//BUG_ON(priv == NULL);
+	//BUG_ON(spi == NULL);
+
+	//if (spi->irq >= 0) {
+	//	if (priv->polling_interval <= 0) {
+	//		synchronize_irq(gpio_to_irq(spi->irq));
+	//		free_irq(gpio_to_irq(spi->irq), dev);
+	//	}
+	//}
+#if defined(ENABLE_HW_RESET)
+	gpio_set_value(RPI_GPIO_FOR_RST, 0);
+	msleep(10);
+	gpio_set_value(RPI_GPIO_FOR_RST, 1);
+
+	gpio_free(RPI_GPIO_FOR_RST);
+#else
+	spi_reset(dev);
+#endif
+	gpio_set_value(RPI_GPIO_FOR_PS, 1);
+	gpio_free(RPI_GPIO_FOR_PS);
+	return 0;
+}
+
+static void spi_disable_irq(struct nrc_hif_device *hdev);
+static void spi_close(struct nrc_hif_device *dev)
+{
+	struct nrc_spi_priv *priv = dev->priv;
+
+	spi_disable_irq(dev);
+	priv->slot[TX_SLOT].count = 999;
+	if (priv->polling_kthread)
+		kthread_stop(priv->polling_kthread);
+	if (priv->kthread)
+		kthread_stop(priv->kthread);
+	wake_up_interruptible(&priv->wait);
+}
+
+
+int spi_test(struct nrc_hif_device *hdev)
+{
+/* temporary function for soc */
+	struct nrc_spi_priv *priv = hdev->priv;
+	struct spi_device *spi = priv->spi;
+	struct spi_status_reg *status = &priv->hw.status;
+	struct spi_sys_reg *sys = &priv->hw.sys;
+	int ret;
+
+	nrc_dbg(NRC_DBG_HIF, "+ read sys");
+	ret = c_spi_read_regs(spi, C_SPI_WAKE_UP, (void *)sys,
+			sizeof(*sys));
+	nrc_dbg(NRC_DBG_HIF, "- read sys");
+
+	print_hex_dump(KERN_DEBUG, "sys ", DUMP_PREFIX_NONE, 16, 1,
+			sys, sizeof(*sys), false);
+
+	if (ret < 0)
+		return ret;
+
+	nrc_dbg(NRC_DBG_HIF, "+ read status");
+	ret = c_spi_read_regs(spi, C_SPI_EIRQ_MODE, (void *)status,
+			sizeof(*status));
+	nrc_dbg(NRC_DBG_HIF, "- read status");
+
+	print_hex_dump(KERN_DEBUG, "status ", DUMP_PREFIX_NONE, 16, 1,
+			status, sizeof(*status), false);
+
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+void spi_wakeup(struct nrc_hif_device *hdev)
+{
+	struct nrc_spi_priv *priv = hdev->priv;
+	struct spi_device *spi = priv->spi;
+
+	//spi_enable_irq(hdev);
+	//c_spi_enable_irq(spi, true);
+	//nrc_ps_dbg("spi-wakeup");
+	/* 0x79 is magic number for wakeup the device from sleep mode */
+	c_spi_write_reg(spi, C_SPI_WAKE_UP, 0x79);
+
+}
+
+static void spi_config_fw(struct nrc_hif_device *dev)
+{
+	struct nrc_hif_device *hdev = dev;
+	struct nrc_spi_priv *priv = (void *)(hdev + 1);
+	int ac;
+
+	priv->slot[RX_SLOT].tail = priv->slot[RX_SLOT].head = 0;
+	priv->slot[TX_SLOT].tail = priv->slot[TX_SLOT].head = 0;
+
+	for (ac = 0; ac < CREDIT_QUEUE_MAX; ac++) {
+		priv->front[ac] = 0;
+		priv->rear[ac] = 0;
+	}
+}
+
+static void spi_sync_lock(struct nrc_hif_device *hdev)
+{
+	struct nrc_spi_priv *priv = hdev->priv;
+
+	mutex_lock(&priv->bus_lock_mutex);
+}
+
+static void spi_sync_unlock(struct nrc_hif_device *hdev)
+{
+	struct nrc_spi_priv *priv = hdev->priv;
+
+	mutex_unlock(&priv->bus_lock_mutex);
+}
+
+static void spi_disable_irq(struct nrc_hif_device *hdev)
+{
+	struct nrc_spi_priv *priv = hdev->priv;
+	struct spi_device *spi = priv->spi;
+
+	if (spi->irq >= 0) {
+		if (priv->polling_interval <= 0) {
+			//disable_irq(gpio_to_irq(spi->irq));
+			disable_irq_nosync(gpio_to_irq(spi->irq));
+		}
+	}
+}
+
+static void spi_enable_irq(struct nrc_hif_device *hdev)
+{
+	struct nrc_spi_priv *priv = hdev->priv;
+	struct spi_device *spi = priv->spi;
+
+	if (spi->irq >= 0)
+		if (priv->polling_interval <= 0)
+			enable_irq(gpio_to_irq(spi->irq));
+}
+
+static int spi_status_irq(struct nrc_hif_device *hdev)
+{
+	struct nrc_spi_priv *priv = hdev->priv;
+	struct spi_device *spi = priv->spi;
+	int irq = gpio_get_value(spi->irq);
+
+	return irq;
+}
+
+static void spi_clear_irq(struct nrc_hif_device *hdev)
+{
+	struct nrc_spi_priv *priv = hdev->priv;
+	struct spi_device *spi = priv->spi;
+
+	spi_read_status(spi);
+}
+
+static void spi_update(struct nrc_hif_device *hdev)
+{
+	struct nrc_spi_priv *priv = hdev->priv;
+	struct spi_device *spi = priv->spi;
+	struct spi_status_reg *status = &priv->hw.status;
+	int ret;
+	u32 rear;
+	int ac;
+
+	ret = c_spi_read_regs(spi, C_SPI_EIRQ_MODE, (void *)status,
+			sizeof(*status));
+	if (ret < 0)
+		return;
+
+	priv->slot[TX_SLOT].count = status->rxq_status[1] & RXQ_SLOT_COUNT;
+	priv->slot[RX_SLOT].count = status->txq_status[1] & TXQ_SLOT_COUNT;
+	priv->slot[RX_SLOT].head = __be32_to_cpu(status->msg[0]) & 0xffff;
+	priv->slot[TX_SLOT].head = __be32_to_cpu(status->msg[0]) >> 16;
+
+	/* Update VIF0 credit */
+	rear = __be32_to_cpu(status->msg[1]);
+	for (ac = 0; ac < 4; ac++)
+		priv->rear[ac] = (rear >> 8*ac) & 0xff;
+
+	/* Update VIF1 credit */
+	rear = __be32_to_cpu(status->msg[2]);
+	for (ac = 0; ac < 4; ac++)
+		priv->rear[6+ac] = (rear >> 8*ac) & 0xff;
+}
+
+static void spi_gpio(int v)
+{
+#if defined(SPI_DBG)
+	gpio_set_value(SPI_DBG, v);
+#endif
+}
+
+static bool spi_support_fastboot(struct nrc_hif_device *hdev)
+{
+	struct nrc_spi_priv *priv = hdev->priv;
+
+	return priv->fastboot;
+}
+
+static int spi_suspend_rx_thread(struct nrc_hif_device *hdev)
+{
+	struct nrc_spi_priv *priv = hdev->priv;
+	struct spi_device *spi = priv->spi;
+
+	if (spi->irq >= 0 && priv->polling_interval <= 0) {
+		if (atomic_read(&irq_enabled) == 1) {
+			disable_irq_nosync(gpio_to_irq(spi->irq));
+			atomic_set(&irq_enabled, 0);
+		}
+	}
+
+	cspi_suspend = true;
+	return 0;
+}
+
+static int spi_resume_rx_thread(struct nrc_hif_device *hdev)
+{
+	struct nrc_spi_priv *priv = hdev->priv;
+	struct spi_device *spi = priv->spi;
+
+	if (spi->irq >= 0 && priv->polling_interval <= 0) {
+		if (atomic_read(&irq_enabled) == 0) {
+			enable_irq(gpio_to_irq(spi->irq));
+			atomic_set(&irq_enabled, 1);
+		}
+	}
+
+	cspi_suspend = false;
+	return 0;
+}
+
+static int spi_check_target(struct nrc_hif_device *hdev, u8 reg)
+{
+	struct nrc_spi_priv *priv = hdev->priv;
+	struct spi_device *spi = priv->spi;
+	struct spi_status_reg *status = &priv->hw.status;
+	int ret;
+
+	ret = c_spi_read_regs(spi, C_SPI_EIRQ_MODE, (void *)status,
+			sizeof(*status));
+
+	if (ret < 0)
+		return ret;
+
+	return (int)(*(((u8*)status) + reg - C_SPI_EIRQ_MODE));
+}
+
+#if defined(CONFIG_CHECK_READY)
+static bool spi_check_ready(struct nrc_hif_device *hdev)
+{
+	struct nrc_spi_priv *priv = hdev->priv;
+	struct spi_device *spi = priv->spi;
+	int ret = 0;
+	u8 dev_status = 0;
+
+	ret = c_spi_read_regs(spi, C_SPI_DEVICE_STATUS, (void *)&dev_status,
+			sizeof(dev_status));
+
+	if (ret < 0)
+		return false;
+
+	return (bool)(dev_status&0x1);
+}
+#endif /* defined(CONFIG_CHECK_READY) */
+
+static struct nrc_hif_ops spi_ops = {
+	.name = spi_name,
+	.check_fw = spi_check_fw,
+	.xmit = spi_xmit,
+	.wait_for_xmit = spi_wait_for_xmit,
+	.write = spi_raw_write,
+	.wait_ack = spi_wait_ack,
+	.start = spi_start,
+	.stop = spi_stop,
+	.suspend = spi_suspend,
+	.resume = spi_resume,
+	.close = spi_close,
+	.reset = spi_reset,
+	.wakeup = spi_wakeup,
+	.test = spi_test,
+	.config = spi_config_fw,
+	.sync_lock = spi_sync_lock,
+	.sync_unlock = spi_sync_unlock,
+	.disable_irq = spi_disable_irq,
+	.enable_irq = spi_enable_irq,
+	.status_irq = spi_status_irq,
+	.clear_irq = spi_clear_irq,
+	.update = spi_update,
+	.set_gpio = spi_gpio,
+	.support_fastboot = spi_support_fastboot,
+	.suspend_rx_thread = spi_suspend_rx_thread,
+	.resume_rx_thread = spi_resume_rx_thread,
+	.check_target = spi_check_target,
+#if defined(CONFIG_CHECK_READY)
+	.check_ready = spi_check_ready,
+#endif /* defined(CONFIG_CHECK_READY) */
+
+};
+
+static void c_spi_enable_irq(struct spi_device *spi, bool enable)
+{
+	if (enable) {
+		c_spi_write_reg(spi, C_SPI_EIRQ_MODE, CSPI_EIRQ_MODE);
+		c_spi_write_reg(spi, C_SPI_EIRQ_ENABLE, CSPI_EIRQ_ENABLE);
+	} else {
+		c_spi_write_reg(spi, C_SPI_EIRQ_MODE, 0x0);
+		c_spi_write_reg(spi, C_SPI_EIRQ_ENABLE, 0x0);
+	}
+}
+
+static void c_spi_config(struct spi_device *spi)
+{
+	struct nrc_hif_device *hdev = spi_get_drvdata(spi);
+	struct nrc_spi_priv *priv = hdev->priv;
+	struct spi_sys_reg *sys = &priv->hw.sys;
+
+	sys->chip_id = be16_to_cpu(sys->chip_id);
+	sys->sw_id = be32_to_cpu(sys->sw_id);
+
+	switch (sys->chip_id) {
+	case 0x7291:
+		priv->slot[TX_SLOT].size = 456;
+		priv->slot[RX_SLOT].size = 492;
+		spi_ops.need_maskrom_war = true;
+		spi_ops.sync_auto = true;
+		break;
+	case 0x7391:
+	case 0x7292:
+	case 0x7392:
+	case 0x4791:
+		priv->slot[TX_SLOT].size = 456;
+		priv->slot[RX_SLOT].size = 492;
+		spi_ops.need_maskrom_war = false;
+		spi_ops.sync_auto = false;
+		//spi_ops.sync_auto = true;
+		break;
+	case 0x6201:
+		priv->slot[TX_SLOT].size = 456;
+		priv->slot[RX_SLOT].size = 492;
+		spi_ops.need_maskrom_war = false;
+		spi_ops.sync_auto = true;
+		break;
+	default:
+		nrc_dbg(NRC_DBG_HIF,
+			"Unknown Newracom IEEE80211 chipset %04x",
+			sys->chip_id);
+		BUG();
+	}
+
+	nrc_dbg(NRC_DBG_HIF,
+	"Newracom IEEE802.11 C-SPI: chipid=%04x, sw_id=%04x, board_id=%04X",
+		sys->chip_id, sys->sw_id, sys->board_id);
+	if (sys->sw_id == SW_MAGIC_FOR_BOOT)
+		nrc_dbg(NRC_DBG_HIF, "Boot loader");
+	else if (sys->sw_id == SW_MAGIC_FOR_FW)
+		nrc_dbg(NRC_DBG_HIF, "Firmware");
+
+	c_spi_enable_irq(spi, spi->irq >= 0 ? true : false);
+}
+
+#if defined(CONFIG_CHECK_READY)
+static bool c_check_device_ready(struct spi_device *spi)
+{
+	struct spi_sys_reg sys;
+	bool res = false;
+	int ret = 0;
+
+	ret = c_spi_read_regs(spi, C_SPI_WAKE_UP, (void *)&sys, sizeof(sys));
+	if (ret < 0) {
+		nrc_dbg(NRC_DBG_HIF, "failed to read register 0x1\n");
+		mdelay(50);
+		res = false;
+	} else {
+		if ((be16_to_cpu(sys.chip_id) != 0x7392 && be16_to_cpu(sys.chip_id) != 0x4791) 
+			|| (sys.status& 0x1))
+			res = true;
+	}
+
+	return res;
+}
+#endif /* defined(CONFIG_CHECK_READY) */
+
+static int c_spi_probe(struct spi_device *spi)
+{
+	struct nrc_hif_device *hdev = spi->dev.platform_data;
+	struct nrc_spi_priv *priv = hdev->priv;
+	struct spi_sys_reg *sys = &priv->hw.sys;
+	int ret;
+
+	priv->spi = spi;
+	priv->loopback_prev_cnt = 0;
+	priv->loopback_total_cnt = 0;
+	priv->loopback_last_jiffies = 0;
+	priv->loopback_read_usec = 0;
+	priv->loopback_write_usec = 0;
+	priv->fastboot = false;
+	priv->polling_interval = spi_polling_interval;
+
+	init_waitqueue_head(&priv->wait);
+	spin_lock_init(&priv->lock);
+	spi_set_drvdata(spi, hdev);
+	priv->ops = &cspi_ops;
+
+	if (fw_name && enable_hspi_init) {
+		spi_reset(hdev);
+#if defined(CONFIG_CHECK_READY)
+		while (!c_check_device_ready(spi));
+#endif /* defined(CONFIG_CHECK_READY) */
+	}
+
+	/* Read the register */
+	ret = c_spi_read_regs(spi, C_SPI_WAKE_UP, (void *)sys, sizeof(*sys));
+	if (ret < 0) {
+		pr_err("[Error] failed to read register(0x0).");
+		priv->spi = NULL;
+		goto fail;
+	}
+
+	if (fw_name) {
+		spi_reset(hdev);
+#if defined(CONFIG_CHECK_READY)
+		while (!c_check_device_ready(spi));
+#endif /* defined(CONFIG_CHECK_READY) */
+	}
+
+	c_spi_config(spi);
+	spi_set_default_credit(priv);
+
+	if (spi->irq >= 0) {
+		/* Claim gpio used for irq */
+		if (gpio_request(spi->irq, "nrc-spi-irq") < 0) {
+			pr_err("[Error] gpio_reqeust() is failed");
+			gpio_free(spi->irq);
+			goto fail;
+		}
+		gpio_direction_input(spi->irq);
+	}
+
+#if defined(SPI_DBG)
+	/* Claim gpio used for debugging */
+	if (gpio_request(SPI_DBG, "nrc-spi-dgb") < 0) {
+		pr_err("[Error] gpio_reqeust() is failed");
+		gpio_free(SPI_DBG);
+		goto fail;
+	}
+	gpio_direction_output(SPI_DBG, 1);
+#endif
+#if defined(ENABLE_HW_RESET)
+	if (gpio_request(RPI_GPIO_FOR_RST, "nrc-reset") < 0) {
+		pr_err("[Error] gpio_reqeust(nrc-reset) is failed");
+		gpio_free(RPI_GPIO_FOR_RST);
+		goto fail;
+	}
+	gpio_direction_output(RPI_GPIO_FOR_RST, 1);
+#endif
+
+	return 0;
+fail:
+	return -EINVAL;
+}
+
+static int c_spi_remove(struct spi_device *spi)
+{
+	//struct nrc_hif_device *hdev = spi->dev.platform_data;
+#if !defined(CONFIG_SUPPORT_THREADED_IRQ)
+	struct nrc_spi_priv *priv = hdev->priv;
+#endif
+
+	if (spi->irq >= 0) {
+		//free_irq(gpio_to_irq(spi->irq), hdev);
+		gpio_free(spi->irq);
+	}
+
+#if defined(SPI_DBG)
+	gpio_free(SPI_DBG);
+#endif
+
+#if !defined(CONFIG_SUPPORT_THREADED_IRQ)
+	flush_workqueue(priv->irq_wq);
+	destroy_workqueue(priv->irq_wq);
+#endif
+	return 0;
+}
+
+static struct spi_driver spi_driver = {
+	.probe = c_spi_probe,
+	.remove = c_spi_remove,
+	.driver = {
+		.name = "nrc-cspi",
+	},
+};
+
+static struct spi_board_info bi = {
+	.modalias = "nrc-cspi",
+//	.chip_select = 0,
+	.mode = SPI_MODE_0,
+};
+
+struct nrc_hif_device *nrc_hif_cspi_init(void)
+{
+	struct nrc_hif_device *hdev;
+	struct nrc_spi_priv *priv;
+	struct spi_device *spi;
+	struct spi_master *master;
+	int ret;
+
+	hdev = kzalloc(sizeof(*hdev) + sizeof(*priv), GFP_KERNEL);
+	if (!hdev) {
+		/*nrc_dbg(NRC_DBG_HIF, "failed to allocate nrc_hif_device");*/
+		return NULL;
+	}
+	priv = (void *)(hdev + 1);
+	mutex_init(&priv->bus_lock_mutex);
+	hdev->priv = priv;
+	hdev->hif_ops = &spi_ops;
+
+#if !defined(CONFIG_SUPPORT_THREADED_IRQ)
+	priv->irq_wq = create_singlethread_workqueue("nrc_cspi_irq");
+	INIT_WORK(&priv->irq_work, irq_worker);
+#endif
+
+	/* Apply module parameters */
+	bi.bus_num = spi_bus_num;
+	bi.chip_select = spi_cs_num;
+	bi.irq = spi_gpio_irq;
+	bi.platform_data = hdev;
+	bi.max_speed_hz = hifspeed;
+
+	nrc_common_dbg("max_speed_hz = %d\n", bi.max_speed_hz);
+
+	/* Find the spi master that our device is attached to */
+	master = spi_busnum_to_master(spi_bus_num);
+	if (!master) {
+		pr_err("[Error] could not find spi master with the bus number %d.",
+			spi_bus_num);
+		goto fail;
+	}
+
+	/* Instantiate and add a spi device */
+	spi = spi_new_device(master, &bi);
+	if (!spi) {
+		pr_err("[Error] failed to instantiate a new spi device.");
+		goto fail;
+	}
+
+	/* Register spi driver */
+	ret = spi_register_driver(&spi_driver);
+	if (ret) {
+		pr_err("[Error] failed to register spi driver(%s).",
+			spi_driver.driver.name);
+		goto unregister_device;
+	}
+
+#ifdef CONFIG_TRX_BACKOFF
+	atomic_set(&priv->trx_backoff, 0);
+#endif
+	return hdev;
+
+unregister_device:
+	spi_unregister_device(spi);
+	spi_unregister_driver(&spi_driver);
+fail:
+	kfree(hdev);
+
+	return NULL;
+}
+
+int nrc_hif_cspi_exit(struct nrc_hif_device *hdev)
+{
+	struct nrc_spi_priv *priv = NULL;
+	struct spi_device *spi = NULL;
+
+	if (!hdev)
+		return 0;
+
+	priv = hdev->priv;
+	spi = priv->spi;
+
+	cancel_delayed_work(&priv->work);
+
+	if (spi->irq >= 0) {
+		if (priv->polling_interval <= 0) {
+			synchronize_irq(gpio_to_irq(spi->irq));
+			free_irq(gpio_to_irq(spi->irq), hdev);
+		}
+	}
+
+	spi_unregister_device(spi);
+	spi_unregister_driver(&spi_driver);
+
+	kfree(hdev);
+
+	return 0;
+}
diff --git a/drivers/staging/nrc/nrc-hif-cspi.h b/drivers/staging/nrc/nrc-hif-cspi.h
new file mode 100644
index 000000000000..0c0fccd13bf9
--- /dev/null
+++ b/drivers/staging/nrc/nrc-hif-cspi.h
@@ -0,0 +1,23 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _NRC_HIF_CSPI_H_
+#define _NRC_HIF_CSPI_H_
+
+struct nrc_hif_device *nrc_hif_cspi_init(void);
+int nrc_hif_cspi_exit(struct nrc_hif_device *hdev);
+
+#endif
diff --git a/drivers/staging/nrc/nrc-hif-debug.c b/drivers/staging/nrc/nrc-hif-debug.c
new file mode 100644
index 000000000000..ed4b30d7461d
--- /dev/null
+++ b/drivers/staging/nrc/nrc-hif-debug.c
@@ -0,0 +1,121 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include "nrc-hif.h"
+#include "nrc-hif-debug.h"
+#include "nrc-debug.h"
+
+#ifdef CONFIG_NRC_HIF_DEBUG
+
+static const char *nrc_hif_debug_name(struct nrc_hif_device *dev)
+{
+	return "DEBUG";
+}
+
+static int nrc_hif_debug_start(struct nrc_hif_device *dev)
+{
+	nrc_dbg(NRC_DBG_HIF, "%s()", __func__);
+	return 0;
+}
+
+static int nrc_hif_debug_stop(struct nrc_hif_device *dev)
+{
+	nrc_dbg(NRC_DBG_HIF, "%s()", __func__);
+	return 0;
+}
+
+static int nrc_hif_debug_write(struct nrc_hif_device *dev, const u8 *data,
+		const u32 len)
+{
+	print_hex_dump(KERN_DEBUG, " ", DUMP_PREFIX_NONE, 16, 1, data, len,
+			false);
+
+	return 0;
+}
+
+static int nrc_hif_debug_write_begin(struct nrc_hif_device *dev)
+{
+	nrc_dbg(NRC_DBG_HIF, "%s()", __func__);
+	return 0;
+}
+
+static int nrc_hif_debug_write_body(struct nrc_hif_device *dev,
+		const u8 *body, const u32 len)
+{
+	nrc_dbg(NRC_DBG_HIF, "%s(body:%d)", __func__, len);
+	print_hex_dump(KERN_DEBUG, " ", DUMP_PREFIX_NONE, 16, 1, body,
+			len, false);
+	return 0;
+}
+
+static int nrc_hif_debug_write_end(struct nrc_hif_device *dev)
+{
+	nrc_dbg(NRC_DBG_HIF, "%s()", __func__);
+	return 0;
+}
+
+static int nrc_hif_debug_suspend(struct nrc_hif_device *dev)
+{
+	nrc_dbg(NRC_DBG_HIF, "%s()", __func__);
+	return 0;
+}
+
+static int nrc_hif_debug_resume(struct nrc_hif_device *dev)
+{
+	nrc_dbg(NRC_DBG_HIF, "%s()", __func__);
+	return 0;
+}
+
+static struct nrc_hif_ops nrc_hif_debug_ops = {
+	.name = nrc_hif_debug_name,
+	.start = nrc_hif_debug_start,
+	.stop = nrc_hif_debug_stop,
+	.write = nrc_hif_debug_write,
+	.write_begin = nrc_hif_debug_write_begin,
+	.write_body = nrc_hif_debug_write_body,
+	.write_end = nrc_hif_debug_write_end,
+	.suspend = nrc_hif_debug_suspend,
+	.resume = nrc_hif_debug_resume
+};
+
+struct nrc_hif_device *nrc_hif_debug_init(void)
+{
+	struct nrc_hif_device *dev = kmalloc(sizeof(*dev), GFP_KERNEL);
+
+	nrc_dbg(NRC_DBG_HIF, "%s()", __func__);
+
+	if (!dev)
+		return NULL;
+
+	dev->hif_ops = &nrc_hif_debug_ops;
+	dev->priv = NULL;
+
+	return dev;
+}
+
+int nrc_hif_debug_exit(struct nrc_hif_device *dev)
+{
+	nrc_dbg(NRC_DBG_HIF, "%s()", __func__);
+
+	if (!dev)
+		return -EINVAL;
+	kfree(dev);
+
+	return 0;
+}
+
+#endif
+
diff --git a/drivers/staging/nrc/nrc-hif-debug.h b/drivers/staging/nrc/nrc-hif-debug.h
new file mode 100644
index 000000000000..8d1747e5bcdb
--- /dev/null
+++ b/drivers/staging/nrc/nrc-hif-debug.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _NRC_HIF_SPI_H_
+#define _NRC_HIF_SPI_H_
+
+#ifdef CONFIG_NRC_HIF_DEBUG
+
+struct nrc_hif_device *nrc_hif_debug_init(void);
+int nrc_hif_debug_exit(struct nrc_hif_device *dev);
+
+#else
+
+struct nrc_hif_device *nrc_hif_debug_init(void)
+{
+	return NULL;
+}
+
+static inline int nrc_hif_debug_exit(struct nrc_hif_device *dev)
+{
+	return 0;
+}
+#endif
+
+#endif
diff --git a/drivers/staging/nrc/nrc-hif-sdio.c b/drivers/staging/nrc/nrc-hif-sdio.c
new file mode 100644
index 000000000000..2498a2450876
--- /dev/null
+++ b/drivers/staging/nrc/nrc-hif-sdio.c
@@ -0,0 +1,1108 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/wait.h>
+#include <linux/spi/spi.h>
+#include <linux/gpio.h>
+#include <linux/irqreturn.h>
+#include <linux/interrupt.h>
+#include <asm/unaligned.h>
+#include <linux/smp.h>
+#ifdef CONFIG_SUPPORT_AFTER_KERNEL_3_0_36
+#include <linux/timekeeping.h>
+#else
+#include <linux/kthread.h>
+#endif
+
+#include <linux/mmc/card.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/core.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/sdio_func.h>
+#include <linux/mmc/sdio_ids.h>
+#include <linux/mmc/sdio.h>
+#include <linux/mmc/sd.h>
+#include <linux/string.h>
+
+#include "nrc-fw.h"
+#include "nrc-hif.h"
+#include "wim.h"
+
+//static bool once;
+static atomic_t suspend;
+
+#define SDIO_ADMA_EN	1
+
+
+#define SDIO_512_INFO	0
+#define TCN  (4)
+#define TCNE (0)
+#define CREDIT_AC0	(TCN*4+TCNE)	/* BK */
+#define CREDIT_AC1	(TCN*4+TCNE)	/* BE */
+#define CREDIT_AC2	(TCN*4+TCNE)	/* VI */
+#define CREDIT_AC3	(TCN*4+TCNE)	/* VO */
+
+/* only use for NRC7291 others are using same value */
+#define CREDIT_AC3_7291	(TCN*2+TCNE)	/* VO */
+
+/* N-SPI host-side memory map */
+#define C_SPI_WAKE_UP 0x0
+#define C_SPI_DEVICE_STATUS 0x1
+#define C_SPI_CHIP_ID_HIGH 0x2
+#define C_SPI_CHIP_ID_LOW 0x3
+#define C_SPI_MODEM_ID 0x4
+#define C_SPI_SOFTWARE_VERSION 0x8
+#define C_SPI_BOARD_ID 0xc
+#define C_SPI_EIRQ_MODE 0x10
+#define C_SPI_EIRQ_ENABLE 0x11
+#define C_SPI_EIRQ_STATUS_LATCH 0x12
+#define C_SPI_EIRQ_STATUS 0x13
+#define C_SPI_QUEUE_STATUS 0x14 /* 0x1f */
+#define C_SPI_MESSAGE 0x20 /* 0x2f */
+
+#define C_SPI_RXQ_THRESHOLD 0x30
+#define C_SPI_RXQ_WINDOW 0x31
+
+#define C_SPI_TXQ_THRESHOLD 0x40
+#define C_SPI_TXQ_WINDOW 0x41
+
+#define SW_MAGIC_FOR_BOOT	(0x01020716)
+#define SW_MAGIC_FOR_FW		(0x01210630)
+
+struct sdio_sys_reg {
+	u8 wakeup;	/* 0x0 */
+	u8 status;	/* 0x1 */
+	u16 chip_id;	/* 0x2-0x3 */
+	u32 modem_id;	/* 0x4-0x7 */
+	u32 sw_id;	/* 0x8-0xb */
+	u32 board_id;	/* 0xc-0xf */
+} __packed;
+
+struct sdio_status_reg {
+	struct {
+		u8 mode;
+		u8 enable;
+		u8 latched_status;
+		u8 status;
+	} eirq;
+	u8 txq_status[6];
+	u8 rxq_status[6];
+	u32 msg[4];
+
+#define EIRQ_IO_ENABLE	(1<<2)
+#define EIRQ_EDGE	(1<<1)
+#define EIRQ_ACTIVE_LO	(1<<0)
+
+#define EIRQ_DEV_SLEEP	(1<<3)
+#define EIRQ_DEV_READY	(1<<2)
+#define EIRQ_RXQ	(1<<1)
+#define EIRQ_TXQ	(1<<0)
+
+#define TXQ_ERROR	(1<<7)
+#define TXQ_SLOT_COUNT	(0x7F)
+#define RXQ_SLOT_COUNT	(0x7F)
+
+} __packed;
+
+#define SPI_BUFFER_SIZE (496-20)
+
+#define TX_SLOT 0
+#define RX_SLOT 1
+
+#define CREDIT_QUEUE_MAX (12)
+
+#define  TRANSA_SDIO_DEBUG
+#define  TRANSA_SDIO_VENDER  0x0296
+#define  TRANSA_SDIO_DEVICE  0x5347
+
+#define SDIO_ADDR_INFO		        (unsigned int)(0x101)
+#define SDIO_ADDR_INFO_ASYNC		(unsigned int)(0x111)
+#define SDIO_ADDR_DATA		        (unsigned int)(0x200)
+
+static const struct sdio_device_id transa_sdio_dev[] = {
+	{ SDIO_DEVICE(TRANSA_SDIO_VENDER, TRANSA_SDIO_DEVICE) },
+	{},
+};
+
+struct sdio_data_t {
+	unsigned int	  credit_vif0;
+	unsigned int	  credit_vif1;
+	unsigned int	  info_wr;
+	unsigned int	  info_rd;
+};
+
+/* Object prepended to strut nrc_hif_device */
+struct transa_sdio_priv_t {
+	struct sdio_func   *func;
+
+	/* work, kthread, ... */
+	struct delayed_work work;
+	struct task_struct *kthread;
+	wait_queue_head_t wait; /* wait queue */
+
+	struct {
+		struct sdio_sys_reg    sys;
+		struct sdio_status_reg status;
+	} hw;
+
+	spinlock_t lock;
+	struct {
+		unsigned int head;
+		unsigned int tail;
+		unsigned int size;
+		unsigned int count;
+	} slot[2];
+	/* VIF0(AC0~AC3), BCN, CONC, VIF1(AC0~AC3), padding*/
+	u8 front[CREDIT_QUEUE_MAX];
+	u8 rear[CREDIT_QUEUE_MAX];
+	u8 credit_max[CREDIT_QUEUE_MAX];
+
+	unsigned long loopback_prev_cnt;
+	unsigned long loopback_total_cnt;
+	unsigned long loopback_last_jiffies;
+	unsigned long loopback_read_usec;
+	unsigned long loopback_write_usec;
+	unsigned long loopback_measure_cnt;
+
+	unsigned int	          recv_len;
+	unsigned int	          recv_num;
+	struct dentry *debugfs;
+
+	unsigned int	  credit_vif0;
+	unsigned int	  credit_vif1;
+
+	struct sdio_data_t sdio_info;
+	struct sk_buff  *skb_tx_last;
+};
+
+struct transa_sdio_priv_t *transa_sdio_priv;
+static bool once;
+
+#ifdef TRANSA_SDIO_DEBUG
+
+static unsigned long get_tod_usec(void)
+{
+#if KERNEL_VERSION(5, 0, 0) > LINUX_VERSION_CODE
+	struct timeval tv;
+
+	do_gettimeofday(&tv);
+	return tv.tv_usec;
+#else
+	return (unsigned long) ktime_to_us(ktime_get());
+#endif
+}
+
+static int nrc_debugfs_sdio_read(void *data, u64 *val)
+{
+	int ret, cnt = 1;
+	struct sk_buff *skb = dev_alloc_skb(2048);
+
+	pr_info("[RRRRR] %s\n", __func__);
+
+	sdio_claim_host(transa_sdio_priv->func);
+	ret = sdio_memcpy_fromio(transa_sdio_priv->func, skb->data,
+						    SDIO_ADDR_INFO, 0x10);
+	sdio_release_host(transa_sdio_priv->func);
+	print_hex_dump(KERN_DEBUG, "wangc: ",
+					  DUMP_PREFIX_NONE, 8, 1,
+					  skb->data, 16, false);
+	sdio_claim_host(transa_sdio_priv->func);
+	ret = sdio_memcpy_fromio(transa_sdio_priv->func, skb->data,
+				   SDIO_ADDR_DATA, 0x20);
+	sdio_release_host(transa_sdio_priv->func);
+	print_hex_dump(KERN_DEBUG, "wangc: ",
+					  DUMP_PREFIX_NONE, 8, 1,
+					  skb->data, 16, false);
+	pr_info("%s, ret: %d, cnt: %d\n", __func__,
+				   ret, cnt);
+
+	return ret;
+}
+
+static int nrc_debugfs_sdio_write(void *data1, u64 val)
+{
+	int ret = 0;
+	struct sk_buff *skb, *skb2, *skb3;
+	void *data;
+	u64 i = val;
+
+	pr_info("[WWWWW] %s, cout: %d\n", __func__, (int)i);
+
+	skb = dev_alloc_skb(2048);
+	skb2 = dev_alloc_skb(1536);
+	skb3 = dev_alloc_skb(1536);
+
+	memset(skb->data, 0x58, 2048);
+	memset(skb2->data, 0x34, 1024);
+
+	if (val == 0) {
+		struct transa_sdio_priv_t *priv = transa_sdio_priv;
+		int i = 0;
+
+		while (ret == 0) {
+			pr_info("[wangc] loop  count: %d\n",  i);
+			sdio_claim_host(priv->func);
+			ret = sdio_memcpy_toio(priv->func, 0xaa,
+							   skb->data, 1562);
+			ret = sdio_memcpy_toio(priv->func, 0xaa,
+							   skb->data, 1562);
+			ret = sdio_memcpy_toio(priv->func, 0xaa,
+							   skb->data, 1562);
+			ret = sdio_memcpy_toio(priv->func, 0xaa,
+							   skb->data, 1562);
+			sdio_release_host(priv->func);
+			i++;
+		}
+	}
+
+	if ((val == 123) || (val == 321)) {
+		unsigned long t1, t2;
+		struct transa_sdio_priv_t *priv = transa_sdio_priv;
+
+		if (priv->loopback_total_cnt == 0) {
+			priv->loopback_last_jiffies = jiffies;
+			priv->loopback_read_usec = 0;
+			priv->loopback_write_usec = 0;
+			priv->loopback_measure_cnt = 0;
+		}
+		val = 0xFFFFFFFF;
+		priv->recv_len = 512;
+
+		while (val) {
+			if (priv->loopback_measure_cnt % 2)
+				data = (void *)skb->data;
+			else
+				data = (void *)skb2->data;
+
+			t1 = get_tod_usec();
+			sdio_claim_host(priv->func);
+			ret = sdio_memcpy_toio(priv->func, 0xaa,
+						   data, priv->recv_len);
+			sdio_release_host(priv->func);
+			t2 = get_tod_usec();
+			if (t2 > t1)
+				priv->loopback_write_usec += (t2 - t1);
+
+			if (ret) {
+#ifdef CONFIG_SUPPORT_AFTER_KERNEL_3_0_36
+				pr_info("[wangc]sdio host write ret: %d, count: %u, skb->data: %p\n",
+					ret,
+					(u32) (priv->loopback_measure_cnt % 2),
+					data);
+#endif
+				print_hex_dump(KERN_DEBUG, "wangc: ",
+						 DUMP_PREFIX_NONE, 16, 1,
+						 data, 496, false);
+				break;
+			}
+			priv->loopback_total_cnt += (priv->recv_len * 2);
+			priv->loopback_measure_cnt++;
+
+			if (time_after(jiffies,
+					(priv->loopback_last_jiffies
+					 + msecs_to_jiffies(1000)))) {
+				unsigned long kilo_bits;
+
+				kilo_bits = ((priv->loopback_total_cnt
+						- priv->loopback_prev_cnt) * 8);
+				kilo_bits = (kilo_bits / 1024);
+				priv->loopback_read_usec /=
+						  priv->loopback_measure_cnt;
+				priv->loopback_write_usec /=
+						  priv->loopback_measure_cnt;
+				nrc_dbg(NRC_DBG_HIF, "loopback throughput(%d kbps @ %d)",
+					 kilo_bits,
+					 priv->func->card->host->ios.clock);
+
+				pr_info("[wangc]loopback_measure_cnt : %d\n",
+					 (int) priv->loopback_measure_cnt);
+
+				priv->loopback_last_jiffies = jiffies;
+				priv->loopback_prev_cnt =
+						  priv->loopback_total_cnt;
+				priv->loopback_measure_cnt = 0;
+				val--;
+			}
+		}
+		dev_kfree_skb(skb);
+		dev_kfree_skb(skb2);
+		dev_kfree_skb(skb3);
+
+		return 0;
+	}
+
+	sdio_claim_host(transa_sdio_priv->func);
+	ret = sdio_memcpy_toio(transa_sdio_priv->func, 0xaa,
+						   skb->data, (int) i);
+	sdio_release_host(transa_sdio_priv->func);
+	pr_info("%s, ret: %d\n", __func__, ret);
+
+	dev_kfree_skb(skb);
+	dev_kfree_skb(skb2);
+	dev_kfree_skb(skb3);
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(nrc_debugfs_sdio,
+			nrc_debugfs_sdio_read,
+			nrc_debugfs_sdio_write,
+			"%llu\n");
+
+void nrc_init_debugfs_sdio(void)
+{
+	pr_info("[XXXXX] %s\n", __func__);
+	transa_sdio_priv->debugfs = debugfs_create_file("nrc_debugfs_sdio",
+				0600, NULL, NULL, &nrc_debugfs_sdio);
+}
+#endif
+
+static inline u16 sdio_num_slots(struct transa_sdio_priv_t *priv, int dir)
+{
+	return (priv->slot[dir].head - priv->slot[dir].tail);
+}
+
+/**
+ * spi_rx_skb - fetch a single hif packet from the target
+ */
+int stop_tx;
+static struct sk_buff *sdio_rx_skb(struct transa_sdio_priv_t *priv)
+{
+	struct sk_buff *skb = NULL;
+	struct hif *hif;
+	int ret;
+	int recv_len;
+
+#ifdef CONFIG_TRX_BACKOFF
+	struct nrc_hif_device *hdev = sdio_get_drvdata(priv->func);
+	struct nrc *nw = hdev->nw;
+	int backoff;
+#endif
+	/* Wait until at least one rx slot is non-empty */
+	ret = wait_event_interruptible(priv->wait,
+			  (priv->recv_len > 1 || kthread_should_stop()));
+	if (ret < 0)
+		goto fail;
+
+	if (kthread_should_stop())
+		goto fail;
+
+#ifdef CONFIG_TRX_BACKOFF
+	if (!nw->ampdu_supported) {
+		backoff = atomic_inc_return(&priv->trx_backoff);
+
+		if ((backoff % 3) != 0) {
+#ifdef CONFIG_NRC_HIF_PRINT_FLOW_CONTROL
+			nrc_dbg(NRC_DBG_HIF, "rx-irq: backoff=%d\n", backoff);
+#endif
+			usleep_range(800, 1000);
+		}
+	}
+#endif
+	recv_len = priv->recv_len;
+	skb = dev_alloc_skb(recv_len);
+	skb_put(skb, recv_len);
+	sdio_claim_host(priv->func);
+	ret = sdio_memcpy_fromio(priv->func, skb->data,
+						  SDIO_ADDR_DATA, recv_len);
+	if (ret) {
+		print_hex_dump(KERN_DEBUG, "wangc-rx: ",
+					   DUMP_PREFIX_NONE, 16, 1,
+					   skb->data, skb->len, false);
+		pr_info("[wangc-err] rx-len: %d\n", skb->len);
+		stop_tx = 1;
+		sdio_release_host(priv->func);
+		goto fail;
+	}
+
+	priv->recv_len = 1;
+	sdio_release_host(priv->func);
+
+	/* Calculate how many more slot to read for this hif packet */
+	hif = (void *)skb->data;
+
+	if (hif->type >= HIF_TYPE_MAX || hif->len == 0) {
+		nrc_dbg(NRC_DBG_HIF,
+				"[wangc-error111]type: %d, len: %d, slot[%d/%d], info_rd: %d\n",
+				hif->type, hif->len,
+				priv->slot[RX_SLOT].head,
+				priv->slot[RX_SLOT].tail,
+				priv->sdio_info.info_rd);
+
+		print_hex_dump(KERN_DEBUG, "rxskb ",
+					   DUMP_PREFIX_NONE, 16, 1,
+					   skb->data, skb->len,
+					   false);
+		msleep(200);
+		BUG();
+	}
+
+#ifdef CONFIG_NRC_HIF_PRINT_FLOW_CONTROL
+	nrc_dbg(NRC_DBG_HIF, "rx-irq: skb=%p len:%d, hif_type=%d\n",
+			skb, skb->len, hif->type);
+#endif
+
+	return skb;
+
+fail:
+	if (skb)
+		dev_kfree_skb(skb);
+	return NULL;
+}
+
+
+static void sdio_credit_skb(struct nrc_hif_device *hdev)
+{
+	struct transa_sdio_priv_t *priv = hdev->priv;
+	struct sk_buff *skb;
+	struct hif *hif;
+	struct wim *wim;
+	struct wim_credit_report *cr;
+	u8 *p;
+	int i;
+	int size = sizeof(*hif) + sizeof(*wim) + sizeof(*cr);
+
+	if (!once) {
+		once = true;
+		return;
+	}
+
+	skb = dev_alloc_skb(size);
+
+	p = skb->data;
+	hif = (void *)p;
+	hif->type = HIF_TYPE_WIM;
+	hif->subtype = HIF_WIM_SUB_EVENT;
+	hif->vifindex = 0;
+	hif->len = sizeof(*wim) + sizeof(*cr);
+
+	p += sizeof(*hif);
+	wim = (void *)p;
+	wim->event = WIM_EVENT_CREDIT_REPORT;
+
+	p += sizeof(*wim);
+	cr = (void *)p;
+	cr->h.type = WIM_TLV_AC_CREDIT_REPORT;
+	cr->h.len = sizeof(struct wim_credit_report_param);
+
+	cr->v.change_index = 0;
+
+	for (i = 0; i < CREDIT_QUEUE_MAX; i++) {
+		u8 room = priv->front[i] - priv->rear[i];
+
+		room = min(priv->credit_max[i], room);
+		cr->v.ac[i] = priv->credit_max[i] - room;
+
+#ifdef CONFIG_NRC_HIF_PRINT_FLOW_CONTROL
+		nrc_dbg(NRC_DBG_HIF, "credit[%d] %d f:%d, r:%d\n",
+				i, cr->v.ac[i], priv->front[i],
+				priv->rear[i]);
+#endif
+	}
+
+	skb_put(skb, hif->len+sizeof(*hif));
+
+	hdev->hif_ops->receive(hdev, skb);
+}
+
+static int sdio_update_status(struct nrc_hif_device *hdev)
+{
+	struct transa_sdio_priv_t *priv = hdev->priv;
+	u32 rear;
+	int ac, ret;
+
+	sdio_claim_host(priv->func);
+	ret = sdio_memcpy_fromio(priv->func, &priv->sdio_info,
+					    SDIO_ADDR_INFO_ASYNC, 0x10);
+	if (ret < 0) {
+		pr_info("[wangc] %s, ret: %d\n", __func__, ret);
+		sdio_release_host(priv->func);
+		return ret;
+	}
+	priv->slot[TX_SLOT].head = priv->sdio_info.info_wr;
+	priv->slot[RX_SLOT].head = priv->sdio_info.info_rd;
+
+	if (hdev->nw->loopback) {
+		sdio_release_host(priv->func);
+		return 0;
+	}
+
+	if ((priv->sdio_info.credit_vif0 != priv->credit_vif0) ||
+		(priv->sdio_info.credit_vif1 != priv->credit_vif1)) {
+		/* Update VIF0 credit */
+		rear = priv->sdio_info.credit_vif0;
+		priv->credit_vif0 = rear;
+		for (ac = 0; ac < 4; ac++)
+			priv->rear[ac] = (rear >> 8*ac) & 0xff;
+
+		/* Update VIF1 credit */
+		rear = priv->sdio_info.credit_vif1;
+		priv->credit_vif1 = rear;
+		for (ac = 0; ac < 4; ac++)
+			priv->rear[6+ac] = (rear >> 8*ac) & 0xff;
+
+		sdio_release_host(priv->func);
+		sdio_credit_skb(hdev);
+	} else {
+		sdio_release_host(priv->func);
+	}
+
+	return 0;
+}
+
+static void sdio_poll_status(struct work_struct *work)
+{
+	struct transa_sdio_priv_t *priv = container_of(to_delayed_work(work),
+			struct transa_sdio_priv_t, work);
+	struct sdio_func *func = priv->func;
+
+	sdio_update_status(sdio_get_drvdata(func));
+	wake_up_interruptible(&priv->wait);
+}
+
+static int sdio_loopback(struct transa_sdio_priv_t *priv, int count)
+{
+	struct sk_buff *skb;
+	int ret;
+	char str[32] = "0";
+	unsigned long t1, t2;
+
+	if (priv->loopback_total_cnt == 0) {
+		priv->loopback_last_jiffies = jiffies;
+		priv->loopback_read_usec = 0;
+		priv->loopback_write_usec = 0;
+		priv->loopback_measure_cnt = 0;
+	}
+
+	skb = dev_alloc_skb(1024);
+	if (!skb)
+		goto end;
+
+	wait_event_interruptible(priv->wait,
+			(priv->recv_num || kthread_should_stop()));
+
+	t1 = get_tod_usec();
+	sdio_claim_host(priv->func);
+	ret = sdio_memcpy_fromio(priv->func, skb->data, 0xc00, priv->recv_len);
+	sdio_release_host(priv->func);
+	t2 = get_tod_usec();
+	if (t2 > t1)
+		priv->loopback_read_usec += (t2 - t1);
+
+	if (ret) {
+		pr_info("[wangc]sdio host read ret: %d\n", ret);
+		pr_info("%s\n", str);
+	}
+
+	priv->recv_num = 0;
+
+	t1 = get_tod_usec();
+	sdio_claim_host(priv->func);
+	ret = sdio_memcpy_toio(priv->func, 0xaa, skb->data, priv->recv_len);
+	sdio_release_host(priv->func);
+	t2 = get_tod_usec();
+	if (t2 > t1)
+		priv->loopback_write_usec += (t2 - t1);
+
+	if (ret) {
+		pr_info("[wangc]sdio host write ret: %d\n", ret);
+		pr_info("%s\n", str);
+	}
+
+	dev_kfree_skb(skb);
+	priv->loopback_total_cnt += (priv->recv_len * 2);
+	priv->loopback_measure_cnt++;
+
+	if (time_after(jiffies,
+			(priv->loopback_last_jiffies
+			 + msecs_to_jiffies(1000)))) {
+		unsigned long kilo_bits;
+
+		kilo_bits = ((priv->loopback_total_cnt
+					- priv->loopback_prev_cnt) * 8);
+		kilo_bits = (kilo_bits / 1024);
+		priv->loopback_read_usec /= priv->loopback_measure_cnt;
+		priv->loopback_write_usec /= priv->loopback_measure_cnt;
+		nrc_dbg(NRC_DBG_HIF, "loopback throughput(%d kbps @ %d), packet len: %d",
+				kilo_bits,
+				priv->func->card->host->ios.clock,
+				priv->recv_len);
+
+		priv->loopback_last_jiffies = jiffies;
+		priv->loopback_prev_cnt = priv->loopback_total_cnt;
+		priv->loopback_measure_cnt = 0;
+	}
+
+	return 1;
+end:
+	if (skb)
+		dev_kfree_skb(skb);
+
+	return ret;
+}
+
+static int sdio_rx_thread(void *data)
+{
+	struct nrc_hif_device *hdev = data;
+	struct transa_sdio_priv_t *priv = (void *)(hdev + 1);
+	struct nrc *nw = hdev->nw;
+	struct sk_buff *skb;
+	int is_suspend;
+	int ret;
+
+	pr_info("[wangc]rx thread entry, loopbakc: %d\n", nw->loopback);
+
+	while (!kthread_should_stop()) {
+		if (nw->loopback == 1) {
+			nrc_debugfs_sdio_write(NULL, 123);
+			ret = sdio_loopback(priv, nw->lb_count);
+			if (ret <= 0)
+				nrc_dbg(NRC_DBG_HIF, "loopback (%d) error.\n",
+					   ret);
+			continue;
+		}
+
+		skb = sdio_rx_skb(priv);
+		is_suspend = atomic_read(&suspend);
+		if (skb && is_suspend) {
+			dev_kfree_skb(skb);
+			atomic_set(&suspend, 0);
+		} else if (skb) {
+			hdev->hif_ops->receive(hdev, skb);
+		} else {
+			nw->drv_state = NRC_DRV_CLOSING;
+			pr_info("[wangc]rx-head: %d, rx-tail: %d, rx-cnt: %d\n",
+					priv->slot[RX_SLOT].head,
+					priv->slot[RX_SLOT].tail,
+					priv->sdio_info.info_rd);
+			break;
+		}
+	}
+	pr_info("rx thread exit\n");
+
+	return 0;
+}
+
+/* hif lower interface */
+static const char *sdio_name(struct nrc_hif_device *dev)
+{
+	return "sdio";
+}
+
+
+static int sdio_noop(struct nrc_hif_device *dev)
+{
+	return 0;
+}
+
+static int sdio_suspend(struct nrc_hif_device *dev)
+{
+	atomic_set(&suspend, 1);
+	return 0;
+}
+
+static int sdio_resume(struct nrc_hif_device *dev)
+{
+	atomic_set(&suspend, 0);
+	return 0;
+}
+
+static bool sdio_check_fw(struct nrc_hif_device *hdev)
+{
+	return 1;
+}
+
+static int sdio_xmit(struct nrc_hif_device *hdev, struct sk_buff *skb)
+{
+	struct nrc *nw = hdev->nw;
+	struct transa_sdio_priv_t *priv = hdev->priv;
+	int ret, nr_slot = DIV_ROUND_UP(skb->len, priv->slot[TX_SLOT].size);
+#ifdef CONFIG_TRX_BACKOFF
+	int backoff;
+#endif
+	struct hif_hdr *hif;
+	struct frame_hdr *fh;
+	int n = 0, rev = 0;
+
+	hif = (void *)skb->data;
+	fh = (void *)(hif + 1);
+
+	if (nw->drv_state == NRC_DRV_CLOSING)
+		return 0;
+
+	if (nw->loopback)
+		return 0;
+
+	if (stop_tx)
+		return 0;
+
+	schedule_delayed_work(&priv->work, msecs_to_jiffies(5));
+	ret = wait_event_interruptible(priv->wait,
+			sdio_num_slots(priv, TX_SLOT) >= nr_slot);
+	if (ret < 0)
+		return ret;
+
+	cancel_delayed_work_sync(&priv->work);
+
+	if (nw->drv_state == NRC_DRV_CLOSING)
+		return 0;
+	priv->slot[TX_SLOT].tail += nr_slot;
+	priv->slot[TX_SLOT].tail &= 0xFFFF;
+
+	if ((hif->type == HIF_TYPE_FRAME)
+			&& ((hif->subtype == HIF_FRAME_SUB_DATA_BE)
+				|| (hif->subtype == HIF_FRAME_SUB_MGMT)))
+		priv->front[fh->flags.tx.ac] += nr_slot;
+
+#ifdef CONFIG_TRX_BACKOFF
+	if (!nw->ampdu_supported) {
+		backoff = atomic_inc_return(&priv->trx_backoff);
+
+		if ((backoff % 3) == 0) {
+#ifdef CONFIG_NRC_HIF_PRINT_FLOW_CONTROL
+			nrc_dbg(NRC_DBG_HIF, "spi_xmit: backoff=%d\n",
+					backoff);
+#endif
+			usleep_range(800, 1000);
+		}
+	}
+#endif
+	/* Yes, I know we are accessing beyound skb->data + skb->len */
+		n = skb->len;
+		rev = 0;
+
+		sdio_claim_host(priv->func);
+		if (n) {
+			ret = sdio_memcpy_toio(priv->func, SDIO_ADDR_DATA,
+				    skb->data, n);
+			if (ret) {
+				stop_tx = 1;
+				pr_info("[wangc]%s, len = %d, nr_slot = %d\n",
+						   __func__, n * 512, nr_slot);
+				print_hex_dump(KERN_DEBUG, "wangc-tx: ",
+					   DUMP_PREFIX_NONE, 32, 1, skb->data,
+					   64, false);
+				return ret;
+			}
+		}
+
+		if (rev) {
+			if (n)
+				udelay(200);
+			ret = sdio_memcpy_toio(priv->func, SDIO_ADDR_DATA,
+						   skb->data + n * 512,  rev);
+			if (ret) {
+				stop_tx = 1;
+				pr_info("[wangc]%s, len = %d, nr_slot = %d\n",
+						   __func__, rev, nr_slot);
+				print_hex_dump(KERN_DEBUG, "wangc-tx: ",
+						  DUMP_PREFIX_NONE, 32, 1,
+						  skb->data, 64, false);
+				return ret;
+			}
+		}
+		sdio_release_host(priv->func);
+#ifdef CONFIG_NRC_HIF_PRINT_FLOW_CONTROL
+	nrc_dbg(NRC_DBG_HIF,
+	"spi_xmit ac=%d skb=%p, slot=%d(%d/%d),fwpend:%d/%d, pending=%d\n",
+			fh->flags.tx.ac, skb, nr_slot,
+			priv->slot[TX_SLOT].head, priv->slot[TX_SLOT].tail,
+			priv->front[fh->flags.tx.ac],
+			priv->rear[fh->flags.tx.ac],
+			skb_queue_len(&hdev->queue[0]));
+#endif
+#ifdef CONFIG_FAST_CREDIT_UPDATE
+	sdio_update_status(hdev);
+#endif
+	return (ret == 0) ? HIF_TX_COMPLETE : ret;
+}
+
+static int
+sdio_raw_write(struct nrc_hif_device *hdev,	const u8 *data,
+				    const u32 len)
+{
+	return 0;
+}
+
+static int sdio_wait_ack(struct nrc_hif_device *hdev, u8 *data, u32 len)
+{
+	return 0;
+}
+
+static int sdio_start(struct nrc_hif_device *hdev)
+{
+	int ret;
+	struct transa_sdio_priv_t *priv = hdev->priv;
+
+	/* Start rx thread */
+	if (hdev->nw->loopback == 1)
+		return 0;
+
+	priv->kthread = kthread_run(sdio_rx_thread, hdev, "sdio-rx");
+
+	if (hdev->nw->loopback == 1)
+		return 0;
+
+
+	INIT_DELAYED_WORK(&priv->work, sdio_poll_status);
+
+	sdio_claim_host(priv->func);
+	ret = sdio_update_status(hdev);
+	sdio_release_host(priv->func);
+	atomic_set(&suspend, 0);
+	pr_info("[wangc]%s\n", __func__);
+
+	return ret;
+}
+
+
+static void sdio_close(struct nrc_hif_device *hdev)
+{
+	struct transa_sdio_priv_t *priv = hdev->priv;
+
+	priv->slot[TX_SLOT].count = 999;
+	kthread_stop(priv->kthread);
+	wake_up_interruptible(&priv->wait);
+
+	pr_info("[XXXXXXXXXX] %s\n", __func__);
+}
+
+
+void sdio_reset(struct nrc_hif_device *hdev)
+{
+	pr_info("[XXXXXXXXXX] %s\n", __func__);
+}
+
+
+void sdio_wakeup(struct nrc_hif_device *hdev)
+{
+	pr_info("[XXXXXXXXXX] %s\n", __func__);
+}
+
+
+int sdio_test(struct nrc_hif_device *hdev)
+{
+	pr_info("[XXXXXXXXXX] %s\n", __func__);
+	return 0;
+}
+
+void transa_sdio_irq_handler(struct sdio_func *func)
+{
+	struct nrc_hif_device     *hdev = sdio_get_drvdata(func);
+	struct transa_sdio_priv_t *priv = hdev->priv;
+	u32 rear;
+	unsigned char lowbyte, highbyte;
+	int ret, ac;
+
+	sdio_claim_host(priv->func);
+	lowbyte  = sdio_readb(priv->func, 0x00, &ret);
+	highbyte = sdio_readb(priv->func, 0x01, &ret);
+	priv->recv_len  = (highbyte << 8) | lowbyte;
+
+	if (priv->recv_len == 1) {
+		ret = sdio_memcpy_fromio(priv->func, &priv->sdio_info,
+				   SDIO_ADDR_INFO, 0x10 /*priv->recv_len*/);
+
+		if (ret < 0) {
+			pr_info("[wangc] %s, info-ret: %d\n", __func__, ret);
+			sdio_release_host(priv->func);
+			return;
+		}
+		priv->slot[TX_SLOT].head = priv->sdio_info.info_wr;
+		priv->slot[RX_SLOT].head = priv->sdio_info.info_rd;
+
+		if ((priv->sdio_info.credit_vif0 != priv->credit_vif0) ||
+			(priv->sdio_info.credit_vif1 != priv->credit_vif1)) {
+			/* Update VIF0 credit */
+			rear = priv->sdio_info.credit_vif0;
+			priv->credit_vif0 = rear;
+			for (ac = 0; ac < 4; ac++)
+				priv->rear[ac] = (rear >> 8*ac) & 0xff;
+
+
+			/* Update VIF1 credit */
+			rear = priv->sdio_info.credit_vif1;
+			priv->credit_vif1 = rear;
+			for (ac = 0; ac < 4; ac++)
+				priv->rear[6+ac] = (rear >> 8*ac) & 0xff;
+
+			//need_credit = 1;
+			sdio_release_host(priv->func);
+			sdio_credit_skb(hdev);
+			sdio_claim_host(func);
+		}
+#ifdef CONFIG_NRC_HIF_PRINT_FLOW_CONTROL
+		nrc_dbg(NRC_DBG_HIF, "-%s\n", __func__);
+#endif
+	}
+	sdio_release_host(priv->func);
+	wake_up_interruptible(&priv->wait);
+}
+
+#define SDIO_BLK_SIZE		(512)
+static int transa_sdio_probe(struct sdio_func *func,
+					 const struct sdio_device_id *id)
+{
+	struct transa_sdio_priv_t *priv = transa_sdio_priv;
+	int ret = 0;
+
+	priv->func = func;
+
+	priv->loopback_prev_cnt = 0;
+	priv->loopback_total_cnt = 0;
+	priv->loopback_last_jiffies = 0;
+	priv->loopback_read_usec = 0;
+	priv->loopback_write_usec = 0;
+
+	//SDK version
+	priv->slot[TX_SLOT].size = 456;
+	priv->slot[RX_SLOT].size = 492;
+
+	priv->credit_max[0] = CREDIT_AC0;
+	priv->credit_max[1] = CREDIT_AC1;
+	priv->credit_max[2] = CREDIT_AC2;
+	priv->credit_max[3] = CREDIT_AC3;
+
+	priv->credit_max[6] = CREDIT_AC0;
+	priv->credit_max[7] = CREDIT_AC1;
+	priv->credit_max[8] = CREDIT_AC2;
+	priv->credit_max[9] = CREDIT_AC3;
+
+	init_waitqueue_head(&priv->wait);
+
+	func->max_blksize = SDIO_BLK_SIZE;
+
+	sdio_claim_host(func);
+
+	ret = sdio_enable_func(func);
+	if (ret) {
+		nrc_dbg(NRC_DBG_HIF, "failed to enable sdio func\n");
+		sdio_release_host(func);
+		return ret;
+	}
+
+	ret = sdio_set_block_size(func, SDIO_BLK_SIZE);
+	if (ret) {
+		nrc_dbg(NRC_DBG_HIF, "failed to set sdio func block size\n");
+		sdio_release_host(func);
+		return ret;
+	}
+
+	ret = sdio_claim_irq(func, transa_sdio_irq_handler);
+	if (ret) {
+		nrc_dbg(NRC_DBG_HIF, "failed to claim sdio irq\n");
+		sdio_release_host(func);
+		return ret;
+	}
+
+	sdio_release_host(func);
+
+	priv->skb_tx_last = dev_alloc_skb(512);
+
+#ifdef CONFIG_TRX_BACKOFF
+	atomic_set(&priv->trx_backoff, 0);
+#endif
+
+#ifdef TRANSA_SDIO_DEBUG
+	nrc_init_debugfs_sdio();
+#endif
+
+	return ret;
+}
+
+static void transa_sdio_remove(struct sdio_func *func)
+{
+	sdio_claim_host(func);
+	sdio_release_irq(func);
+	sdio_disable_func(func);
+	sdio_release_host(func);
+	debugfs_remove(transa_sdio_priv->debugfs);
+
+	nrc_dbg(NRC_DBG_HIF, "%s\n", __func__);
+}
+
+static struct nrc_hif_ops transa_sdio_ops = {
+	.name     = sdio_name,
+	.check_fw = sdio_check_fw,
+	.xmit     = sdio_xmit,
+	.write    = sdio_raw_write,
+	.wait_ack = sdio_wait_ack,
+	.start    = sdio_start,
+	.stop     = sdio_noop,
+	.suspend  = sdio_suspend,
+	.resume   = sdio_resume,
+	.close    = sdio_close,
+	.reset    = sdio_reset,
+	.wakeup   = sdio_wakeup,
+	.test     = sdio_test,
+};
+
+
+static struct sdio_driver transa_sdio_driver = {
+	.name     = "transa_sdio",
+	.id_table = transa_sdio_dev,
+	.probe    = transa_sdio_probe,
+	.remove   = transa_sdio_remove,
+};
+
+struct nrc_hif_device *nrc_hif_sdio_init(void)
+{
+	struct nrc_hif_device     *hdev;
+	struct transa_sdio_priv_t *priv;
+
+	hdev = kzalloc(sizeof(*hdev) + sizeof(*priv), GFP_KERNEL);
+	if (!hdev)
+		return NULL;
+
+	priv          = (void *)(hdev + 1);
+	hdev->priv    = priv;
+	hdev->hif_ops = &transa_sdio_ops;
+
+	transa_sdio_priv = priv;
+	transa_sdio_ops.sync_auto = true;
+
+	/* Register sdio driver */
+	if (sdio_register_driver(&transa_sdio_driver)) {
+		nrc_dbg(NRC_DBG_HIF, "failed to register driver %s\n",
+					   transa_sdio_driver.name);
+		goto failed_register_driver;
+	}
+
+	sdio_set_drvdata(priv->func, hdev);
+	return hdev;
+
+failed_register_driver:
+
+	kfree(hdev);
+	transa_sdio_priv = NULL;
+	return NULL;
+}
+
+int nrc_hif_sdio_exit(struct nrc_hif_device *hdev)
+{
+	nrc_dbg(NRC_DBG_HIF, "%s\n", __func__);
+
+	if (!hdev)
+		return 0;
+
+	sdio_unregister_driver(&transa_sdio_driver);
+	kfree(hdev);
+
+	return 0;
+}
+
+
diff --git a/drivers/staging/nrc/nrc-hif-sdio.h b/drivers/staging/nrc/nrc-hif-sdio.h
new file mode 100644
index 000000000000..412d0d67c562
--- /dev/null
+++ b/drivers/staging/nrc/nrc-hif-sdio.h
@@ -0,0 +1,23 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _NRC_HIF_CSPI_H_
+#define _NRC_HIF_CSPI_H_
+
+struct nrc_hif_device *nrc_hif_sdio_init(struct nrc *nw);
+int nrc_hif_sdio_exit(struct nrc_hif_device *hdev);
+
+#endif
diff --git a/drivers/staging/nrc/nrc-hif-ssp.c b/drivers/staging/nrc/nrc-hif-ssp.c
new file mode 100644
index 000000000000..dfe6b3bcb41b
--- /dev/null
+++ b/drivers/staging/nrc/nrc-hif-ssp.c
@@ -0,0 +1,175 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include "nrc-hif.h"
+#include "nrc-hif-ssp.h"
+#include "nrc-debug.h"
+#include "nrc-ssp.h"
+#include "wim.h"
+#include "nrc-mac80211.h"
+
+static void ssp_args_prepare(struct nrc_hif_ssp *priv)
+{
+	memset(priv, 0, sizeof(struct nrc_hif_ssp));
+	priv->name = hifport;
+	priv->data_rate = hifspeed;
+}
+
+static const char *nrc_hif_ssp_name(struct nrc_hif_device *dev)
+{
+	return "SSP";
+}
+
+static int nrc_hif_ssp_start(struct nrc_hif_device *dev)
+{
+	struct nrc_hif_ssp *priv = dev->priv;
+
+	nrc_dbg(NRC_DBG_HIF, "%s()", __func__);
+	priv->dev = dev;
+
+	return nrc_ssp_register(priv);
+}
+
+static int nrc_hif_ssp_stop(struct nrc_hif_device *dev)
+{
+	struct nrc_hif_ssp *priv = dev->priv;
+
+	nrc_dbg(NRC_DBG_HIF, "%s()", __func__);
+	priv->dev = dev;
+
+	nrc_ssp_unregister(priv);
+	return 0;
+}
+
+static int nrc_hif_ssp_write(struct nrc_hif_device *dev, const u8 *data,
+		const u32 len)
+{
+	return -EOPNOTSUPP;
+}
+
+static int nrc_hif_ssp_suspend(struct nrc_hif_device *dev)
+{
+	return -EOPNOTSUPP;
+}
+
+static int nrc_hif_ssp_resume(struct nrc_hif_device *dev)
+{
+	return -EOPNOTSUPP;
+}
+
+static int nrc_hif_ssp_write_begin(struct nrc_hif_device *dev)
+{
+	return -EOPNOTSUPP;
+}
+
+static int nrc_hif_ssp_write_body(struct nrc_hif_device *dev,
+		const u8 *data, const u32 len)
+{
+	return -EOPNOTSUPP;
+}
+
+static int nrc_hif_ssp_write_end(struct nrc_hif_device *dev)
+{
+	return -EOPNOTSUPP;
+}
+
+static int nrc_hif_ssp_wait_ack(struct nrc_hif_device *dev, u8 *data, u32 len)
+{
+	return -EOPNOTSUPP;
+}
+
+static int nrc_hif_ssp_receive_skb(struct nrc_hif_device *dev,
+		struct sk_buff *skb)
+{
+	struct nrc *nw = dev->nw;
+	struct hif *hif = (void *)skb->data;
+
+	if (nw->drv_state < NRC_DRV_START)
+		return -EIO;
+
+	skb_pull(skb, sizeof(struct hif)); /*remove hif header from skb*/
+
+	switch (hif->type) {
+	case HIF_TYPE_FRAME:
+		nrc_mac_rx(nw, skb);
+		break;
+	case HIF_TYPE_WIM:
+		nrc_wim_rx(nw, skb, hif->subtype);
+		break;
+	default:
+		BUG();
+	}
+	return 0;
+}
+
+static int nrc_hif_ssp_xmit(struct nrc_hif_device *dev, struct sk_buff *skb)
+{
+	struct nrc_hif_ssp *hif = (struct nrc_hif_ssp *)dev->priv;
+	struct nrc_ssp *ssp = hif->ssp;
+
+	ssp_enqueue_buffer(ssp, skb);
+
+	return HIF_TX_QUEUED;
+}
+
+static struct nrc_hif_ops nrc_hif_ssp_ops = {
+	.name = nrc_hif_ssp_name,
+	.start = nrc_hif_ssp_start,
+	.stop = nrc_hif_ssp_stop,
+	.write = nrc_hif_ssp_write,
+	.suspend = nrc_hif_ssp_suspend,
+	.resume = nrc_hif_ssp_resume,
+	.write_begin = nrc_hif_ssp_write_begin,
+	.write_body = nrc_hif_ssp_write_body,
+	.write_end = nrc_hif_ssp_write_end,
+	.wait_ack = nrc_hif_ssp_wait_ack,
+	.receive = nrc_hif_ssp_receive_skb,
+	.xmit = nrc_hif_ssp_xmit
+};
+
+struct nrc_hif_device *nrc_hif_ssp_init(void)
+{
+	struct nrc_hif_device *dev = kmalloc(sizeof(*dev), GFP_KERNEL);
+
+	nrc_dbg(NRC_DBG_HIF, "%s()", __func__);
+
+	if (!dev)
+		return NULL;
+
+	dev->priv = kmalloc(sizeof(struct nrc_hif_ssp), GFP_KERNEL);
+	if (!dev->priv) {
+		/*nrc_dbg(NRC_DBG_HIF, "Failed to allocate nrc_hif priv");*/
+		kfree(dev);
+		return NULL;
+	}
+
+	ssp_args_prepare(dev->priv);
+	nrc_hif_ssp_ops.sync_auto = true;
+	dev->hif_ops = &nrc_hif_ssp_ops;
+
+	return dev;
+}
+
+int nrc_hif_ssp_exit(struct nrc_hif_device *dev)
+{
+	nrc_dbg(NRC_DBG_HIF, "%s()", __func__);
+
+	if (!dev)
+		return -EINVAL;
+	kfree(dev);
+
+	return 0;
+}
diff --git a/drivers/staging/nrc/nrc-hif-ssp.h b/drivers/staging/nrc/nrc-hif-ssp.h
new file mode 100644
index 000000000000..cfe8f02c1daf
--- /dev/null
+++ b/drivers/staging/nrc/nrc-hif-ssp.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _NRC_HIF_SSP_H_
+#define _NRC_HIF_SSP_H_
+
+struct nrc_hif_device;
+struct nrc;
+
+struct nrc_hif_ssp {
+	struct nrc_hif_device *dev;
+	const char *name;
+	unsigned int data_rate;
+	struct nrc_ssp *ssp;
+	struct timer_list exp_timer;
+};
+
+struct nrc_hif_device *nrc_hif_ssp_init(void);
+int nrc_hif_ssp_exit(struct nrc_hif_device *dev);
+#endif
diff --git a/drivers/staging/nrc/nrc-hif-uart.c b/drivers/staging/nrc/nrc-hif-uart.c
new file mode 100644
index 000000000000..6e5f2fb49a92
--- /dev/null
+++ b/drivers/staging/nrc/nrc-hif-uart.c
@@ -0,0 +1,543 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include "nrc.h"
+#include "nrc-hif.h"
+#include "nrc-hif-uart.h"
+#include "nrc-debug.h"
+#include "nrc-wim-types.h"
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/tty.h>
+#include <linux/serial.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+
+#ifdef CONFIG_NRC_HIF_UART
+
+static const u8 nrc_uart_soh[4] = {'N', 'R', 'C', '['};
+static const u8 nrc_uart_eot[4] = {']', 'M', 'S', 'G'};
+
+static void uart_start_user_oper(struct nrc_hif_uart *priv)
+{
+#if KERNEL_VERSION(5,0,0) > NRC_TARGET_KERNEL_VERSION
+	priv->fs_snapshot = get_fs();
+	set_fs( get_ds() );
+#elif KERNEL_VERSION(5,10,0) > NRC_TARGET_KERNEL_VERSION
+	priv->fs_snapshot = get_fs();
+	set_fs( KERNEL_DS );
+#else
+	priv->fs_snapshot = force_uaccess_begin();
+#endif
+}
+
+static void uart_stop_user_oper(struct nrc_hif_uart *priv)
+{
+#if KERNEL_VERSION(5,10,0) > NRC_TARGET_KERNEL_VERSION
+	set_fs(priv->fs_snapshot);
+#else
+	force_uaccess_end(priv->fs_snapshot);
+#endif
+}
+
+static long uart_ioctl(struct file *f, unsigned int op, unsigned long param)
+{
+	if (f->f_op->unlocked_ioctl)
+		return f->f_op->unlocked_ioctl(f, op, param);
+
+	/*return -ENOSYS;*/
+	return -EINVAL;
+}
+
+static tcflag_t conv_baud(unsigned int baud)
+{
+	switch (baud) {
+	case 19200:
+		return B19200;
+	case 38400:
+		return B38400;
+	case 57600:
+		return B57600;
+	case 115200:
+		return B115200;
+	case 230400:
+		return B230400;
+	case 460800:
+		return B460800;
+	case 921600:
+		return B921600;
+	default:
+		return B115200;
+	}
+}
+
+
+static int _nrc_hif_uart_read(struct nrc_hif_uart *priv,  u8 *data, u32 len)
+{
+	struct file *f = priv->fp;
+
+	f->f_pos = 0;
+	return f->f_op->read(f, (__force char __user *)data, len, &f->f_pos);
+}
+
+static int _nrc_hif_uart_read_one(struct nrc_hif_uart *priv,  u8 *ch)
+{
+	return _nrc_hif_uart_read(priv, ch, 1);
+}
+
+static void uart_args_prepare(struct nrc_hif_uart *priv)
+{
+	memset(priv, 0, sizeof(struct nrc_hif_uart));
+	priv->name = hifport;
+	priv->device_baud = hifspeed;
+	priv->fp = NULL;
+#ifdef CONFIG_X86
+	priv->fs_snapshot.seg = 0;
+#endif
+}
+
+static int uart_open(struct nrc_hif_uart *priv)
+{
+	struct termios tio;
+	struct serial_struct s;
+
+	uart_start_user_oper(priv);
+
+#ifdef CONFIG_ARM
+	priv->fp = filp_open(priv->name, O_RDWR | O_NOCTTY, 0);
+#else
+	priv->fp = filp_open(priv->name, O_RDWR | O_NOCTTY, 0);
+#endif
+
+	if (IS_ERR(priv->fp)) {
+		long err = PTR_ERR(priv->fp);
+
+		nrc_dbg(NRC_DBG_HIF, "Failed to open %s, err=%d",
+				priv->name, err);
+		priv->fp = NULL;
+		uart_stop_user_oper(priv);
+		return err;
+	}
+
+	/*
+	 * Set fixed baud rate of 115200 for boot mode HIF operation
+	 */
+	uart_ioctl(priv->fp, TCGETS, (unsigned long)&tio);
+	memset(&tio, 0, sizeof(tio));
+
+	tio.c_cflag =  (conv_baud(115200) | CLOCAL | CS8 | CREAD);
+	tio.c_lflag = 0;
+	tio.c_iflag = IGNPAR;
+	tio.c_oflag = 0;
+
+	uart_ioctl(priv->fp, TCSETS, (unsigned long)&tio);
+	uart_ioctl(priv->fp, TIOCGSERIAL, (unsigned long)&s);
+
+	s.flags |= ASYNC_LOW_LATENCY;
+
+	uart_ioctl(priv->fp, TIOCSSERIAL, (unsigned long)&s);
+
+	uart_stop_user_oper(priv);
+
+	return 0;
+}
+
+static int uart_close(struct nrc_hif_uart *priv)
+{
+	uart_start_user_oper(priv);
+
+	if (priv->fp) {
+		filp_close(priv->fp, NULL);
+		priv->fp = NULL;
+	}
+
+	uart_stop_user_oper(priv);
+
+	return 0;
+}
+
+static const char *nrc_hif_uart_name(struct nrc_hif_device *dev)
+{
+	return "UART";
+}
+
+static void nrc_uart_poll(struct nrc_hif_uart *priv)
+{
+	struct poll_wqueues table;
+	ktime_t start, now;
+	struct file *f = priv->fp;
+
+	const int timeout = 1000;
+
+	start = ktime_get();
+	poll_initwait(&table);
+
+	while (1) {
+		long elapsed;
+		int mask;
+
+		mask = f->f_op->poll(f, &table.pt);
+		if (mask & (POLLRDNORM | POLLRDBAND | POLLIN |
+			    POLLHUP | POLLERR)) {
+			break;
+		}
+		now = ktime_get();
+		elapsed = ktime_us_delta(now, start);
+		if (elapsed > timeout)
+			break;
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(((timeout - elapsed) * HZ) / 10000);
+	}
+
+	poll_freewait(&table);
+}
+
+static int nrc_uart_rx_data_done(struct nrc_hif_uart *priv,
+		const u8 *data, const u32 len)
+{
+	static struct nrc_hif_rx_info info;
+
+	struct nrc *nw = priv->dev->nw;
+
+	WARN_ON(!nw);
+
+	memset(&info, 0, sizeof(struct nrc_hif_rx_info));
+
+	info.band = nw->band;
+	info.freq = nw->center_freq;
+
+	return nrc_hif_rx(priv->dev, data, len);
+}
+
+static void nrc_uart_rx_state_init(struct nrc_hif_uart *priv)
+{
+	priv->rx_state = NRC_HIF_RX_SOH;
+	priv->rx_data_pos = 0;
+	priv->rx_data_size = 0;
+}
+
+static int nrc_uart_rx_push(struct nrc_hif_uart *priv, u8 ch)
+{
+	if (priv->dev->suspended) {
+		priv->ack_val = ch;
+		priv->ack_received = true;
+		return 0;
+	}
+
+	priv->rx_data[priv->rx_data_pos++] = ch;
+
+	if (priv->rx_state == NRC_HIF_RX_SOH) {
+		if (priv->rx_data_pos > 4) {
+			nrc_dbg(NRC_DBG_HIF, "the size of SOH exceeds (State:%d rx_data_pos:%d)",
+				priv->rx_state, priv->rx_data_pos);
+			BUG();
+		}
+		if (priv->rx_data[priv->rx_data_pos-1]
+				== nrc_uart_soh[priv->rx_data_pos-1]) {
+			if (priv->rx_data_pos == 4) {
+				priv->rx_state = NRC_HIF_RX_HIF_HDR;
+				priv->rx_data_pos = 0;
+			}
+		} else {
+			nrc_dbg(NRC_DBG_HIF, "Wrong SOH received (State:%d rx_data_pos:%d, 0x%02X)",
+				priv->rx_state, priv->rx_data_pos, ch);
+			nrc_uart_rx_state_init(priv);
+		}
+	} else if (priv->rx_state == NRC_HIF_RX_HIF_HDR) {
+		if (priv->rx_data_pos == sizeof(struct hif_hdr)) {
+			struct hif_hdr *hdr = (struct hif_hdr *)priv->rx_data;
+
+			priv->rx_data_size = hdr->len;
+			priv->rx_state = NRC_HIF_RX_PAYLOAD;
+		}
+	} else if (priv->rx_state == NRC_HIF_RX_PAYLOAD) {
+		WARN_ON(priv->rx_data_pos == 0);
+		WARN_ON(priv->rx_data_pos > (sizeof(struct hif_hdr)
+					+ priv->rx_data_size));
+
+		if (priv->rx_data_pos >= (sizeof(struct hif_hdr)
+					+ priv->rx_data_size))
+			priv->rx_state = NRC_HIF_RX_EOT;
+	} else if (priv->rx_state == NRC_HIF_RX_EOT) {
+		int eot_idx = (priv->rx_data_pos - priv->rx_data_size
+				- sizeof(struct hif_hdr));
+
+		if (priv->rx_data[priv->rx_data_pos-1]
+				== nrc_uart_eot[eot_idx-1]) {
+			if (eot_idx == 4) {
+				nrc_uart_rx_data_done(priv, priv->rx_data,
+						priv->rx_data_pos-4);
+				nrc_uart_rx_state_init(priv);
+			}
+		} else {
+			nrc_dbg(NRC_DBG_HIF, "Wrong EOT received (State:%d rx_data_pos:%d)",
+				priv->rx_state, priv->rx_data_pos);
+			nrc_uart_rx_state_init(priv);
+		}
+	}
+	return 0;
+}
+
+static int nrc_uart_rx_thread(void *arg)
+{
+	u8 ch = 0;
+	struct nrc_hif_uart *priv = (struct nrc_hif_uart *) arg;
+
+	set_current_state(TASK_INTERRUPTIBLE);
+
+	while (!kthread_should_stop()) {
+		uart_start_user_oper(priv);
+
+		nrc_uart_poll(priv);
+
+		while (_nrc_hif_uart_read_one(priv, &ch))
+			nrc_uart_rx_push(priv, ch);
+
+		uart_stop_user_oper(priv);
+
+		if (signal_pending(current))
+			break;
+	}
+
+	while (!kthread_should_stop()) {
+		flush_signals(current);
+		set_current_state(TASK_INTERRUPTIBLE);
+		if (!kthread_should_stop())
+			schedule();
+		set_current_state(TASK_RUNNING);
+	}
+
+	return 0;
+}
+
+static int nrc_hif_uart_start(struct nrc_hif_device *dev)
+{
+	struct nrc_hif_uart *priv = dev->priv;
+
+	nrc_dbg(NRC_DBG_HIF, "%s", __func__);
+	priv->dev = dev;
+
+	if (uart_open(priv) != 0)
+		return -EINVAL;
+
+	if (priv) {
+		priv->thread_rx = kthread_run(nrc_uart_rx_thread, priv,
+				"uart_rx_thread");
+		if (IS_ERR(priv->thread_rx)) {
+			nrc_dbg(NRC_DBG_HIF, "Failed to run rx thread");
+			return -EINVAL;
+		}
+		nrc_dbg(NRC_DBG_HIF, "thread run");
+	}
+
+	return 0;
+}
+
+static int nrc_hif_uart_stop(struct nrc_hif_device *dev)
+{
+	struct nrc_hif_uart *priv = dev->priv;
+
+	if (priv->thread_rx) {
+		kthread_stop(priv->thread_rx);
+		nrc_dbg(NRC_DBG_HIF, "thread stop by force");
+	}
+	return uart_close(priv);
+}
+
+static struct file *get_uart_fp(struct nrc_hif_device *dev)
+{
+	struct nrc_hif_uart *uart = dev->priv;
+
+	return uart->fp;
+}
+
+static int _nrc_hif_uart_write(struct file *f, const u8 *data, const u32 len)
+{
+	if (!f->f_op) {
+		nrc_dbg(NRC_DBG_HIF, "f is not ready");
+		return -EOPNOTSUPP;
+	}
+
+	f->f_pos = 0;
+
+	if (!f->f_op) {
+		nrc_dbg(NRC_DBG_HIF, "f_op is not ready");
+		return -EOPNOTSUPP;
+	}
+
+	return f->f_op->write(f, (__force const char __user *)data,
+			len, &f->f_pos);
+}
+
+#ifndef CONFIG_NRC_HIF_AH_UART
+static int nrc_hif_uart_write(struct nrc_hif_device *dev, const u8 *data,
+		const u32 len)
+{
+	int cnt = 0;
+	struct file *f = get_uart_fp(dev);
+
+	if (len == 0 || data == NULL)
+		return 0;
+
+	uart_start_user_oper(dev->priv);
+
+	cnt += _nrc_hif_uart_write(f, nrc_uart_soh, 4);
+	cnt += _nrc_hif_uart_write(f, data, len);
+	cnt += _nrc_hif_uart_write(f, nrc_uart_eot, 4);
+
+	uart_stop_user_oper(dev->priv);
+
+	if (cnt == len + 8)
+		return 0;
+	return -1;
+}
+#endif
+
+static int nrc_hif_uart_write_data(struct nrc_hif_device *dev, const u8 *data,
+		const u32 len)
+{
+	struct file *f = get_uart_fp(dev);
+	int ret = -1;
+
+	if (f == NULL) {
+		WARN_ON(1);
+		return -1;
+	}
+
+	uart_start_user_oper(dev->priv);
+
+	if (_nrc_hif_uart_write(f, data, len) == len)
+		ret = 0;
+
+	uart_stop_user_oper(dev->priv);
+
+	return ret;
+}
+
+static int nrc_hif_uart_write_begin(struct nrc_hif_device *dev)
+{
+	return nrc_hif_uart_write_data(dev, nrc_uart_soh, 4);
+}
+
+static int nrc_hif_uart_write_end(struct nrc_hif_device *dev)
+{
+	return nrc_hif_uart_write_data(dev, nrc_uart_eot, 4);
+}
+
+static int nrc_hif_uart_write_body(struct nrc_hif_device *dev, const u8 *body,
+		const u32 len)
+{
+	return nrc_hif_uart_write_data(dev, body, len);
+
+}
+static int nrc_hif_uart_suspend(struct nrc_hif_device *dev)
+{
+	return 0;
+}
+
+static int nrc_hif_uart_resume(struct nrc_hif_device *dev)
+{
+	struct termios tio;
+	struct nrc_hif_uart *priv = dev->priv;
+
+	uart_start_user_oper(priv);
+
+	/*
+	 * Set baud rate configured for normal HIF operation
+	 */
+	uart_ioctl(priv->fp, TCGETS, (unsigned long)&tio);
+	memset(&tio, 0, sizeof(tio));
+
+	tio.c_cflag =  (conv_baud(priv->device_baud) | CLOCAL | CS8 | CREAD);
+	tio.c_lflag = 0;
+	tio.c_iflag = IGNPAR;
+	tio.c_oflag = 0;
+
+	uart_ioctl(priv->fp, TCSETS, (unsigned long)&tio);
+
+	uart_stop_user_oper(priv);
+
+	return 0;
+}
+
+static int nrc_hif_uart_wait_ack(struct nrc_hif_device *dev, u8 *data, u32 len)
+{
+	int max = 1000;
+	struct nrc_hif_uart *priv = dev->priv;
+
+	while (!priv->ack_received && --max)
+		udelay(1000);
+	BUG_ON(!max);
+	*data = priv->ack_val;
+	priv->ack_received = false;
+	return 1;
+}
+
+static struct nrc_hif_ops nrc_hif_uart_ops = {
+	.name = nrc_hif_uart_name,
+	.start = nrc_hif_uart_start,
+	.stop = nrc_hif_uart_stop,
+#ifdef CONFIG_NRC_HIF_AH_UART
+	.write = nrc_hif_uart_write_data,
+#else
+	.write = nrc_hif_uart_write,
+#endif
+	.write_begin = nrc_hif_uart_write_begin,
+	.write_body = nrc_hif_uart_write_body,
+	.write_end = nrc_hif_uart_write_end,
+	.suspend = nrc_hif_uart_suspend,
+	.resume = nrc_hif_uart_resume,
+	.wait_ack = nrc_hif_uart_wait_ack
+};
+
+struct nrc_hif_device *nrc_hif_uart_init(void)
+{
+	struct nrc_hif_device *dev;
+
+	nrc_dbg(NRC_DBG_HIF, "%s()", __func__);
+
+	dev = kmalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		/*nrc_dbg(NRC_DBG_HIF, "Failed to allocate nrc_hif_device");*/
+		return NULL;
+	}
+
+	dev->priv = kmalloc(sizeof(struct nrc_hif_uart), GFP_KERNEL);
+
+	if (!dev->priv) {
+		/*nrc_dbg(NRC_DBG_HIF, "Failed to allocate nrc_hif priv");*/
+		kfree(dev);
+		return NULL;
+	}
+
+	uart_args_prepare(dev->priv);
+	dev->hif_ops = &nrc_hif_uart_ops;
+
+	return dev;
+}
+
+int nrc_hif_uart_exit(struct nrc_hif_device *dev)
+{
+	nrc_dbg(NRC_DBG_HIF, "%s()", __func__);
+
+	kfree(dev->priv);
+	dev->priv = NULL;
+	kfree(dev);
+	dev = NULL;
+	return 0;
+}
+
+#endif
diff --git a/drivers/staging/nrc/nrc-hif-uart.h b/drivers/staging/nrc/nrc-hif-uart.h
new file mode 100644
index 000000000000..04fdcfe1e115
--- /dev/null
+++ b/drivers/staging/nrc/nrc-hif-uart.h
@@ -0,0 +1,67 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _NRC_HIF_UART_H_
+#define _NRC_HIF_UART_H_
+
+#ifdef CONFIG_NRC_HIF_UART
+#include <asm/uaccess.h>
+#include <linux/kthread.h>
+
+struct file;
+struct nrc_hif_device;
+
+enum nrc_hif_rx_state {
+	NRC_HIF_RX_SOH,
+	NRC_HIF_RX_IDLE = NRC_HIF_RX_SOH,
+	NRC_HIF_RX_HIF_HDR,
+	NRC_HIF_RX_PAYLOAD,
+	NRC_HIF_RX_EOT,
+};
+
+struct nrc_hif_uart {
+	struct nrc_hif_device *dev;
+	const char *name;
+	unsigned int device_baud;
+	struct file *fp;
+	mm_segment_t fs_snapshot;
+	struct task_struct *thread_rx;
+	enum nrc_hif_rx_state rx_state;
+	u8 rx_data[IEEE80211_MAX_DATA_LEN];
+	u32 rx_data_pos;
+	u32 rx_data_size;
+	u8 ack_val;
+	bool ack_received;
+};
+
+struct nrc_hif_device *nrc_hif_uart_init(void);
+int nrc_hif_uart_exit(struct nrc_hif_device *dev);
+
+#else
+
+static inline struct nrc_hif_device *nrc_hif_uart_init(void)
+{
+	return NULL;
+}
+
+static inline int nrc_hif_uart_exit(struct nrc_hif_device *dev)
+{
+	return 0;
+}
+
+#endif
+
+#endif
diff --git a/drivers/staging/nrc/nrc-hif.h b/drivers/staging/nrc/nrc-hif.h
new file mode 100755
index 000000000000..49be95f6212f
--- /dev/null
+++ b/drivers/staging/nrc/nrc-hif.h
@@ -0,0 +1,426 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _NRC_HIF_H_
+#define _NRC_HIF_H_
+
+#include <net/mac80211.h>
+#include "nrc.h"
+#include "nrc-debug.h"
+
+/*#define CONFIG_NRC_HIF_DEBUG_READ*/
+/*#define CONFIG_NRC_HIF_DEBUG_WRITE*/
+
+/* struct nrc_hif_ops - callbacks from transport layer to the host layer
+ *
+ * This structure mainly used to handle host interface contains various
+ * callbacks that the host interface may handle or, in some cases,
+ * must handle, for example to start, stop, transmit data to host.
+ *
+ * name: Handle calls for identifying the name of host interface
+ *  this function is called when host interface is initialized.
+ *
+ * start: Handle that the transport layer on mac80211 host driver calls
+ *  for host device initialization.
+ *  This function is called after wpa_supplcant or hostapd is attached.
+ *
+ * stop: Handle that the transport layer on mac80211 host driver calls
+ *  for host device cleanup.
+ *  This function is called after wpa_supplcant or hostapd is detached.
+ *
+ * suspend: Handle that the transport layer on mac80211 host driver calls
+ *  for host device sleep.
+ *  This function is called when device sleeps
+ *
+ * resume: Handle that the transport layer on mac80211 host driver calls
+ *  for host device wakeup.
+ *  This function is called when device wake-up
+ *
+ * write: Handle that the transport layer on mac80211 host driver calls
+ *  for each transmitted frame.
+ *
+ * write_multi: Handle that the transport layer on mac80211 host driver calls
+ *  for each transmitted frame separated with multiple parts head, body
+ *  and tail.
+ *
+ * need_maskrom_war: apply workaround when NRC7291 maskrom work.
+ *
+ * sync_auto: Determine which layer controls sync.
+ *  true: controlled by driver layer
+ *  false: controlled by hif layer
+ */
+struct nrc_hif_ops {
+	const char *(*name)(struct nrc_hif_device *dev);
+	bool (*check_fw)(struct nrc_hif_device *dev);
+	int (*start)(struct nrc_hif_device *dev);
+	int (*stop)(struct nrc_hif_device *dev);
+	int (*write)(struct nrc_hif_device *dev, const u8 *data, const u32 len);
+	int (*suspend)(struct nrc_hif_device *dev);
+	int (*resume)(struct nrc_hif_device *dev);
+	int (*write_begin)(struct nrc_hif_device *dev);
+	int (*write_body)(struct nrc_hif_device *dev, const u8 *data,
+			const u32 len);
+	int (*write_end)(struct nrc_hif_device *dev);
+	int (*wait_ack)(struct nrc_hif_device *dev, u8 *data, u32 len);
+	/* New APIs */
+	int (*xmit)(struct nrc_hif_device *dev, struct sk_buff *skb);
+	int (*wait_for_xmit)(struct nrc_hif_device *dev, struct sk_buff *skb);
+	int (*receive)(struct nrc_hif_device *dev, struct sk_buff *skb);
+	void (*close)(struct nrc_hif_device *dev);
+	void (*reset)(struct nrc_hif_device *dev);
+	void (*wakeup)(struct nrc_hif_device *dev);
+	int (*test)(struct nrc_hif_device *dev);
+	void (*config)(struct nrc_hif_device *dev);
+	void (*sync_lock)(struct nrc_hif_device *dev);
+	void (*sync_unlock)(struct nrc_hif_device *dev);
+	void (*disable_irq)(struct nrc_hif_device *dev);
+	void (*enable_irq)(struct nrc_hif_device *dev);
+	int (*status_irq)(struct nrc_hif_device *dev);
+	void (*clear_irq)(struct nrc_hif_device *dev);
+	void (*update)(struct nrc_hif_device *dev);
+	void (*set_gpio)(int v);
+	bool need_maskrom_war;
+	bool sync_auto;
+	bool (*support_fastboot)(struct nrc_hif_device *dev);
+	int (*suspend_rx_thread)(struct nrc_hif_device *dev);
+	int (*resume_rx_thread)(struct nrc_hif_device *dev);
+	int (*check_target)(struct nrc_hif_device *dev, u8 reg);
+#if defined(CONFIG_CHECK_READY)
+	bool (*check_ready)(struct nrc_hif_device *dev);
+#endif /* defined(CONFIG_CHECK_READY) */
+};
+
+/* struct nrc_hif_device - host interface driver
+ *
+ * @nr: pointer to struct nr that was allocated on host driver initialization
+ *
+ * @hif_ops: callbacks
+ *
+ * @started: flag to indicates whether host interface is started
+ *
+ * @suspended: flag to indicates whether host interface is suspeded
+ *
+ * @priv: pointer to private area for each host interface
+ */
+struct nrc_hif_device {
+	struct nrc *nw;
+	struct nrc_hif_ops *hif_ops;
+	bool started;
+	bool suspended;
+	void *priv;
+
+	struct sk_buff_head queue[2]; /* 0: frame, 1: wim */
+	struct work_struct work;
+	struct work_struct ps_work;
+};
+
+/* struct nrc_hif_rx_info - additional information on rx
+ *
+ * @offset: offset
+ *
+ * @need_free: nrc_hif is responsible for mem-free
+ *
+ * @in_interrupt: called in IRQ context
+ *
+ */
+struct nrc_hif_rx_info {
+	int offset;
+	bool need_free;
+	bool in_interrupt;
+	u8 band;
+	u16 freq;
+};
+
+/* nrc_hif_init - initialize host interface
+ *
+ * You must call this function before any other host functions.
+ *
+ * @nrc: pointer to struct nrc
+ *
+ * Return: pointer to struct nrc_hif_device PTR_ERR otherwise.
+ */
+struct nrc_hif_device *nrc_hif_init(struct nrc *nr);
+
+
+/* nrc_hif_rx - receive data from host interface
+ *
+ * This function should be called when the host interface
+ * receives data from Target
+ *
+ * @dev: pointer to host interface descriptor
+ * @info: additional rx information
+ * @data: the received data
+ * @len: the length of the received data
+ */
+/*
+ * int nrc_hif_rx(struct nrc_hif_device *dev, struct nrc_hif_rx_info *info,
+ * const u8 *data, const u32 len);
+ */
+int nrc_hif_rx(struct nrc_hif_device *dev, const u8 *data, const u32 len);
+
+/* nrc_hif_exit - free hostinterface descriptor
+ *
+ * @dev: pointer to host interface desciptor
+ * Return: 0 on success. An error code other wires
+ */
+int nrc_hif_exit(struct nrc_hif_device *dev);
+
+static inline const char *nrc_hif_name(struct nrc_hif_device *dev)
+{
+	nrc_dbg(NRC_DBG_HIF, "name()");
+	BUG_ON(!dev->hif_ops->name);
+	return dev->hif_ops->name(dev);
+}
+
+static inline bool nrc_hif_check_fw(struct nrc_hif_device *dev)
+{
+	if (dev->hif_ops->check_fw)
+		return dev->hif_ops->check_fw(dev);
+	else
+		return false;
+}
+
+#if defined(CONFIG_CHECK_READY)
+static inline bool nrc_hif_check_ready(struct nrc_hif_device *dev)
+{
+	if (dev->hif_ops->check_ready)
+		return dev->hif_ops->check_ready(dev);
+	else
+		return true;
+}
+#endif /* defined(CONFIG_CHECK_READY) */
+
+static inline int nrc_hif_start(struct nrc_hif_device *dev)
+{
+	nrc_dbg(NRC_DBG_HIF, "start()");
+	BUG_ON(!dev->hif_ops->start);
+	dev->started = true;
+	return dev->hif_ops->start(dev);
+}
+
+static inline int nrc_hif_stop(struct nrc_hif_device *dev)
+{
+	nrc_dbg(NRC_DBG_HIF, "stop()");
+	BUG_ON(!dev->hif_ops->stop);
+
+	if (!dev->started)
+		return 0;
+
+	dev->hif_ops->stop(dev);
+	dev->started = false;
+	return true;
+}
+
+static inline int nrc_hif_write(struct nrc_hif_device *dev, u8 *data, u32 len)
+{
+	/*nrc_dbg(NRC_DBG_HIF, "write(len=%d)", len);*/
+	BUG_ON(!dev->hif_ops->write);
+	return dev->hif_ops->write(dev, data, len);
+}
+
+static inline int nrc_hif_write_begin(struct nrc_hif_device *dev)
+{
+	nrc_dbg(NRC_DBG_HIF, "write_begin()");
+	if (dev->hif_ops->write_begin)
+		return dev->hif_ops->write_begin(dev);
+	else
+		return -1;
+}
+
+static inline int nrc_hif_write_body(struct nrc_hif_device *dev, u8 *body,
+		u32 len)
+{
+	nrc_dbg(NRC_DBG_HIF, "write_body(body_len=%d)", len);
+	if (dev->hif_ops->write_body)
+		return dev->hif_ops->write_body(dev, body, len);
+	else
+		return -1;
+}
+
+static inline int nrc_hif_write_end(struct nrc_hif_device *dev)
+{
+	nrc_dbg(NRC_DBG_HIF, "write_end()");
+	if (dev->hif_ops->write_end)
+		return dev->hif_ops->write_end(dev);
+	else
+		return -1;
+}
+
+static inline int nrc_hif_suspend(struct nrc_hif_device *dev)
+{
+	nrc_dbg(NRC_DBG_HIF, "suspend()");
+	if (dev->suspended)
+		return 0;
+
+	dev->suspended = true;
+
+	if (dev->hif_ops->suspend)
+		return dev->hif_ops->suspend(dev);
+
+	return 0;
+}
+
+static inline int nrc_hif_resume(struct nrc_hif_device *dev)
+{
+	dev->suspended = false;
+	if (dev->hif_ops->resume)
+		dev->hif_ops->resume(dev);
+
+	return 0;
+}
+
+static inline int nrc_hif_wait_ack(struct nrc_hif_device *dev,
+		u8 *data, u32 len)
+{
+	BUG_ON(!dev->hif_ops->wait_ack);
+	return dev->hif_ops->wait_ack(dev, data, len);
+}
+
+static inline bool nrc_hif_check_maskrom_war(struct nrc_hif_device *dev)
+{
+	return dev->hif_ops->need_maskrom_war;
+}
+
+static inline void nrc_hif_disable_irq(struct nrc_hif_device *dev)
+{
+	if (dev->hif_ops->disable_irq)
+		dev->hif_ops->disable_irq(dev);
+}
+
+static inline int nrc_hif_xmit(struct nrc_hif_device *dev, struct sk_buff *skb)
+{
+	if (dev->hif_ops->xmit)
+		return dev->hif_ops->xmit(dev, skb);
+	return -1;
+}
+
+static inline void nrc_hif_set_gpio(struct nrc_hif_device *dev, int hi_lo)
+{
+	if (dev->hif_ops->set_gpio)
+		dev->hif_ops->set_gpio(hi_lo);
+}
+
+static inline void nrc_hif_update(struct nrc_hif_device *dev)
+{
+	if (dev->hif_ops->update)
+		dev->hif_ops->update(dev);
+}
+
+static inline void nrc_hif_set_enable_irq(struct nrc_hif_device *dev)
+{
+	if (dev->hif_ops->enable_irq)
+		dev->hif_ops->enable_irq(dev);
+}
+
+static inline int  nrc_hif_wait_for_xmit(struct nrc_hif_device *dev,
+					struct sk_buff *skb)
+{
+	if (dev->hif_ops->wait_for_xmit)
+		return dev->hif_ops->wait_for_xmit(dev, skb);
+	return -1;
+}
+
+static inline bool nrc_hif_support_fastboot(struct nrc_hif_device *dev)
+{
+	if (dev->hif_ops->support_fastboot)
+		return dev->hif_ops->support_fastboot(dev);
+
+	return false;
+}
+
+static inline void nrc_hif_config(struct nrc_hif_device *dev)
+{
+	if (dev->hif_ops->config)
+		dev->hif_ops->config(dev);
+}
+
+static inline int nrc_hif_suspend_rx_thread(struct nrc_hif_device *dev)
+{
+	if (dev->hif_ops->suspend_rx_thread)
+		return dev->hif_ops->suspend_rx_thread(dev);
+
+	return 0;
+}
+
+static inline int nrc_hif_resume_rx_thread(struct nrc_hif_device *dev)
+{
+	if (dev->hif_ops->resume_rx_thread)
+		return dev->hif_ops->resume_rx_thread(dev);
+
+	return 0;
+}
+
+static inline int nrc_hif_check_target(struct nrc_hif_device *dev, u8 reg)
+{
+	if (dev->hif_ops->check_target)
+		return dev->hif_ops->check_target(dev, reg);
+
+	return -1;
+}
+
+struct hif {
+	u8 type;
+	u8 subtype;
+	u8 flags;
+	s8 vifindex;
+	u16 len;
+	u16 tlv_len;
+	u8 payload[0];
+} __packed;
+
+#define SYNC_LOCK(x) do {\
+	if (!x->hif_ops->sync_auto && x->hif_ops->sync_lock)\
+		x->hif_ops->sync_lock(x); } while (0)
+#define SYNC_UNLOCK(x) do {;\
+	if (!x->hif_ops->sync_auto && x->hif_ops->sync_unlock)\
+		x->hif_ops->sync_unlock(x); } while (0)
+
+#define HIF_TX_COMPLETE 0
+#define HIF_TX_QUEUED   1
+#define HIF_TX_FAILED   2
+#define HIF_TX_PASSOVER 3
+
+int nrc_xmit_wim_request(struct nrc *nw, struct sk_buff *skb);
+/*
+ * nrc_xmit_wim_request_wait: - Transmit WIM REQUEST message and wait
+ * until WIM RESPONSE message received or timeout reached.
+ *
+ * Return: WIM RESPONSE message, null if timeout reached.
+ */
+
+int nrc_xmit_wim_powersave(struct nrc *nw, struct sk_buff *skb_src, uint16_t ps_enable, uint64_t duration);
+struct sk_buff *nrc_xmit_wim_request_wait(struct nrc *nw,
+		struct sk_buff *skb, int timeout);
+int nrc_xmit_wim_response(struct nrc *nw, struct sk_buff *skb);
+int nrc_xmit_wim_simple_request(struct nrc *nw, int cmd);
+int nrc_xmit_frame(struct nrc *nw, s8 vif_index, u16 aid, struct sk_buff *skb);
+int nrc_xmit_injected_frame(struct nrc *nw,
+		   struct ieee80211_vif *vif,
+		   struct ieee80211_sta *sta,
+		   struct sk_buff *skb);
+void nrc_hif_free_skb(struct nrc *nw, struct sk_buff *skb);
+void nrc_hif_debug_send(struct nrc *nw, struct sk_buff *skb);
+int nrc_hif_debug_rx(void);
+int nrc_hif_close(struct nrc_hif_device *dev);
+int nrc_hif_wakeup_device(struct nrc_hif_device *dev);
+int nrc_hif_reset_device(struct nrc_hif_device *dev);
+int nrc_hif_test_status(struct nrc_hif_device *dev);
+void nrc_hif_down(struct nrc *nw);
+void nrc_hif_up(struct nrc *nw);
+void nrc_hif_sync_lock(struct nrc_hif_device *dev);
+void nrc_hif_sync_unlock(struct nrc_hif_device *dev);
+void nrc_hif_flush_wq(struct nrc_hif_device *dev);
+#endif
diff --git a/drivers/staging/nrc/nrc-init.c b/drivers/staging/nrc/nrc-init.c
new file mode 100644
index 000000000000..947395a3ce79
--- /dev/null
+++ b/drivers/staging/nrc/nrc-init.c
@@ -0,0 +1,722 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+#include "nrc.h"
+#include "nrc-hif.h"
+#include "nrc-debug.h"
+#include "nrc-mac80211.h"
+#include "nrc-fw.h"
+#include "nrc-netlink.h"
+#include "nrc-stats.h"
+#include "wim.h"
+#include "nrc-recovery.h"
+#include "nrc-vendor.h"
+#if defined(CONFIG_SUPPORT_BD)
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include "nrc-bd.h"
+#endif /* defined(CONFIG_SUPPORT_BD) */
+
+char *fw_name;
+module_param(fw_name, charp, 0444);
+MODULE_PARM_DESC(fw_name, "Firmware file name");
+
+#if defined(CONFIG_SUPPORT_BD)
+char *bd_name ="nrc7292_bd.dat";
+module_param(bd_name, charp, 0600);
+MODULE_PARM_DESC(bd_name, "Board Data file name");
+#endif /* defined(CONFIG_SUPPORT_BD) */
+
+/**
+ * default port name
+ */
+#if defined(CONFIG_ARM)
+#if defined(CONFIG_NRC_HIF_UART)
+char *hifport = "/dev/ttyAMA0";
+#else
+char *hifport = "/dev/ttyUSB0";
+#endif
+#else
+char *hifport = "/dev/ttyUSB0";
+#endif
+module_param(hifport, charp, 0600);
+MODULE_PARM_DESC(hifport, "HIF port device name");
+
+/**
+ * default port speed
+ */
+#if defined(CONFIG_NRC_HIF_CSPI)
+int hifspeed = (20*1000*1000);
+#elif defined(CONFIG_NRC_HIF_SSP)
+int hifspeed = (1300*1000);
+#elif defined(CONFIG_NRC_HIF_UART)
+int hifspeed = 115200;
+#else
+int hifspeed = 115200;
+#endif
+module_param(hifspeed, int, 0600);
+MODULE_PARM_DESC(hifspeed, "HIF port speed");
+
+int spi_bus_num;
+module_param(spi_bus_num, int, 0600);
+MODULE_PARM_DESC(spi_bus_num, "SPI controller bus number");
+
+int spi_cs_num;
+module_param(spi_cs_num, int, 0600);
+MODULE_PARM_DESC(spi_cs_num, "SPI chip select number");
+
+int spi_gpio_irq = 5;
+module_param(spi_gpio_irq, int, 0600);
+MODULE_PARM_DESC(spi_gpio_irq, "SPI gpio irq");
+
+int spi_polling_interval = 0;
+module_param(spi_polling_interval, int, 0600);
+MODULE_PARM_DESC(spi_polling_interval, "SPI polling interval (msec)");
+
+int spi_gdma_irq = 6;
+module_param(spi_gdma_irq, int, 0600);
+MODULE_PARM_DESC(spi_gdma_irq, "SPI gdma irq");
+
+bool loopback;
+module_param(loopback, bool, 0600);
+MODULE_PARM_DESC(loopback, "HIF loopback");
+
+int lb_count = 1;
+module_param(lb_count, int, 0600);
+MODULE_PARM_DESC(lb_count, "HIF loopback Buffer count");
+
+int disable_cqm = 0;
+module_param(disable_cqm, int, 0600);
+MODULE_PARM_DESC(disable_cqm, "Disable CQM (0: enable, 1: disable)");
+
+int listen_interval = 100;
+module_param(listen_interval, int, 0600);
+MODULE_PARM_DESC(listen_interval, "Listen Interval");
+
+/**
+ * bss_max_idle (in unit of 1000TUs(1024ms)
+ */
+int bss_max_idle;
+module_param(bss_max_idle, int, 0600);
+MODULE_PARM_DESC(bss_max_idle, "BSS Max Idle");
+
+/**
+ * bss_max_idle_usf_format
+ */
+bool bss_max_idle_usf_format=true;
+module_param(bss_max_idle_usf_format, bool, 0600);
+MODULE_PARM_DESC(bss_max_idle_usf_format, "BSS Max Idle specified in units of usf");
+
+/**
+ * enable/disable the s1g short beacon
+ */
+bool enable_short_bi = 1;
+module_param(enable_short_bi, bool, 0600);
+MODULE_PARM_DESC(enable_short_bi, "Enable Short Beacon Interval");
+
+/**
+ * enable/disable the legacy ack mode
+ */
+bool enable_legacy_ack = false;
+module_param(enable_legacy_ack, bool, 0600);
+MODULE_PARM_DESC(enable_legacy_ack, "Enable Legacy ACK mode");
+
+bool enable_monitor;
+module_param(enable_monitor, bool, 0600);
+MODULE_PARM_DESC(enable_monitor, "Enable Monitor");
+
+/**
+ * milisecond unit
+ * to resolve QoS null frame variable-interval issue
+ */
+int bss_max_idle_offset;
+module_param(bss_max_idle_offset, int, 0600);
+MODULE_PARM_DESC(bss_max_idle_offset, "BSS Max Idle Offset");
+
+/**
+ * override  mac-address on nrc driver, follow below format
+ * xx:xx:xx:xx:xx:xx
+ */
+static char *macaddr = ":";
+module_param(macaddr, charp, 0);
+MODULE_PARM_DESC(macaddr, "MAC Address");
+
+/**
+ * enable/disable the power save mode by default
+ */
+int power_save = NRC_PS_NONE;;
+module_param(power_save, int, 0600);
+MODULE_PARM_DESC(power_save, "power save");
+
+/**
+ * deepsleep duration of non-TIM mode power save
+ */
+int sleep_duration[2] = {0,};
+module_param_array(sleep_duration, int, NULL, 0600);
+MODULE_PARM_DESC(sleep_duration, "deepsleep duration of non-TIM mode power save");
+
+/**
+ * wlantest mode
+ */
+bool wlantest = false;
+module_param(wlantest, bool, 0600);
+MODULE_PARM_DESC(wlantest, "wlantest");
+
+/**
+ * Set NDP Probe Request mode
+ */
+bool ndp_preq = false;
+module_param(ndp_preq, bool, 0600);
+MODULE_PARM_DESC(ndp_preq, "Enable NDP Probe Request");
+
+/**
+ * Set 1M NDP ACK
+ */
+bool ndp_ack_1m = false;
+module_param(ndp_ack_1m, bool, 0600);
+MODULE_PARM_DESC(ndp_ack_1m, "Enable 1M NDP ACK");
+
+/**
+ * Enable HSPI init
+ */
+bool enable_hspi_init = false;
+module_param(enable_hspi_init, bool, S_IRUSR | S_IWUSR);
+MODULE_PARM_DESC(enable_hspi_init, "Enable HSPI Initialization");
+
+/**
+ * Enable handling null func (ps-poll) on mac80211
+ */
+bool nullfunc_enable = false;
+module_param(nullfunc_enable, bool, S_IRUSR | S_IWUSR);
+MODULE_PARM_DESC(nullfunc_enable, "Enable null func on mac80211");
+
+/**
+ * Set up automatic TX BA session on connection and QoS data Tx
+ */
+bool auto_ba = false;
+module_param(auto_ba, bool, 0600);
+MODULE_PARM_DESC(auto_ba, "Enable auto ba session setup on connection / QoS data Tx");
+
+/**
+ * Use SW Encryption instead of HW Encryption
+ */
+bool sw_enc = false;
+module_param(sw_enc, bool, S_IRUSR | S_IWUSR);
+MODULE_PARM_DESC(sw_enc, "Use SW Encryption instead of HW Encryption");
+
+/**
+ * Set Singal Monitor  mode
+ */
+bool signal_monitor = false;
+module_param(signal_monitor, bool, 0600);
+MODULE_PARM_DESC(signal_monitor, "Enable SIGNAL(RSSI/SNR) Monitor");
+
+/**
+ * Set configuration of KR USN
+ */
+bool enable_usn = false;
+module_param(enable_usn, bool, 0600);
+MODULE_PARM_DESC(enable_usn, "Use configuration of KR USN (Same ac between data and beacon)");
+
+/**
+ * Debug Level All
+ */
+bool debug_level_all = false;
+module_param(debug_level_all, bool, 0600);
+MODULE_PARM_DESC(debug_level_all, "Driver debug level all");
+
+/**
+ * credit number for AC_BE
+ */
+int credit_ac_be = 40; //default 40
+module_param(credit_ac_be, int, 0600);
+MODULE_PARM_DESC(credit_ac_be, "credit number for AC_BE");
+
+/**
+ * discard TX deauth frame for Mult-STA test
+ */
+bool discard_deauth = false;
+module_param(discard_deauth , bool, 0600);
+MODULE_PARM_DESC(discard_deauth , "(Test only) discard TX deauth for Multi-STA test");
+
+/**
+ * Use bitmap encoding for block ack
+ */
+bool bitmap_encoding = true;
+module_param(bitmap_encoding , bool, 0600);
+MODULE_PARM_DESC(bitmap_encoding , "(NRC7292 only) Use bitmap encoding for block ack");
+
+/**
+ * Apply scrambler reversely
+ */
+bool reverse_scrambler = true;
+module_param(reverse_scrambler , bool, 0600);
+MODULE_PARM_DESC(reverse_scrambler , "(NRC7292 only) Apply scrambler reversely");
+
+/**
+ * Maximum beacon loss count
+ */
+int beacon_loss_count = 7;
+module_param(beacon_loss_count, int, 0600);
+MODULE_PARM_DESC(beacon_loss_count, "Number of beacon intervals before we decide beacon was lost");
+
+static bool has_macaddr_param(uint8_t *dev_mac)
+{
+	int res;
+
+	if (macaddr[0] == ':')
+		return false;
+
+	res = sscanf(macaddr, "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx",
+				&dev_mac[0], &dev_mac[1], &dev_mac[2],
+				&dev_mac[3], &dev_mac[4], &dev_mac[5]);
+
+	return (res == 6);
+}
+
+
+static int s1g_unscaled_interval_max = 0x3fff;
+static int convert_usf(int interval)
+{
+	int ui, usf = 0, interval_usf;
+
+	if (interval <= s1g_unscaled_interval_max) {
+		ui = interval;
+		usf = 0;
+	} else if (interval / 10 <= s1g_unscaled_interval_max) {
+		ui= interval / 10;
+		usf = 1;
+	} else if (interval / 1000 <= s1g_unscaled_interval_max) {
+		ui = interval / 1000;
+		usf = 2;
+	} else if (interval / 10000 <= s1g_unscaled_interval_max) {
+		ui = interval / 10000;
+		usf = 3;
+	} else {
+		ui = 0;
+		usf = 0;
+	}
+
+	interval_usf = (usf << 14) + ui;
+
+	return interval_usf;
+}
+
+/****************************************************************************
+ * FunctionName : nrc_set_macaddr_from_fw
+ * Description : This function set MAC Addresses from Serial Flash.
+ *	Case1: macaddr0, macaddr1 are both written in Serial Flash
+ *	VIF0 = macaddr0 / VIF1 = macaddr1
+ *
+ *	Case2: only macaddr0 is written in Serial Flash
+ *	VIF0 = macaddr0 / VIF1 = macaddr0 with private bit
+ *
+ *	Case3: only macaddr1 is written in Serial Flash
+ *	VIF0 = macaddr1 with private bit / VIF1 = macaddr1
+ *
+ *	Case4: macaddr0,macaddr1 are both not written in Serial Flash
+ *	VIF0/VIF1 = generated macaddr by Host(RP)
+ *
+ * Returns : NONE
+ *****************************************************************************/
+static void nrc_set_macaddr_from_fw(struct nrc *nw, struct wim_ready *ready)
+{
+	int i;
+
+	for (i = 0; i < NR_NRC_VIF; i++)
+		nw->has_macaddr[i] = true;
+
+	if (ready->v.has_macaddr[0] && ready->v.has_macaddr[1]) {
+		for (i = 0; i < NR_NRC_VIF; i++) {
+			memcpy(&nw->mac_addr[i].addr[0],
+				&ready->v.macaddr[i][0], ETH_ALEN);
+		}
+	} else if (ready->v.has_macaddr[0] && !ready->v.has_macaddr[1]) {
+		memcpy(&nw->mac_addr[0].addr[0],
+			&ready->v.macaddr[0][0], ETH_ALEN);
+		if (!(nw->mac_addr[0].addr[0]&0x2)) {
+			memcpy(&nw->mac_addr[1].addr[0],
+				&ready->v.macaddr[0][0], ETH_ALEN);
+			nw->mac_addr[1].addr[0] |= 0x2;
+		} else {
+			nw->has_macaddr[1] = false;
+		}
+	} else if (!ready->v.has_macaddr[0] && ready->v.has_macaddr[1]) {
+		memcpy(&nw->mac_addr[1].addr[0],
+			&ready->v.macaddr[1][0], ETH_ALEN);
+		if (!(nw->mac_addr[1].addr[0]&0x2)) {
+			memcpy(&nw->mac_addr[0].addr[0],
+				&ready->v.macaddr[1][0], ETH_ALEN);
+			nw->mac_addr[0].addr[0] |= 0x2;
+		} else {
+			nw->has_macaddr[0] = false;
+		}
+	} else {
+		for (i = 0; i < NR_NRC_VIF; i++)
+			nw->has_macaddr[i] = false;
+	}
+}
+
+static void nrc_on_fw_ready(struct sk_buff *skb, struct nrc *nw)
+{
+	struct ieee80211_hw *hw = nw->hw;
+	struct wim_ready *ready;
+	struct wim *wim = (struct wim *)skb->data;
+	int i;
+
+	nrc_dbg(NRC_DBG_HIF, "system ready");
+	ready = (struct wim_ready *) (wim + 1);
+	nrc_dbg(NRC_DBG_HIF, "ready");
+	nrc_dbg(NRC_DBG_HIF, "  -- type: %d", ready->h.type);
+	nrc_dbg(NRC_DBG_HIF, "  -- length: %d", ready->h.len);
+	nrc_dbg(NRC_DBG_HIF, "  -- version: 0x%08X",
+			ready->v.version);
+	nrc_dbg(NRC_DBG_HIF, "  -- tx_head_size: %d",
+			ready->v.tx_head_size);
+	nrc_dbg(NRC_DBG_HIF, "  -- rx_head_size: %d",
+			ready->v.rx_head_size);
+	nrc_dbg(NRC_DBG_HIF, "  -- payload_align: %d",
+			ready->v.payload_align);
+	nw->fwinfo.ready = NRC_FW_ACTIVE;
+	nw->fwinfo.version = ready->v.version;
+	nw->fwinfo.rx_head_size = ready->v.rx_head_size;
+	nw->fwinfo.tx_head_size = ready->v.tx_head_size;
+	nw->fwinfo.payload_align = ready->v.payload_align;
+	nw->fwinfo.buffer_size = ready->v.buffer_size;
+	nrc_dbg(NRC_DBG_HIF, "  -- hw_version: %d",
+			ready->v.hw_version);
+	nw->fwinfo.hw_version = ready->v.hw_version;
+	nrc_dbg(NRC_DBG_HIF, "  -- cap_mask: 0x%x",
+			ready->v.cap.cap);
+	nrc_dbg(NRC_DBG_HIF, "  -- cap_li: %d, %d",
+			ready->v.cap.listen_interval, listen_interval);
+	nrc_dbg(NRC_DBG_HIF, "  -- cap_idle: %d, %d",
+			ready->v.cap.bss_max_idle, bss_max_idle);
+
+	nw->cap.cap_mask = ready->v.cap.cap;
+	nw->cap.listen_interval = ready->v.cap.listen_interval;
+	nw->cap.bss_max_idle = ready->v.cap.bss_max_idle;
+	nw->cap.max_vif = ready->v.cap.max_vif;
+
+	if (has_macaddr_param(nw->mac_addr[0].addr)) {
+		nw->has_macaddr[0] = true;
+		nw->has_macaddr[1] = true;
+		memcpy(nw->mac_addr[1].addr, nw->mac_addr[0].addr, ETH_ALEN);
+		nw->mac_addr[1].addr[1]++;
+		nw->mac_addr[1].addr[5]++;
+	} else {
+		nrc_set_macaddr_from_fw(nw, ready);
+	}
+
+	for (i = 0; i < NR_NRC_VIF; i++) {
+		if (nw->has_macaddr[i])
+			nrc_dbg(NRC_DBG_HIF, "  -- mac_addr[%d]: %pM",
+					i, nw->mac_addr[i].addr);
+	}
+
+	for (i = 0; i < nw->cap.max_vif; i++) {
+		nw->cap.vif_caps[i].cap_mask = ready->v.cap.vif_caps[i].cap;
+		nrc_dbg(NRC_DBG_HIF, "  -- cap_mask[%d]: 0x%x", i,
+			ready->v.cap.vif_caps[i].cap);
+	}
+	/* Override with insmod parameters */
+	if (listen_interval) {
+		hw->max_listen_interval = listen_interval;
+		nw->cap.listen_interval = listen_interval;
+	}
+
+	if (nrc_mac_is_s1g(hw->priv) && bss_max_idle_usf_format) {
+		/* bss_max_idle: in unit of 1000 TUs (1024ms = 1.024 seconds) */
+		if (bss_max_idle > 16383 * 10000 || bss_max_idle <= 0) {
+			nw->cap.bss_max_idle = 0;
+		} else {
+			/* Convert in USF Format (Value (14bit) * USF(2bit)) and save it */
+			nw->cap.bss_max_idle = convert_usf(bss_max_idle);
+		}
+	} else {
+		if (bss_max_idle > 65535 || bss_max_idle <= 0) {
+			nw->cap.bss_max_idle = 0;
+		} else {
+			nw->cap.bss_max_idle = bss_max_idle;
+		}
+	}
+
+	dev_kfree_skb(skb);
+}
+
+static void nrc_check_start(struct work_struct *work)
+{
+	struct nrc *nw = container_of(work, struct nrc, check_start.work);
+	int ret;
+	struct sk_buff *skb_req, *skb_resp;
+	struct wim_drv_info_param *p;
+
+	if (nw->drv_state == NRC_DRV_CLOSING)
+		return;
+	if (nrc_check_fw_file(nw)) {
+		if (nrc_check_boot_ready(nw)) {
+			/* ready to download fw, so kick it */
+			nw->drv_state = NRC_DRV_BOOT;
+			nrc_download_fw(nw);
+			/* check the normal fw after 3 sec. */
+			schedule_delayed_work(&nw->check_start,
+					msecs_to_jiffies(3000));
+			return;
+		} else if (nw->drv_state == NRC_DRV_INIT) {
+			/*
+			 * not ready to download,
+			 * so check it again after 10 ms
+			 */
+			schedule_delayed_work(&nw->check_start,
+					msecs_to_jiffies(10));
+			return;
+		}
+		/* just finished downloading, so go forward as normal flow */
+		nw->drv_state = NRC_DRV_INIT;
+		nrc_release_fw(nw);
+	}
+
+#if defined(CONFIG_CHECK_READY)
+	while (!nrc_hif_check_ready(nw->hif)) {
+		nrc_dbg(NRC_DBG_HIF, "Target doesn't ready yet.");
+		mdelay(100);
+	}
+#endif /* defined(CONFIG_CHECK_READY) */
+
+	nw->drv_state = NRC_DRV_START;
+
+	nrc_hif_resume(nw->hif);
+
+	init_completion(&nw->wim_responded);
+	nw->workqueue = create_singlethread_workqueue("nrc_wq");
+	nw->ps_wq = create_singlethread_workqueue("nrc_ps_wq");
+
+	skb_req = nrc_wim_alloc_skb(nw, WIM_CMD_START, sizeof(int));
+	if (!skb_req)
+		goto fail_start;
+	p = nrc_wim_skb_add_tlv(skb_req, WIM_TLV_DRV_INFO,
+			sizeof(struct wim_drv_info_param), NULL);
+	p->boot_mode = (nw->fw_priv->num_chunks > 0) ? 1 : 0;
+	p->cqm_off = disable_cqm;
+	p->bitmap_encoding = bitmap_encoding;
+	p->reverse_scrambler = reverse_scrambler;
+	skb_resp = nrc_xmit_wim_request_wait(nw, skb_req, (WIM_RESP_TIMEOUT * 30));
+	if (skb_resp)
+		nrc_on_fw_ready(skb_resp, nw);
+	else
+		goto fail_start;
+
+	ret = nrc_register_hw(nw);
+	if (ret) {
+		pr_err("failed to register hw");
+		goto fail_start;
+	}
+
+	ret = nrc_netlink_init(nw);
+	if (ret) {
+		pr_err("failed to register netlink");
+		goto fail_start;
+	}
+
+	return;
+
+ fail_start:
+	nrc_free_hw(nw);
+
+	nw->drv_state = NRC_DRV_INIT;
+
+	nrc_dbg(NRC_DBG_MAC, "-%s:error!!", __func__);
+}
+
+static int nrc_platform_probe(struct platform_device *pdev)
+{
+	struct nrc *nw;
+	int ret;
+
+	nw = nrc_alloc_hw(pdev);
+	if (!nw)
+		return -ENOMEM;
+
+	nrc_dbg_init(nw);
+	nw->loopback = loopback;
+	nw->lb_count = lb_count;
+
+	nw->fw_priv = nrc_fw_init(nw);
+	if (!nw->fw_priv) {
+		pr_err("failed to initialize fw");
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	nw->hif = nrc_hif_init(nw);
+	if (!nw->hif) {
+		pr_err("failed to initialize hif");
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	INIT_DELAYED_WORK(&nw->check_start, nrc_check_start);
+
+	platform_set_drvdata(pdev, nw);
+
+	nw->drv_state = NRC_DRV_INIT;
+	nw->fw = NULL;
+
+	schedule_delayed_work(&nw->check_start, msecs_to_jiffies(10));
+
+	return 0;
+
+ fail:
+	nrc_free_hw(nw);
+	platform_set_drvdata(pdev, NULL);
+
+	return ret;
+}
+
+static int nrc_platform_remove(struct platform_device *pdev)
+{
+	struct nrc *nw = platform_get_drvdata(pdev);
+	int counter = 0;
+
+	while(atomic_read(&nw->d_deauth.delayed_deauth)) {
+		msleep(100);
+		if (counter++ > 10) {
+			atomic_set(&nw->d_deauth.delayed_deauth, 0);
+			gpio_set_value(RPI_GPIO_FOR_PS, 0);
+			break;
+		}
+	}
+
+	if (nw->drv_state == NRC_DRV_PS) {
+		gpio_set_value(RPI_GPIO_FOR_PS, 1);
+		msleep(20);
+	}
+	nw->drv_state = NRC_DRV_CLOSING;
+
+	cancel_delayed_work(&nw->check_start);
+
+	if (!loopback) {
+		nrc_netlink_exit();
+		gpio_set_value(RPI_GPIO_FOR_PS, 0);
+		nrc_unregister_hw(nw);
+		nrc_fw_exit(nw->fw_priv);
+	}
+	nrc_hif_close(nw->hif);
+	nrc_hif_exit(nw->hif);
+
+	if (nw->hw)
+		nrc_free_hw(nw);
+
+	platform_set_drvdata(pdev, NULL);
+	nw->drv_state = NRC_DRV_CLOSED;
+	nw->pdev = NULL;
+#if defined(ENABLE_HW_RESET)
+	gpio_set_value(RPI_GPIO_FOR_RST, 0);
+	gpio_free(RPI_GPIO_FOR_RST);
+#endif
+
+	return 0;
+}
+
+static struct platform_driver nrc_driver = {
+	.driver = {
+		.name = "nrc80211",
+	},
+	.probe = nrc_platform_probe,
+	.remove = nrc_platform_remove,
+};
+
+static void nrc_device_release(struct device *dev)
+{
+}
+
+static struct platform_device nrc_device = {
+	.name = "nrc80211",
+	.id = -1,
+	.dev.release = nrc_device_release,
+};
+
+void nrc_set_bss_max_idle_offset(int value)
+{
+	bss_max_idle_offset = value;
+}
+
+void nrc_set_auto_ba(bool toggle)
+{
+	auto_ba = toggle;
+	nrc_dbg(NRC_DBG_MAC, "%s: Auto BA session feature %s", __func__, auto_ba ? "ON" : "OFF");
+}
+
+static int __init nrc_init(void)
+{
+	int err;
+
+	err = nrc_stats_init();
+	if (err)
+		return err;
+
+#if defined(CONFIG_SUPPORT_BD)
+	err = nrc_check_bd();
+	if (err)
+		return err;
+#endif /* defined(CONFIG_SUPPORT_BD) */
+
+	err = platform_device_register(&nrc_device);
+	if (err)
+		return err;
+
+	err = platform_driver_register(&nrc_driver);
+	if (err)
+		goto fail_driver_register;
+
+	nrc_set_bss_max_idle_offset(bss_max_idle_offset);
+
+	return 0;
+
+fail_driver_register:
+	platform_device_unregister(&nrc_device);
+
+	return err;
+}
+module_init(nrc_init);
+
+static void __exit nrc_exit(void)
+{
+	nrc_dbg(NRC_DBG_MAC, "+%s", __func__);
+
+	nrc_exit_debugfs();
+
+	platform_device_unregister(&nrc_device);
+	platform_driver_unregister(&nrc_driver);
+	nrc_stats_deinit();
+
+	nrc_dbg(NRC_DBG_MAC, "-%s", __func__);
+}
+module_exit(nrc_exit);
+
+MODULE_AUTHOR("Newracom, Inc.(http://www.newracom.com)");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_DESCRIPTION("Newracom 802.11 driver");
+#if KERNEL_VERSION(5, 12, 0) > NRC_TARGET_KERNEL_VERSION
+MODULE_SUPPORTED_DEVICE("Newracom 802.11 devices");
+#endif
diff --git a/drivers/staging/nrc/nrc-init.h b/drivers/staging/nrc/nrc-init.h
new file mode 100644
index 000000000000..7ed7cdb9d689
--- /dev/null
+++ b/drivers/staging/nrc/nrc-init.h
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef _NRC_INIT_H_
+#define _NRC_INIT_H_
+
+struct nrc_test_ops;
+struct nrc_uart_priv;
+#include "nrc_monitor_rx.h"
+
+struct nrc_monitor {
+	struct nrc_priv *priv;
+	struct wireless_dev *wdev;
+	struct nrc_monitor_rx_priv rx_priv;
+};
+
+#endif
diff --git a/drivers/staging/nrc/nrc-mac80211.c b/drivers/staging/nrc/nrc-mac80211.c
new file mode 100644
index 000000000000..9d7ede7c3887
--- /dev/null
+++ b/drivers/staging/nrc/nrc-mac80211.c
@@ -0,0 +1,3717 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include "nrc-mac80211.h"
+#include "nrc-hif.h"
+#include "wim.h"
+#include "nrc-debug.h"
+#include "nrc-vendor.h"
+#include "nrc-stats.h"
+#include "nrc-recovery.h"
+#include "nrc-dump.h"
+#include <linux/list.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <net/dst.h>
+#include <net/xfrm.h>
+#include <net/mac80211.h>
+#include <net/ieee80211_radiotap.h>
+#include <linux/if_arp.h>
+#include <linux/netdevice.h>
+#include <linux/rtnetlink.h>
+#include <linux/etherdevice.h>
+#include <linux/platform_device.h>
+#include <linux/debugfs.h>
+#include <linux/module.h>
+#include <linux/ktime.h>
+#include <net/genetlink.h>
+#include <linux/spi/spi.h>
+#include <linux/gpio.h>
+#include "compat.h"
+#if defined(CONFIG_SUPPORT_BD)
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include "nrc-bd.h"
+#endif /* defined(CONFIG_SUPPORT_BD) */
+
+#define CHANS1G(_freq, _freq_partial) { \
+	.band = NL80211_BAND_S1GHZ,			\
+	.center_freq = (_freq),				\
+	.hw_value = (_freq),				\
+	.max_power = 20,					\
+	.center_freq_fractional = (_freq_partial) \
+}
+
+char nrc_cc[2];
+
+#define US_BASE_FREQ	2412
+#define K1_BASE_FREQ	5220
+#define K2_BASE_FREQ	5180
+#define JP_BASE_FREQ	5180
+#define TW_BASE_FREQ	5180
+#define EU_BASE_FREQ	5180
+#define CN_BASE_FREQ	5180
+#define NZ_BASE_FREQ	5180
+#define AU_BASE_FREQ	5180
+
+#define CHAN2G(freq)			\
+{								\
+	.band = NL80211_BAND_2GHZ,	\
+	.center_freq = (freq),		\
+	.hw_value = (freq),			\
+	.max_power = 20,			\
+}
+
+#define CHAN5G(freq)			\
+{								\
+	.band = NL80211_BAND_5GHZ,	\
+	.center_freq = (freq),		\
+	.hw_value = (freq),			\
+	.max_power = 20,			\
+}
+
+#define NRC_CONFIGURE_FILTERS	\
+	(FIF_ALLMULTI				\
+	|FIF_PSPOLL					\
+	|FIF_BCN_PRBRESP_PROMISC	\
+	|FIF_PROBE_REQ				\
+	)
+
+#define FREQ_TO_100KHZ(mhz, khz) (mhz * 10 + khz / 100)
+
+#if defined(CONFIG_S1G_CHANNEL)
+static struct ieee80211_channel nrc_channels_s1ghz[] = {
+	CHANS1G(902, 500),  /* Channel 1 */
+	CHANS1G(903, 0),    /* Channel 2 */
+	CHANS1G(903, 500),  /* Channel 3 */
+	CHANS1G(904, 500),  /* Channel 5 */
+	CHANS1G(905, 0),    /* Channel 6 */
+	CHANS1G(905, 500),  /* Channel 7 */
+	CHANS1G(906, 0),    /* Channel 8 */
+	CHANS1G(906, 500),  /* Channel 9 */
+	CHANS1G(907, 0),    /* Channel 10 */
+	CHANS1G(907, 500),  /* Channel 11 */
+	CHANS1G(908, 500),  /* Channel 13 */
+	CHANS1G(909, 0),    /* Channel 14 */
+	CHANS1G(909, 500),  /* Channel 15 */
+	CHANS1G(910, 0),    /* Channel 16 */
+	CHANS1G(910, 500),  /* Channel 17 */
+	CHANS1G(911, 0),    /* Channel 18 */
+	CHANS1G(911, 500),  /* Channel 19 */
+	CHANS1G(912, 500),  /* Channel 21 */
+	CHANS1G(913, 0),    /* Channel 22 */
+	CHANS1G(913, 500),  /* Channel 23 */
+	CHANS1G(914, 0),    /* Channel 24 */
+	CHANS1G(914, 500),  /* Channel 25 */
+	CHANS1G(915, 0),    /* Channel 26 */
+	CHANS1G(915, 500),  /* Channel 27 */
+	CHANS1G(916, 500),  /* Channel 29 */
+	CHANS1G(917, 0),    /* Channel 30 */
+	CHANS1G(917, 500),  /* Channel 31 */
+	CHANS1G(918, 0),    /* Channel 32 */
+	CHANS1G(918, 500),  /* Channel 33 */
+	CHANS1G(919, 0),    /* Channel 34 */
+	CHANS1G(919, 500),  /* Channel 35 */
+	CHANS1G(920, 500),  /* Channel 37 */
+	CHANS1G(921, 0),    /* Channel 38 */
+	CHANS1G(921, 500),  /* Channel 39 */
+	CHANS1G(922, 0),    /* Channel 40 */
+	CHANS1G(922, 500),  /* Channel 41 */
+	CHANS1G(923, 0),    /* Channel 42 */
+	CHANS1G(923, 500),  /* Channel 43 */
+	CHANS1G(924, 500),  /* Channel 45 */
+	CHANS1G(925, 0),    /* Channel 46 */
+	CHANS1G(925, 500),  /* Channel 47 */
+	CHANS1G(926, 0),    /* Channel 48 */
+	CHANS1G(926, 500),  /* Channel 49 */
+	CHANS1G(927, 0),    /* Channel 46 */
+	CHANS1G(927, 500),  /* Channel 51 */
+};
+#else
+static struct ieee80211_channel nrc_channels_2ghz[] = {
+	CHAN2G(2412), /* Channel 1 */
+	CHAN2G(2417), /* Channel 2 */
+	CHAN2G(2422), /* Channel 3 */
+	CHAN2G(2427), /* Channel 4 */
+	CHAN2G(2432), /* Channel 5 */
+	CHAN2G(2437), /* Channel 6 */
+	CHAN2G(2442), /* Channel 7 */
+	CHAN2G(2447), /* Channel 8 */
+	CHAN2G(2452), /* Channel 9 */
+	CHAN2G(2457), /* Channel 10 */
+	CHAN2G(2462), /* Channel 11 */
+	CHAN2G(2467), /* Channel 12 */
+	CHAN2G(2472), /* Channel 13 */
+	CHAN2G(2484), /* Channel 14 */
+};
+
+static struct ieee80211_channel nrc_channels_5ghz[] = {
+	CHAN5G(5180), /* Channel 36 */
+	CHAN5G(5185), /* Channel 37 */
+	CHAN5G(5190), /* Channel 38 */
+	CHAN5G(5195), /* Channel 39 */
+	CHAN5G(5200), /* Channel 40 */
+	CHAN5G(5205), /* Channel 41 */
+	CHAN5G(5210), /* Channel 42 */
+	CHAN5G(5215), /* Channel 43 */
+	CHAN5G(5220), /* Channel 44 */
+	CHAN5G(5225), /* Channel 45 */
+	CHAN5G(5230), /* Channel 46 */
+	CHAN5G(5235), /* Channel 47 */
+	CHAN5G(5240), /* Channel 48 */
+	CHAN5G(5260), /* Channel 52 */
+	CHAN5G(5280), /* Channel 56 */
+	CHAN5G(5300), /* Channel 60 */
+	CHAN5G(5320), /* Channel 64 */
+	CHAN5G(5500), /* Channel 100 */
+	CHAN5G(5520), /* Channel 104 */
+	CHAN5G(5540), /* Channel 108 */
+	CHAN5G(5560), /* Channel 112 */
+	CHAN5G(5580), /* Channel 116 */
+	CHAN5G(5745), /* Channel 149 */
+	CHAN5G(5750), /* Channel 150 */
+	CHAN5G(5755), /* Channel 151 */
+	CHAN5G(5760), /* Channel 152 */
+	CHAN5G(5765), /* Channel 153 */
+	CHAN5G(5770), /* Channel 154 */
+	CHAN5G(5775), /* Channel 155 */
+	CHAN5G(5780), /* Channel 156 */
+	CHAN5G(5785), /* Channel 157 */
+	CHAN5G(5790), /* Channel 158 */
+	CHAN5G(5795), /* Channel 159 */
+	CHAN5G(5800), /* Channel 160 */
+	CHAN5G(5805), /* Channel 161 */
+	CHAN5G(5810), /* Channel 162 */
+	CHAN5G(5815), /* Channel 163 */
+	CHAN5G(5820), /* Channel 164 */
+	CHAN5G(5825), /* Channel 165 */
+};
+#endif /* CONFIG_S1G_CHANNEL */
+
+
+static struct ieee80211_rate nrc_rates[] = {
+	/* 11b rates */
+	{ .bitrate = 10 },
+	{ .bitrate = 20, .flags = IEEE80211_RATE_SHORT_PREAMBLE },
+	{ .bitrate = 55, .flags = IEEE80211_RATE_SHORT_PREAMBLE },
+	{ .bitrate = 110, .flags = IEEE80211_RATE_SHORT_PREAMBLE },
+
+	/* 11g rates */
+	{ .bitrate = 60 },
+	{ .bitrate = 90 },
+	{ .bitrate = 120 },
+	{ .bitrate = 180 },
+	{ .bitrate = 240 },
+
+	/* README it is removed for 11N Certification 5.2.34 */
+	{ .bitrate = 360 },
+	{ .bitrate = 480 },
+	{ .bitrate = 540 }
+};
+
+#if defined(CONFIG_S1G_CHANNEL)
+static const struct ieee80211_regdomain mac80211_regdom = {
+	.n_reg_rules = 1,
+	.alpha2 =  "99",
+	.reg_rules = {
+		REG_RULE(800, 1000, 4, 0, 20, 0),
+	},
+};
+#else
+static const struct ieee80211_regdomain mac80211_regdom = {
+	.n_reg_rules = 4,
+	.alpha2 =  "99",
+	.reg_rules = {
+		REG_RULE(2412-10, 2484+10, 40, 0, 20, 0),
+		REG_RULE(5180-10, 5320+10, 40, 0, 30, 0),
+		REG_RULE(5500-10, 5580+10, 40, 0, 30, 0),
+		REG_RULE(5745-10, 5825+10, 40, 0, 30, 0),
+	},
+};
+#endif /* CONFIG_S1G_CHANNEL */
+
+static const char nrc_gstrings_stats[][ETH_GSTRING_LEN] = {
+	"tx_pkts_nic",
+	"tx_bytes_nic",
+	"rx_pkts_nic",
+	"rx_bytes_nic",
+	"d_tx_dropped",
+	"d_tx_failed",
+	"d_ps_mode",
+	"d_group",
+	"d_tx_power",
+};
+
+static const u32 nrc_cipher_supported[] = {
+#if !defined(CONFIG_S1G_CHANNEL)
+	WLAN_CIPHER_SUITE_WEP40,
+	WLAN_CIPHER_SUITE_WEP104,
+	WLAN_CIPHER_SUITE_TKIP,
+#endif
+	WLAN_CIPHER_SUITE_CCMP,
+#ifdef CONFIG_SUPPORT_CCMP_256
+	WLAN_CIPHER_SUITE_CCMP_256,
+#endif
+	WLAN_CIPHER_SUITE_AES_CMAC,
+};
+
+static const struct ieee80211_iface_limit if_limits_multi[] = {
+	{
+		.max = 2,
+		.types = BIT(NL80211_IFTYPE_STATION) |
+#ifdef CONFIG_MAC80211_MESH
+			 BIT(NL80211_IFTYPE_MESH_POINT) |
+#endif
+#if defined(CONFIG_WIRELESS_WDS)
+			BIT(NL80211_IFTYPE_WDS) |
+#endif
+			BIT(NL80211_IFTYPE_AP)
+	},
+};
+
+static const struct ieee80211_iface_combination if_comb_multi[] = {
+	{
+		.limits = if_limits_multi,
+		.n_limits = ARRAY_SIZE(if_limits_multi),
+		/* The number of supported VIF (2) + P2P_DEVICE */
+		.max_interfaces = 2,
+		.num_different_channels = 1,
+
+		.beacon_int_infra_match = true,
+#if !defined(CONFIG_S1G_CHANNEL)
+		.radar_detect_widths =
+			BIT(NL80211_CHAN_WIDTH_20_NOHT) |
+			BIT(NL80211_CHAN_WIDTH_20) |
+			BIT(NL80211_CHAN_WIDTH_40) |
+			BIT(NL80211_CHAN_WIDTH_80) |
+			BIT(NL80211_CHAN_WIDTH_160),
+#endif
+	},
+};
+
+static bool get_intf_addr(const char *intf_name, char *addr)
+{
+	struct socket *sock	= NULL;
+	struct net_device *dev	= NULL;
+	struct net *net		= NULL;
+	int retval = 0;
+
+	if (!addr || !intf_name)
+		return false;
+
+	retval = sock_create(AF_INET, SOCK_STREAM, 0, &sock);
+	if (retval < 0)
+		return false;
+
+	net = sock_net(sock->sk);
+
+	dev = dev_get_by_name_rcu(net, intf_name);
+	if (!dev) {
+		sock_release(sock);
+		return false;
+	}
+
+	memcpy(addr, dev->dev_addr, 6);
+
+	sock_release(sock);
+
+	return true;
+}
+
+static void set_mac_address(struct mac_address *macaddr, u8 vif)
+{
+	eth_zero_addr(macaddr->addr);
+	get_intf_addr("eth0", macaddr->addr);
+
+	macaddr->addr[0] = 0x2;
+	macaddr->addr[1] = vif;
+	macaddr->addr[5]++;
+}
+
+#ifdef CONFIG_USE_TXQ
+static inline struct ieee80211_txq *to_txq(struct nrc_txq *p)
+{
+	return container_of((void *)p, struct ieee80211_txq, drv_priv);
+}
+
+/**
+ * nrc_txq_init - Initialize txq driver data
+ */
+static void nrc_init_txq(struct ieee80211_txq *txq, struct ieee80211_vif *vif)
+{
+	struct nrc_txq *q;
+
+	if (!txq)
+		return;
+
+	q = (void *)txq->drv_priv;
+	INIT_LIST_HEAD(&q->list);
+	skb_queue_head_init(&q->queue);
+#ifdef CONFIG_CHECK_DATA_SIZE
+	q->data_size = 0;
+#endif
+	q->hw_queue = vif->hw_queue[txq->ac];
+}
+
+
+unsigned int nrc_ac_credit(struct nrc *nw, int ac)
+{
+	int ret;
+
+	ret = atomic_read(&nw->tx_credit[ac])
+		- atomic_read(&nw->tx_pend[ac]);
+	if (ret < 0)
+		return 0;
+	return ret;
+}
+
+static __u32 nrc_txq_pending(struct ieee80211_hw *hw)
+{
+	struct nrc *nw = hw->priv;
+	struct nrc_txq *cur, *next;
+	int ac;
+	int len = 0;
+	u64 now = 0, diff = 0;
+
+	if (nw->drv_state != NRC_DRV_RUNNING)
+		return 0;
+
+	now = ktime_to_us(ktime_get_real());
+
+	spin_lock_bh(&nw->txq_lock);
+
+	rcu_read_lock();
+	list_for_each_entry_safe(cur, next, &nw->txq, list) {
+		ac = cur->hw_queue;
+		len += skb_queue_len(&cur->queue);
+		len += atomic_read(&nw->tx_pend[ac]);
+		/* Need to consider credit? */
+	}
+	rcu_read_unlock();
+
+	spin_unlock_bh(&nw->txq_lock);
+
+	diff = ktime_to_us(ktime_get_real()) - now;
+	if ((!diff) || (diff > NRC_MAC80211_RCU_LOCK_THRESHOLD))
+		nrc_mac_dbg("%s, diff=%lu", __func__, (unsigned long)diff);
+
+	return len;
+}
+
+/* Just for debugging */
+static unsigned long long fail, total;
+
+/**
+ * nrc_pull_txq - pull skb's from txq within available credits.
+ *
+ *
+ * Return the number of remaining packets.
+ */
+static __u32 nrc_pull_txq(struct nrc *nw, struct nrc_txq *q)
+{
+	struct sk_buff *skb;
+	struct ieee80211_tx_control control;
+	//struct nrc_txq *q = (void *)txq->drv_priv;
+	int ac = q->hw_queue, credit;
+	__u32 ret;
+#ifdef CONFIG_NRC_HIF_PRINT_FLOW_CONTROL
+	int i;
+#endif
+	control.sta = q->sta;
+
+	while ((ret = skb_queue_len(&q->queue)) > 0) {
+		unsigned long flags;
+
+		spin_lock_irqsave(&q->queue.lock, flags);
+
+		total++;
+		skb = skb_peek(&q->queue);
+		BUG_ON(!skb);
+		credit = DIV_ROUND_UP(skb->len + nw->fwinfo.tx_head_size,
+				nw->fwinfo.buffer_size);
+		if (credit > nrc_ac_credit(nw, ac)) {
+			fail++;
+#ifdef CONFIG_NRC_HIF_PRINT_FLOW_CONTROL
+			nrc_dbg(NRC_DBG_MAC,
+			"%s: failed to push skb %p (%d/%d): fail/total=%llu/%llu\n",
+					__func__, skb,
+					credit,
+					nrc_ac_credit(nw, ac),
+					fail, total);
+#endif
+			/*
+			 * We do not have enough credit to transmit
+			 * @skb immediately. Backoff for next chances.
+			 */
+			spin_unlock_irqrestore(&q->queue.lock, flags);
+			break;
+		}
+
+		__skb_unlink(skb, &q->queue);
+#ifdef CONFIG_CHECK_DATA_SIZE
+		q->data_size -= skb->len;
+		//pr_err("dequeue tx size:%d\n", q->data_size);
+#endif
+
+
+		spin_unlock_irqrestore(&q->queue.lock, flags);
+
+#ifdef CONFIG_NRC_HIF_PRINT_FLOW_CONTROL
+		nrc_mac_dbg("tx: ac=%d skb=%p qlen=%d credit=%d %c: ",
+				ac, skb, skb_queue_len(&q->queue),
+				nrc_ac_credit(nw, ac),
+				in_softirq() ? 'w' : 'i');
+		nrc_mac_dbg("credits: ");
+		for (i = 0; i < 4; i++)
+			nrc_mac_dbg("%d ", nrc_ac_credit(nw, i));
+		nrc_mac_dbg("\n");
+#endif
+#ifdef CONFIG_SUPPORT_AFTER_KERNEL_3_0_36
+		nrc_mac_tx(nw->hw, &control, skb);
+#else
+		nrc_mac_tx(nw->hw, skb);
+#endif
+
+		/* It is no longer needed */
+		/* atomic_sub(credit, &nw->tx_credit[ac]); */
+	}
+	return skb_queue_len(&q->queue);
+}
+
+static bool
+nrc_txq_pullable(struct nrc_txq *ntxq)
+{
+#ifdef CONFIG_CHECK_DATA_SIZE
+#if 0 /* test code to check max size */
+	static unsigned int max_size;
+
+	if (ntxq->data_size > max_size) {
+		max_size = ntxq->data_size;
+		pr_err("max tx size:%d\n", max_size);
+	}
+#endif
+	if (ntxq->data_size < NR_NRC_MAX_TXQ_SIZE) {
+		return true;
+	}
+	else {
+		pr_info_ratelimited("overrun, tx size:%d\n", ntxq->data_size);
+		return false;
+	}
+	return (ntxq->data_size < NR_NRC_MAX_TXQ_SIZE);
+#else
+	return (skb_queue_len(&ntxq->queue) < NR_NRC_MAX_TXQ);
+#endif
+}
+
+/**
+ * nrc_wake_tx_queue
+ *
+ * The function moves skb in @txq to sk_buff_head in its private data
+ * structure, and add it to woken up list.
+ */
+static
+void nrc_wake_tx_queue(struct ieee80211_hw *hw, struct ieee80211_txq *txq)
+{
+	struct nrc *nw = hw->priv;
+	struct nrc_txq *local, *priv_ntxq = (void *)txq->drv_priv;
+	struct sk_buff *skb = NULL;
+	int max = 16;
+
+	if (nw->drv_state == NRC_DRV_PS) {
+		max = 1;
+		gpio_set_value(RPI_GPIO_FOR_PS, 1);
+		nrc_ps_dbg("[%s,L%d] Set GPIO high for wakeup(%d)\n", __func__, __LINE__, nw->drv_state);
+		ieee80211_stop_queue(hw, priv_ntxq->hw_queue);
+	}
+
+	local = &nw->ntxq[priv_ntxq->hw_queue];
+
+	while (max--) {
+		skb = ieee80211_tx_dequeue(nw->hw, txq);
+		if (!skb)
+			break;
+		if (nrc_txq_pullable(local)) {
+			spin_lock_bh(&nw->txq_lock);
+			skb_queue_tail(&local->queue, skb);
+#ifdef CONFIG_CHECK_DATA_SIZE
+			local->data_size += skb->len;
+			//pr_err("enqueue tx size:%d\n", local->data_size);
+#endif
+			spin_unlock_bh(&nw->txq_lock);
+		} else {
+			dev_kfree_skb(skb);
+		}
+	}
+
+	if (nw->drv_state == NRC_DRV_PS) {
+		return;
+	}
+
+	ieee80211_stop_queue(hw, priv_ntxq->hw_queue);
+	nrc_kick_txq(nw->hw);
+}
+
+/**
+ * nrc_kick_txq - push tx frames to hif.
+ *
+ * This function is called from both wake_tx_queue() callback
+ * and the ac queue status event handler.
+ *
+ * TODO:
+ * Decide scheduling algorithm: first-come first-serve or
+ * fairness between txq's (currently, it's first-come first served).
+ */
+void nrc_kick_txq(struct ieee80211_hw *hw)
+{
+	struct nrc *nw = hw->priv;
+	struct nrc_txq *cur;
+	int res, cnt = 0, i = 0;
+
+	if (nw->drv_state != NRC_DRV_RUNNING)
+		return;
+
+	/* Before pushing frame to HIF, check pending TXQs exits.
+	 * If so, pulling them first.
+	 */
+	spin_lock_bh(&nw->txq_lock);
+	rcu_read_lock();
+
+	for (i = 0; i < NRC_QUEUE_MAX; i++) {
+		cur = &nw->ntxq[i];
+		res = nrc_pull_txq(nw, cur);
+		cnt += res;
+	}
+
+	rcu_read_unlock();
+	spin_unlock_bh(&nw->txq_lock);
+
+	ieee80211_wake_queues(nw->hw);
+}
+
+/*
+ * nrc_cleanup_txq - cleanup txq
+ *
+ * This function is called from nrc_unregister_hw()
+ */
+static
+void nrc_cleanup_txq(struct nrc *nw)
+{
+	struct nrc_txq *cur, *next;
+	int res, ret;
+	struct sk_buff *skb;
+
+	spin_lock_bh(&nw->txq_lock);
+
+	list_for_each_entry_safe(cur, next, &nw->txq, list) {
+		res = nrc_pull_txq(nw, cur);
+		while ((ret = skb_queue_len(&cur->queue)) > 0) {
+			skb = skb_peek(&cur->queue);
+			BUG_ON(!skb);
+
+			__skb_unlink(skb, &cur->queue);
+#ifdef CONFIG_CHECK_DATA_SIZE
+			cur->data_size -= skb->len;
+#endif
+			dev_kfree_skb_any(skb);
+		}
+		list_del_init(&cur->list);
+	}
+
+	spin_unlock_bh(&nw->txq_lock);
+}
+
+#else
+#define nrc_init_txq(txq, vif)
+#endif
+
+static void nrc_assoc_h_basic(struct ieee80211_hw *hw,
+			      struct ieee80211_vif *vif,
+			      struct ieee80211_bss_conf *info,
+			      struct ieee80211_sta *sta,
+			      struct sk_buff *skb)
+{
+	struct nrc *nw = hw->priv;
+#ifdef CONFIG_SUPPORT_CHANNEL_INFO
+	struct ieee80211_chanctx_conf *conf;
+#else
+	struct ieee80211_conf	*conf = &hw->conf;
+	struct ieee80211_channel *conf_chan = conf->channel;
+#endif
+
+#ifdef CONFIG_USE_NEW_BAND_ENUM
+	enum nl80211_band band;
+#else
+	enum ieee80211_band band;
+#endif
+
+	nrc_mac_dbg("%s: aid=%u, bssid=%pM", __func__,
+		info->aid, info->bssid);
+
+	nw->aid = info->aid;
+#ifdef CONFIG_TRX_BACKOFF
+	nw->ampdu_supported = 0;
+#endif
+
+	nrc_wim_skb_add_tlv(skb, WIM_TLV_AID, sizeof(info->aid), &info->aid);
+	nrc_wim_skb_add_tlv(skb, WIM_TLV_BSSID, ETH_ALEN, (void *)info->bssid);
+
+	/* Enable later when rate adaptation is supported in the target */
+#ifdef CONFIG_SUPPORT_CHANNEL_INFO
+	conf = rcu_dereference(vif->chanctx_conf);
+	band = conf->def.chan->band;
+#else
+	band = conf_chan->band;
+#endif
+	nrc_wim_skb_add_tlv(skb, WIM_TLV_SUPPORTED_RATES,
+			    sizeof(sta->supp_rates[band]),
+			    &sta->supp_rates[band]);
+	nrc_wim_skb_add_tlv(skb, WIM_TLV_BASIC_RATE,
+			    sizeof(info->basic_rates), &info->basic_rates);
+}
+
+
+static
+void nrc_assoc_h_ht(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+		    struct ieee80211_bss_conf *bss_conf,
+		    struct ieee80211_sta *sta, struct sk_buff *skb)
+{
+	struct ieee80211_sta_ht_cap *ht_cap = &sta->ht_cap;
+
+	/* Assumption: ht_cap->ht_supported is false if HT Capabilities
+	 * element is not included in the Association Response frame
+	 */
+
+	nrc_mac_dbg("%s: %s (ht_cap=%04x)", __func__,
+		ht_cap->ht_supported ? "HT" : "non-HT",
+		ht_cap->ht_supported ? ht_cap->cap : 0x0);
+
+	if (!ht_cap->ht_supported)
+		return;
+
+	nrc_wim_skb_add_tlv(skb, WIM_TLV_HT_CAP, sizeof(u16), &ht_cap->cap);
+
+	/* TODO: MCS */
+}
+
+static
+void nrc_assoc_h_phymode(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+			 struct ieee80211_bss_conf *bss_conf,
+			 struct ieee80211_sta *sta, struct sk_buff *skb)
+{
+	enum { PHY_HT_NONE = 0, PHY_11B = 1, PHY_HT_MF = 3};
+	static char * const phymodestr[] = {"HT-none", "11b", "", "HT"};
+	u8 phymode;
+
+	/* HT_MF, non-HT, 11b */
+	if (sta->ht_cap.ht_supported)
+		phymode = PHY_HT_MF;
+	else if (sta->supp_rates[NL80211_BAND_2GHZ] >> 4)
+		phymode = PHY_HT_NONE;
+	else
+		phymode = PHY_11B;
+
+	nrc_mac_dbg("%s: phy mode=%s", __func__, phymodestr[phymode]);
+
+	nrc_wim_skb_add_tlv(skb, WIM_TLV_PHY_MODE, sizeof(u8), &phymode);
+}
+
+
+static
+void nrc_bss_assoc(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+			  struct ieee80211_bss_conf *bss_conf,
+			  struct sk_buff *skb)
+{
+	struct ieee80211_sta *ap_sta;
+	u64 now = 0, diff = 0;
+
+	now = ktime_to_us(ktime_get_real());
+
+	rcu_read_lock();
+	ap_sta = ieee80211_find_sta(vif, bss_conf->bssid);
+	if (!ap_sta) {
+		nrc_mac_dbg("failed to find sta for bss %pM",
+			bss_conf->bssid);
+		goto out;
+	}
+
+	nrc_assoc_h_basic(hw, vif, bss_conf, ap_sta, skb);
+	nrc_assoc_h_ht(hw, vif, bss_conf, ap_sta, skb);
+	nrc_assoc_h_phymode(hw, vif, bss_conf, ap_sta, skb);
+
+ out:
+	rcu_read_unlock();
+	diff = ktime_to_us(ktime_get_real()) - now;
+	if ((!diff) || (diff > NRC_MAC80211_RCU_LOCK_THRESHOLD))
+		nrc_mac_dbg("%s, diff=%lu", __func__, (unsigned long)diff);
+}
+
+static int nrc_vendor_update_beacon(struct ieee80211_hw *hw,
+			struct ieee80211_vif *vif)
+{
+	struct nrc *nw = hw->priv;
+	struct sk_buff *skb, *b;
+	u8 *pos;
+	u16 need_headroom, need_tailroom;
+
+	b = ieee80211_beacon_get_template(hw, vif, NULL);
+	if (!b)
+		return -EINVAL;
+
+	if (nw->vendor_skb) {
+		need_headroom = skb_headroom(b);
+		need_tailroom = nw->vendor_skb->len;
+
+		if (skb_tailroom(b) < need_tailroom) {
+			if (pskb_expand_head(b, need_headroom, need_tailroom,
+						GFP_ATOMIC)) {
+				nrc_mac_dbg("Fail to expand Beacon for vendor elem (need: %d)",
+					need_tailroom);
+				dev_kfree_skb_any(b);
+				dev_kfree_skb_any(nw->vendor_skb);
+				nw->vendor_skb = NULL;
+				return 0;
+			}
+		}
+		pos = skb_put(b, nw->vendor_skb->len);
+		memcpy(pos, nw->vendor_skb->data, nw->vendor_skb->len);
+	}
+
+	skb = nrc_wim_alloc_skb_vif(nw, vif, WIM_CMD_SET, WIM_MAX_SIZE);
+	pos = nrc_wim_skb_add_tlv(skb, WIM_TLV_BEACON, b->len, b->data);
+
+	dev_kfree_skb_any(b);
+	return nrc_xmit_wim_request(nw, skb);
+}
+
+static int nrc_mac_start(struct ieee80211_hw *hw)
+{
+	struct nrc *nw = hw->priv;
+	struct sk_buff *skb;
+	int alloc_size;
+
+#if defined(CONFIG_SUPPORT_BD)
+	/* Case of Invalid board data */
+	if(nw->bd_valid == false)
+		return -1;
+	else
+#endif /* defined(CONFIG_SUPPORT_BD) */
+		nw->drv_state = NRC_DRV_RUNNING;
+
+	nw->aid = 0;
+
+	alloc_size = tlv_len(sizeof(u16)) + tlv_len(ETH_ALEN);
+	if (nrc_mac_is_s1g(nw)) {
+		alloc_size += tlv_len(sizeof(u8));
+	}
+	skb = nrc_wim_alloc_skb(nw, WIM_CMD_SET, alloc_size);
+
+	nrc_wim_set_aid(nw, skb, nw->aid);
+	nrc_wim_add_mac_addr(nw, skb, nw->mac_addr[0].addr);
+
+	if (nrc_mac_is_s1g(nw)) {
+		nrc_wim_set_ndp_preq(nw, skb, ndp_preq);
+		if(enable_legacy_ack)
+			nrc_wim_set_legacy_ack(nw, skb, enable_legacy_ack);
+	}
+
+	nrc_xmit_wim_request(nw, skb);
+
+	return 0;
+}
+
+void nrc_mac_stop(struct ieee80211_hw *hw)
+{
+	struct nrc *nw = hw->priv;
+	int ret = 0;
+
+	if (nw->drv_state == NRC_DRV_CLOSING ||
+		atomic_read(&nw->d_deauth.delayed_deauth))
+		return;
+
+	nw->drv_state = NRC_DRV_STOP;
+	ret = nrc_hif_check_target(nw->hif, 0x1B);
+	if (ret != 1) {
+		nrc_xmit_wim_simple_request(nw, WIM_CMD_STOP);
+	}
+}
+
+/**
+ * DOC: VIF handlers
+ *
+ */
+static int nrc_alloc_vif_index(struct nrc *nw, struct ieee80211_vif *vif)
+{
+	int i;
+	const int P2P_INDEX = 1;
+
+	spin_lock_bh(&nw->vif_lock);
+	for (i = 0; i < ARRAY_SIZE(nw->vif); i++) {
+		/* Assign P2P DEVICE's index to P2P GO or GC */
+		if (vif->p2p && i == P2P_INDEX && nw->vif[i])
+			nw->vif[i] = NULL;
+
+		if (!nw->vif[i]) {
+			struct nrc_vif *i_vif = to_i_vif(vif);
+
+			i_vif->index = i;
+			nw->vif[i] = vif;
+			nw->enable_vif[i] = true;
+			spin_unlock_bh(&nw->vif_lock);
+			return 0;
+		}
+	}
+
+	spin_unlock_bh(&nw->vif_lock);
+	/* All h/w vifs are in use */
+	return -EBUSY;
+}
+
+void nrc_free_vif_index(struct nrc *nw, struct ieee80211_vif *vif)
+{
+	struct nrc_vif *i_vif = to_i_vif(vif);
+
+	spin_lock_bh(&nw->vif_lock);
+	nw->vif[i_vif->index] = NULL;
+	nw->enable_vif[i_vif->index] = false;
+	i_vif->index = -1;
+	spin_unlock_bh(&nw->vif_lock);
+}
+
+bool nrc_access_vif(struct nrc *nw)
+{
+	int i;
+
+	spin_lock_bh(&nw->vif_lock);
+	for (i = 0; i < ARRAY_SIZE(nw->vif); i++) {
+		/* FIXME: use vif_lock for fw_state -- sw.ki -- 2019-1022 */
+		if (nw->vif[i] /*&& nw->fw_state == NRC_FW_ACTIVE*/) {
+			spin_unlock_bh(&nw->vif_lock);
+			return true;
+		}
+	}
+	spin_unlock_bh(&nw->vif_lock);
+	return false;
+}
+
+const char *iftype_string(enum nl80211_iftype iftype)
+{
+	switch (iftype) {
+	case NL80211_IFTYPE_UNSPECIFIED: return "UNSPECIFIED";
+	case NL80211_IFTYPE_ADHOC: return "ADHOC";
+	case NL80211_IFTYPE_STATION: return "STATION";
+	case NL80211_IFTYPE_AP: return "AP";
+	case NL80211_IFTYPE_AP_VLAN: return "AP_VLAN";
+	case NL80211_IFTYPE_WDS: return "WDS";
+	case NL80211_IFTYPE_MONITOR: return "MONITOR";
+	case NL80211_IFTYPE_MESH_POINT: return "MESH_POINT";
+#ifdef CONFIG_SUPPORT_AFTER_KERNEL_3_0_36
+	case NL80211_IFTYPE_P2P_CLIENT: return "P2P_CLIENT";
+	case NL80211_IFTYPE_P2P_GO: return "P2P_GO";
+	case NL80211_IFTYPE_P2P_DEVICE: return "P2P_DEVICE";
+#endif
+#ifdef CONFIG_SUPPORT_IFTYPE_OCB
+	case NL80211_IFTYPE_OCB: return "OCB";
+#endif
+	default: return "UNKNOWN Type";
+	}
+}
+
+static void nrc_mac_roc_finish(struct work_struct *work)
+{
+	struct nrc *nw = container_of(work, struct nrc, roc_finish.work);
+
+	nrc_mac_dbg("%s", __func__);
+	ieee80211_remain_on_channel_expired(nw->hw);
+}
+
+#ifdef CONFIG_USE_SCAN_TIMEOUT
+static void nrc_mac_scan_timeout(struct work_struct *work);
+#endif
+
+static int nrc_mac_add_interface(struct ieee80211_hw *hw,
+				 struct ieee80211_vif *vif)
+{
+	struct nrc *nw = hw->priv;
+	struct nrc_vif *i_vif = to_i_vif(vif);
+	int hw_queue_start = 0;
+	u64 now = 0, diff = 0;
+
+#ifdef CONFIG_SUPPORT_AFTER_KERNEL_3_0_36
+	/* 20190724, jmjang, CB#8781, Gerrit #2200
+	 *	This feature is opposite to legacy power save in host mode and
+	 *  so this feature is blocked.
+	 *	Consideration: There is an WFA test case about WMM-PS but
+	 *  it will be related to Wi-Fi P2P
+	 */
+	/* vif->driver_flags |= IEEE80211_VIF_SUPPORTS_UAPSD; */
+#endif
+	memset(i_vif, 0, sizeof(*i_vif));
+
+	if (WARN_ON(nrc_alloc_vif_index(nw, vif) < 0))
+		return -1;
+
+	if (vif->type == NL80211_IFTYPE_MONITOR) {
+		/*
+		 * Monitor interfaces are the only active interfaces.
+		 * Put the target into promiscuous mode
+		 */
+		nw->promisc = true;
+
+		nrc_mac_dbg("promiscuous mode on");
+		goto out;
+	}
+
+	nw->promisc = false;
+
+	hw_queue_start = i_vif->index * NR_NRC_VIF_HW_QUEUE;
+	if (i_vif->index)
+		hw_queue_start += 2;
+
+#ifdef CONFIG_SUPPORT_AFTER_KERNEL_3_0_36
+	if (vif->type == NL80211_IFTYPE_AP ||
+	    vif->type == NL80211_IFTYPE_WDS ||
+	    vif->type == NL80211_IFTYPE_P2P_GO)
+		vif->cab_queue = hw_queue_start + 4;
+	else
+		vif->cab_queue = IEEE80211_INVAL_HW_QUEUE;
+
+	vif->hw_queue[IEEE80211_AC_VO] = hw_queue_start + 3;
+	vif->hw_queue[IEEE80211_AC_VI] = hw_queue_start + 2;
+	vif->hw_queue[IEEE80211_AC_BE] = hw_queue_start + 1;
+	vif->hw_queue[IEEE80211_AC_BK] = hw_queue_start + 0;
+#endif
+
+	nrc_init_txq(vif->txq, vif);
+
+	i_vif->nw = nw;
+	i_vif->max_idle_period = nw->cap.bss_max_idle;
+
+	now = ktime_to_us(ktime_get_real());
+
+	rcu_read_lock();
+	i_vif->dev = dev_getbyhwaddr_rcu(wiphy_net(hw->wiphy), ARPHRD_ETHER,
+					 vif->addr);
+	rcu_read_unlock();
+
+	diff = ktime_to_us(ktime_get_real()) - now;
+	if ((!diff) || (diff > NRC_MAC80211_RCU_LOCK_THRESHOLD))
+		nrc_mac_dbg("%s, diff=%lu", __func__, (unsigned long)diff);
+
+	if (i_vif->dev == NULL)
+		return -1;
+
+	spin_lock_init(&i_vif->preassoc_sta_lock);
+	INIT_LIST_HEAD(&i_vif->preassoc_sta_list);
+
+#ifdef CONFIG_USE_SCAN_TIMEOUT
+	INIT_DELAYED_WORK(&i_vif->scan_timeout, nrc_mac_scan_timeout);
+#endif
+
+	nrc_mac_dbg("%s %s addr:%pM hwindex:%d", __func__,
+			i_vif->dev ? netdev_name(i_vif->dev):"NULL", vif->addr,
+			i_vif->index);
+
+ out:
+
+	if (vif->p2p)
+		nrc_wim_set_p2p_addr(nw, vif);
+	else
+		nrc_wim_set_mac_addr(nw, vif);
+
+	nrc_wim_set_sta_type(nw, vif);
+	nrc_hif_resume_rx_thread(nw->hif);
+
+	return 0;
+}
+
+static int nrc_mac_change_interface(struct ieee80211_hw *hw,
+				struct ieee80211_vif *vif,
+				enum nl80211_iftype newtype,
+				bool newp2p)
+{
+	struct nrc *nw = hw->priv;
+
+	/*
+	 * interface may change from non-AP to AP in
+	 * which case this needs to be set up again
+	 */
+	vif->type = newtype;
+	vif->p2p = newp2p;
+
+	nrc_wim_set_mac_addr(nw, vif);
+	nrc_wim_set_sta_type(nw, vif);
+
+#ifdef CONFIG_SUPPORT_AFTER_KERNEL_3_0_36
+	vif->cab_queue = 0;
+#endif
+
+	return 0;
+}
+
+static void nrc_mac_remove_interface(struct ieee80211_hw *hw,
+				struct ieee80211_vif *vif)
+{
+	struct nrc *nw = hw->priv;
+	struct nrc_vif *i_vif = to_i_vif(vif);
+
+	if (vif->type == NL80211_IFTYPE_MONITOR || vif->p2p)
+		return;
+
+	nrc_mac_dbg("%s %s addr:%pM hwindex:%d %s", __func__,
+		    i_vif->dev ? netdev_name(i_vif->dev):"NULL", vif->addr,
+		    i_vif->index,
+		    iftype_string(vif->type));
+
+#ifdef CONFIG_USE_SCAN_TIMEOUT
+	cancel_delayed_work_sync(&i_vif->scan_timeout);
+#endif
+	if (!atomic_read(&nw->d_deauth.delayed_deauth)) {
+		int ret = 0;
+		ret = nrc_hif_check_target(nw->hif, 0x1B);
+		if (ret != 1) {
+			nrc_wim_unset_sta_type(nw, vif);
+		}
+		nrc_free_vif_index(hw->priv, vif);
+		i_vif->dev = NULL;
+	} else {
+		nw->d_deauth.removed = true;
+}
+}
+
+static enum WIM_CHANNEL_PARAM_WIDTH
+get_wim_channel_width(enum nl80211_chan_width width)
+{
+	switch (width) {
+	case NL80211_CHAN_WIDTH_20_NOHT:
+		return CH_WIDTH_20_NOHT;
+	case NL80211_CHAN_WIDTH_20:
+		return CH_WIDTH_20;
+	case NL80211_CHAN_WIDTH_40:
+		return CH_WIDTH_40;
+	case NL80211_CHAN_WIDTH_80:
+		return CH_WIDTH_80;
+	case NL80211_CHAN_WIDTH_80P80:
+		return CH_WIDTH_80P80;
+	case NL80211_CHAN_WIDTH_160:
+		return CH_WIDTH_160;
+	case NL80211_CHAN_WIDTH_5:
+		return CH_WIDTH_5;
+	case NL80211_CHAN_WIDTH_10:
+		return CH_WIDTH_10;
+#if defined(CONFIG_S1G_CHANNEL)
+	case NL80211_CHAN_WIDTH_1:
+		return CH_WIDTH_1;
+	case NL80211_CHAN_WIDTH_2:
+		return CH_WIDTH_2;
+	case NL80211_CHAN_WIDTH_4:
+		return CH_WIDTH_4;
+	case NL80211_CHAN_WIDTH_8:
+		return CH_WIDTH_8;
+	case NL80211_CHAN_WIDTH_16:
+		return CH_WIDTH_16;
+#endif /* CONFIG_S1G_CHANNEL */
+	default:
+		return CH_WIDTH_20;
+	}
+}
+
+uint16_t get_base_freq (void)
+{
+	uint16_t ret_freq = 0;
+
+	if (nrc_cc[0] == 'U' && nrc_cc[1] == 'S') {
+		ret_freq = US_BASE_FREQ;
+	} else if (nrc_cc[0] == 'J' && nrc_cc[1] == 'P') {
+		ret_freq = JP_BASE_FREQ;
+	} else if (nrc_cc[0] == 'T' && nrc_cc[1] == 'W') {
+		ret_freq = TW_BASE_FREQ;
+	} else if (nrc_cc[0] == 'A' && nrc_cc[1] == 'U') {
+		ret_freq = AU_BASE_FREQ;
+	} else if (nrc_cc[0] == 'N' && nrc_cc[1] == 'Z') {
+		ret_freq = NZ_BASE_FREQ;
+	} else if (nrc_cc[0] == 'E' && nrc_cc[1] == 'U') {
+		ret_freq = EU_BASE_FREQ;
+	} else if (nrc_cc[0] == 'C' && nrc_cc[1] == 'N') {
+		ret_freq = CN_BASE_FREQ;
+	} else if (nrc_cc[0] == 'K' && nrc_cc[1] == 'R') {
+		if (enable_usn) {
+			ret_freq = K1_BASE_FREQ;
+		} else {
+			ret_freq = K2_BASE_FREQ;
+		}
+	}
+	else {
+	}
+	return ret_freq;
+}
+
+#ifdef CONFIG_SUPPORT_CHANNEL_INFO
+void nrc_mac_add_tlv_channel(struct sk_buff *skb,
+					struct cfg80211_chan_def *chandef)
+{
+#if !defined(CONFIG_S1G_CHANNEL)
+	enum nl80211_channel_type ch_type;
+	struct wim_channel_param ch_param;
+
+	ch_type = cfg80211_get_chandef_type(chandef);
+
+	/*temporarily resolved host system freezing */
+	if (WARN_ON(!chandef->chan))
+		return;
+
+	ch_param.channel = chandef->chan->center_freq;
+	ch_param.type = ch_type;
+	ch_param.width = get_wim_channel_width(chandef->width);
+	nrc_wim_skb_add_tlv(skb, WIM_TLV_CHANNEL,
+				   sizeof(ch_param), &ch_param);
+#else
+	struct wim_s1g_channel_param param;
+
+	param.pr_freq = FREQ_TO_100KHZ(chandef->chan->center_freq,
+				chandef->chan->center_freq_fractional);
+	param.op_freq = FREQ_TO_100KHZ(chandef->center_freq1,
+				chandef->center_freq1_fractional);
+	param.width = get_wim_channel_width(chandef->width);
+	pr_err("nrc: pri(%d), op(%d), width(%d)\n", param.pr_freq,
+			param.op_freq, param.width);
+	nrc_wim_skb_add_tlv(skb, WIM_TLV_S1G_CHANNEL, sizeof(param),
+			&param);
+#endif
+}
+#else
+void nrc_mac_add_tlv_channel(struct sk_buff *skb,
+			struct ieee80211_conf *chandef)
+{
+	enum nl80211_channel_type ch_type = chandef->channel_type;
+	struct wim_channel_param ch_param;
+
+	ch_param.channel = chandef->channel->center_freq;
+	ch_param.type = ch_type;
+	if (ch_type >= NL80211_CHAN_HT40MINUS)
+		ch_param.width = NL80211_CHAN_HT40MINUS;
+	else
+		ch_param.width = ch_type;
+
+	nrc_wim_skb_add_tlv(skb, WIM_TLV_CHANNEL,
+				sizeof(ch_param), &ch_param);
+}
+#endif
+
+static int nrc_mac_config(struct ieee80211_hw *hw, u32 changed)
+{
+	struct nrc *nw = hw->priv;
+	struct wim_pm_param *p;
+	struct sk_buff *skb;
+	struct nrc_txq *ntxq;
+	int ret = 0, i;
+	struct ieee80211_channel ch = {0,};
+#if defined(CONFIG_SUPPORT_BD)
+	bool supp_ch_flag = false;
+#endif /* defined(CONFIG_SUPPORT_BD) */
+#ifdef CONFIG_SUPPORT_CHANNEL_INFO
+	struct cfg80211_chan_def chandef = {0,};
+	memcpy(&chandef, &hw->conf.chandef, sizeof(struct cfg80211_chan_def));
+	memcpy(&ch, hw->conf.chandef.chan, sizeof(struct ieee80211_channel));
+	chandef.chan = &ch;
+#else
+	struct ieee80211_conf chandef = {0,};
+	memcpy(&chandef, &hw->conf, sizeof(struct ieee80211_conf));
+	memcpy(&ch, hw->conf.channel, sizeof(struct ieee80211_channel));
+	chandef.channel = &ch;
+#endif
+
+#if defined(CONFIG_SUPPORT_BD)
+	if(g_supp_ch_list.num_ch) {
+		if (changed & IEEE80211_CONF_CHANGE_CHANNEL) {
+			for(i=0; i < g_supp_ch_list.num_ch; i++) {
+				if(g_supp_ch_list.nons1g_ch_freq[i] ==
+					hw->conf.chandef.chan->center_freq) {
+					supp_ch_flag = true;
+					break;
+				}
+			}
+			if (!supp_ch_flag && nw->alpha2[0] != 'U' && nw->alpha2[1] != 'S' &&
+				hw->conf.chandef.chan->center_freq == 2412) {
+				supp_ch_flag = true;
+#ifdef CONFIG_SUPPORT_CHANNEL_INFO
+				chandef.chan->center_freq = g_supp_ch_list.nons1g_ch_freq[0];
+#else
+				chandef.channel->center_freq = g_supp_ch_list.nons1g_ch_freq[0];
+#endif /* CONFIG_SUPPORT_CHANNEL_INFO */
+			}
+			if(!supp_ch_flag) {
+				nrc_mac_dbg("%s: Not supported channel %u",
+					__func__, hw->conf.chandef.chan->center_freq);
+				return -EINVAL;
+			}
+		}
+	}
+#else
+	if (nw->alpha2[0] != 'U' && nw->alpha2[1] != 'S' &&
+			hw->conf.chandef.chan->center_freq == 2412) {
+#ifdef CONFIG_SUPPORT_CHANNEL_INFO
+		chandef.chan->center_freq = get_base_freq();
+#else
+		chandef.channel->center_freq = get_base_freq();
+#endif /* CONFIG_SUPPORT_CHANNEL_INFO */
+	}
+#endif /* defined(CONFIG_SUPPORT_BD) */
+
+	skb = nrc_wim_alloc_skb(nw, WIM_CMD_SET, WIM_MAX_SIZE);
+
+	if (changed & IEEE80211_CONF_CHANGE_CHANNEL) {
+
+		/* TODO: Remove the following line */
+#ifdef CONFIG_SUPPORT_CHANNEL_INFO
+		nw->band = hw->conf.chandef.chan->band;
+		nw->center_freq = hw->conf.chandef.chan->center_freq;
+#else
+		nw->band = hw->conf.channel->band;
+		nw->center_freq = hw->conf.channel->center_freq;
+#endif
+
+		if (!atomic_read(&nw->d_deauth.delayed_deauth)) {
+			nrc_mac_add_tlv_channel(skb, &chandef);
+		} else {
+#ifdef CONFIG_SUPPORT_CHANNEL_INFO
+			memcpy(&nw->d_deauth.c, &hw->conf.chandef, sizeof(struct cfg80211_chan_def));
+			memcpy(&nw->d_deauth.ch, hw->conf.chandef.chan, sizeof(struct ieee80211_channel));
+			nw->d_deauth.c.chan = &nw->d_deauth.ch;
+#else
+			memcpy(&nw->d_deauth.c, &hw->conf, sizeof(struct ieee80211_conf));
+#endif
+		}
+		/* TODO: band (2G, 5G, etc) and bandwidth (20MHz, 40MHz, etc) */
+	}
+
+	if (changed & IEEE80211_CONF_CHANGE_PS) {
+		nw->ps_enabled = (hw->conf.flags & IEEE80211_CONF_PS);
+		//nw->ps_drv_state = nw->ps_enabled;
+		//nrc_ps_dbg("[%s,L%d] drv_state:%d ps_enable:%d dynamic_ps_timeout:%d\n", __func__, __LINE__, 
+		//			nw->drv_state, nw->ps_enabled, hw->conf.dynamic_ps_timeout);
+
+		if (nw->drv_state == NRC_DRV_PS) {
+			/**
+			 * if the current state is already NRC_DRV_PS,
+			 * there's nothing to do in here even if mac80211 notifies wake-up.
+			 * the actual action to wake up for target will be done by
+			 * nrc_wake_tx_queue() with changing gpio signal.
+			 * (when driver receives a data frame.)
+			 */
+			if (nw->ps_enabled)
+				nrc_ps_dbg("Target is already in deepsleep...\n");
+			else
+				nrc_ps_dbg("Target will wake-up after frame type check.\n");
+
+			goto finish;
+		}
+
+		if (ieee80211_hw_check(hw, SUPPORTS_DYNAMIC_PS)) {
+			if (nw->ps_enabled && (hw->conf.dynamic_ps_timeout > 0)) {
+				mod_timer(&nw->dynamic_ps_timer,
+					jiffies + msecs_to_jiffies(hw->conf.dynamic_ps_timeout));
+				goto finish;
+			}
+		} else {
+			if (nw->ps_enabled || power_save == NRC_PS_MODEMSLEEP) {
+				p = nrc_wim_skb_add_tlv(skb, WIM_TLV_PS_ENABLE,
+						sizeof(struct wim_pm_param), NULL);
+				memset(p, 0, sizeof(struct wim_pm_param));
+				p->ps_mode = power_save;
+				p->ps_enable = nw->ps_enabled;
+				p->ps_wakeup_pin = TARGET_GPIO_FOR_WAKEUP;
+
+				if (power_save >= NRC_PS_DEEPSLEEP_TIM) {
+					p->ps_duration = sleep_duration[0] * (sleep_duration[1] ? 1000 : 1);
+					ieee80211_stop_queues(nw->hw);
+					for (i = 0; i < NRC_QUEUE_MAX; i++) {
+						ntxq = &nw->ntxq[i];
+						skb_queue_purge(&ntxq->queue);
+#ifdef CONFIG_CHECK_DATA_SIZE
+						ntxq->data_size = 0;
+#endif
+					}
+					nrc_ps_dbg("Enter DEEPSLEEP!!!\n");
+					nrc_ps_dbg("sleep_duration: %lld ms\n", p->ps_duration);
+				}
+			}
+		}
+	}
+
+finish:
+	/* i.e., if we added at least one tlv */
+	if (skb->len > sizeof(struct wim)) {
+		gpio_set_value(RPI_GPIO_FOR_PS, 0);
+		nrc_hif_suspend_rx_thread(nw->hif);
+		ret = nrc_xmit_wim_request(nw, skb);
+		if (!ieee80211_hw_check(hw, SUPPORTS_DYNAMIC_PS)) {
+			if (power_save >= NRC_PS_DEEPSLEEP_TIM &&
+				(nw->drv_state != NRC_DRV_PS) && nw->ps_enabled) {
+				nrc_hif_suspend(nw->hif);
+				msleep(100);
+			}
+		}
+		nrc_hif_resume_rx_thread(nw->hif);
+		ieee80211_wake_queues(nw->hw);
+	}
+	else
+		dev_kfree_skb(skb);
+
+	return ret;
+}
+
+static void nrc_mac_configure_filter(struct ieee80211_hw *hw,
+				     unsigned int changed_flags,
+				     unsigned int *total_flags,
+				     u64 multicast)
+{
+
+	*total_flags &= NRC_CONFIGURE_FILTERS;
+
+	/* TODO: talk to target */
+}
+#ifdef CONFIG_SUPPORT_AFTER_KERNEL_3_0_36
+static void nrc_mac_update_p2p_ps(struct sk_buff *skb,
+				  struct ieee80211_vif *vif)
+{
+	int i = 0;
+	u8 ctwin;
+	struct ieee80211_p2p_noa_attr *noa = &vif->bss_conf.p2p_noa_attr;
+	struct wim_noa_param *p;
+
+	if (!vif->p2p)
+		return;
+
+	if (noa->oppps_ctwindow & IEEE80211_P2P_OPPPS_ENABLE_BIT) {
+		ctwin = cpu_to_le32(noa->oppps_ctwindow);
+		nrc_wim_skb_add_tlv(skb, WIM_TLV_P2P_OPPPS, sizeof(u8),
+				&ctwin);
+		nrc_mac_dbg("%s: OppPS, ctwindow(%d)", __func__, ctwin);
+	}
+
+	for (i = 0; i < IEEE80211_P2P_NOA_DESC_MAX; i++) {
+		const struct ieee80211_p2p_noa_desc *desc = &noa->desc[i];
+
+		if (!desc->count || !desc->duration)
+			continue;
+
+		p = nrc_wim_skb_add_tlv(skb, WIM_TLV_P2P_NOA, sizeof(*p),
+					NULL);
+
+		p->index = i;
+		p->count = desc->count;
+		p->start_time = le32_to_cpu(desc->start_time);
+		p->interval = le32_to_cpu(desc->interval);
+		p->duration = le32_to_cpu(desc->duration);
+
+		nrc_mac_dbg(
+			"%s(%d/%d): NoA cnt: %d,st: %d, dur: %d, intv: %d",
+			__func__, noa->index, i, p->count, p->start_time,
+			p->duration, p->interval);
+	}
+}
+#endif
+
+#define BSS_CHANGED_ERP						\
+	(BSS_CHANGED_ERP_CTS_PROT | BSS_CHANGED_ERP_PREAMBLE |	\
+	 BSS_CHANGED_ERP_SLOT)
+
+/* S1G Short Beacon Interval (in TU) */
+#define DEF_CFG_S1G_SHORT_BEACON_COUNT	10
+
+void nrc_mac_bss_info_changed(struct ieee80211_hw *hw,
+				     struct ieee80211_vif *vif,
+				     struct ieee80211_bss_conf *info,
+				     u32 changed)
+{
+	struct nrc *nw = hw->priv;
+	struct sk_buff *skb;
+	int ret;
+
+	//nrc_mac_dbg("%s: changed=0x%x", __func__, changed);
+
+	if (nw->drv_state == NRC_DRV_PS) {
+		if (changed == 0x80309f && atomic_read(&nw->d_deauth.delayed_deauth))
+			memcpy(&nw->d_deauth.b, info, sizeof(struct ieee80211_bss_conf));
+
+		return;
+	}
+
+	skb = nrc_wim_alloc_skb_vif(nw, vif, WIM_CMD_SET, WIM_MAX_SIZE);
+
+	if (changed & BSS_CHANGED_ASSOC) {
+		nw->associated = info->assoc;
+		if (info->assoc) {
+			nrc_bss_assoc(hw, vif, info, skb);
+			if (!disable_cqm) {
+				mod_timer(&nw->bcn_mon_timer,
+					jiffies + msecs_to_jiffies(nw->beacon_timeout));
+			}
+		} else {
+			if (!disable_cqm) {
+				nw->beacon_timeout = 0;
+				del_timer(&nw->bcn_mon_timer);
+			}
+		}
+		nrc_mac_dbg("[BSS_CHANGED_ASSOC] assoc:%d beacon_timeout:%lu",
+			nw->associated, nw->beacon_timeout);
+	}
+	
+	if (changed & BSS_CHANGED_BASIC_RATES) {
+		nrc_mac_dbg("basic_rate: %08x", info->basic_rates);
+		nrc_wim_skb_add_tlv(skb, WIM_TLV_BASIC_RATE,
+				sizeof(info->basic_rates), &info->basic_rates);
+	}
+
+	if (changed & BSS_CHANGED_HT) {
+		nrc_mac_dbg("ht: %08x", info->ht_operation_mode);
+
+		nrc_wim_skb_add_tlv(skb, WIM_TLV_HT_MODE,
+				    sizeof(info->ht_operation_mode),
+				    &info->ht_operation_mode);
+	}
+
+	if (changed & BSS_CHANGED_BSSID) {
+		nrc_mac_dbg("bssid=%pM", info->bssid);
+
+		nrc_wim_skb_add_tlv(skb, WIM_TLV_BSSID, ETH_ALEN,
+				    (void *)info->bssid);
+	}
+
+	if (changed & BSS_CHANGED_BEACON_INT ||
+		changed & BSS_CHANGED_BEACON_ENABLED) {
+		/**
+		 * BSS_CHANGED_BEACON_ENABLED flag is used only for AP and MESH.
+		 */
+		u16 bi, short_bi = 0;
+		u8 dtim_period = info->dtim_period;
+
+		nrc_mac_dbg("beacon: %s, interval=%u, dtim_period:%u",
+				info->enable_beacon ? "enabled" : "disabled",
+				info->beacon_int,
+				info->dtim_period);
+
+		nw->beacon_int = bi = info->beacon_int;
+		if (!disable_cqm) {
+			if (vif->type == NL80211_IFTYPE_STATION) {
+				nw->beacon_timeout = beacon_loss_count * bi;
+				nrc_mac_dbg("[BSS_CHANGED_BEACON_INT] assoc:%d beacon_timeout:%lu",
+					nw->associated, nw->beacon_timeout);
+			}
+		}
+		if ((vif->type == NL80211_IFTYPE_AP || (vif->type == NL80211_IFTYPE_MESH_POINT)) &&
+			nrc_mac_is_s1g(nw) && enable_short_bi) {
+			/**
+			 * AP/MESH : When 'enable_short_bi' is true(AP will send S1G beacons with both(full/minimum) set),
+			 *           the Short Beacon Interval is 'beacon_int' value in hostap/wpa_supplicant conf. file
+			 *           and the Beacon Interval will be 'Short Beacon Interval * 10'.
+			 *           Otherwise, 'beacon_int' is used for the value of Beacon Interval and
+			 *           the Short Beacon Interval is 0.
+			 *     STA : Basically, the beacon_int from mac80211 will be treated as the Beacon Interval in STA.
+			 *           and the Short Beacon Interval value will be extracted from beacons directly in the target
+			 *           after established the Wi-Fi connection.
+			 */
+			short_bi = info->beacon_int;
+			bi = DEF_CFG_S1G_SHORT_BEACON_COUNT * short_bi;
+		}
+
+		nrc_wim_skb_add_tlv(skb, WIM_TLV_BCN_INTV, sizeof(bi), &bi);
+
+		nrc_wim_skb_add_tlv(skb, WIM_TLV_SHORT_BCN_INTV,
+					sizeof(short_bi), &short_bi);
+		nrc_wim_skb_add_tlv(skb, WIM_TLV_DTIM_PERIOD,
+				sizeof(dtim_period), &dtim_period);
+
+		if (changed & BSS_CHANGED_BEACON_ENABLED) {
+			nrc_wim_skb_add_tlv(skb, WIM_TLV_BEACON_ENABLE,
+						sizeof(info->enable_beacon),
+						&info->enable_beacon);
+		}
+	}
+
+	if (changed & BSS_CHANGED_BEACON)
+		nrc_vendor_update_beacon(hw, vif);
+
+#ifdef CONFIG_SUPPORT_AFTER_KERNEL_3_0_36
+	if (changed & BSS_CHANGED_SSID) {
+		nrc_mac_dbg("ssid=%s", info->ssid);
+
+		nrc_wim_skb_add_tlv(skb, WIM_TLV_SSID, info->ssid_len,
+				info->ssid);
+	}
+#endif
+
+	if (changed & BSS_CHANGED_ERP) {
+		struct wim_erp_param *p;
+
+		p = nrc_wim_skb_add_tlv(skb, WIM_TLV_ERP_PARAM, sizeof(*p),
+					NULL);
+		p->use_11b_protection = info->use_cts_prot;
+		p->use_short_preamble = info->use_short_preamble;
+		p->use_short_slot = info->use_short_slot;
+	}
+
+	/* TODO: implement! */
+	if (changed & BSS_CHANGED_CQM)
+		nrc_mac_dbg("%s(changed:%s)", __func__,
+				"BSS_CHANGED_CQM");
+	if (changed & BSS_CHANGED_IBSS)
+		nrc_mac_dbg("%s(changed:%s)", __func__,
+				"BSS_CHANGED_IBSS");
+	if (changed & BSS_CHANGED_ARP_FILTER)
+		nrc_mac_dbg("%s(changed:%s)", __func__,
+				"BSS_CHANGED_ARP_FILTER");
+#if 0
+	if (changed & BSS_CHANGED_QOS)
+		nrc_mac_dbg("%s(changed:%s)", __func__,
+				"BSS_CHANGED_QOS");
+#endif
+	if (changed & BSS_CHANGED_IDLE)
+		nrc_mac_dbg("%s(changed:%s)", __func__,
+				"BSS_CHANGED_IDLE");
+#ifdef CONFIG_SUPPORT_AFTER_KERNEL_3_0_36
+	if (changed & BSS_CHANGED_TXPOWER) {
+		int txpower = info->txpower;
+		uint16_t txpower_type = info->txpower_type;
+		nrc_common_dbg("%s(changed:%s[PW=%d TYPE=%s])", __func__,
+			"BSS_CHANGED_TXPOWER", txpower,
+			txpower_type == TXPWR_LIMIT ? "limit" : txpower_type ? "fixed" : "auto");
+#ifdef CONFIG_SUPPORT_IW_TXPWR
+#if 0 //def CONFIG_SUPPORT_BD
+		/**
+		 * cli_app cannot be used on openWRT system. so use "iw phy nrc80211 set txpower"
+		 * But, txpower could be limited smaller than expected by user in this cse
+		 * since the max value of txpower via iw command should comply the regulations.
+		 * So, it's necessary to change it forcibly in here when txpower type is limit(1) or auto(0).
+		 * Then, the actual txpower will be assigned as the value in bd file finally.
+		 */
+		if (txpower_type < TXPWR_FIXED && txpower < 24) {
+			nrc_common_dbg("%s max txpower was changed (%d -> 30)",__func__, txpower);
+			txpower = 24;
+		}
+#endif /* CONFIG_SUPPORT_BD */
+		if (txpower < 1 || txpower > 30) {
+			nrc_common_dbg("%s invalid txpowr (%d)", __func__, txpower);
+		} else {
+			u32 p = txpower_type;
+			p = (p << 16) | txpower;
+			nrc_wim_skb_add_tlv(skb, WIM_TLV_SET_TXPOWER, sizeof(u32), &p);
+		}
+#endif /* CONFIG_SUPPORT_IW_TXPWR */
+	}
+	if (changed & BSS_CHANGED_P2P_PS) {
+		nrc_mac_dbg("%s(changed:%s)", __func__,
+				"BSS_CHANGED_P2P_PS");
+		nrc_mac_update_p2p_ps(skb, vif);
+	}
+	if (changed & BSS_CHANGED_BEACON_INFO) {
+		/*
+		 * dtim_period for STA is transferred by this.
+		 * but, the target is getting this info from TIM ie in beacon.
+		 */
+		nrc_mac_dbg("%s(changed:%s) dtim_period:%u", __func__,
+				"BSS_CHANGED_BEACON_INFO", info->dtim_period);
+	}
+	if (changed & BSS_CHANGED_BANDWIDTH)
+		nrc_mac_dbg("%s(changed:%s)", __func__,
+				"BSS_CHANGED_BANDWIDTH");
+#ifdef CONFIG_SUPPORT_IFTYPE_OCB
+	if (changed & BSS_CHANGED_OCB)
+		nrc_mac_dbg("%s(changed:%s)", __func__,
+				"BSS_CHANGED_OCB");
+#endif
+#endif
+
+	if (skb->len > sizeof(struct wim)) {
+		ret = nrc_xmit_wim_request(nw, skb);
+		if (ret < 0)
+			nrc_mac_dbg("failed to transmit a wim request");
+	} else {
+		dev_kfree_skb(skb);
+	}
+}
+
+static
+int nrc_mac_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+		    struct ieee80211_sta *sta)
+{
+	struct nrc *nw = hw->priv;
+#ifdef CONFIG_USE_TXQ
+	int i;
+#endif
+
+	nrc_stats_add(sta->addr, 16);
+	nrc_stats_print();
+	nrc_wim_change_sta(nw, vif, sta, WIM_STA_CMD_ADD, 0);
+
+#ifdef CONFIG_USE_TXQ
+	/* Initialize txq driver data.
+	 * Assumptions are:
+	 * (1) per-sta per-tid txq is not in use up to this point (associated).
+	 * (2) EAPOL frames do not resort to txq.
+	 */
+	for (i = 0; i < ARRAY_SIZE(sta->txq); i++)
+		nrc_init_txq(sta->txq[i], vif);
+#endif
+	return 0;
+}
+
+int nrc_mac_sta_remove(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+		       struct ieee80211_sta *sta)
+{
+	nrc_stats_del(sta->addr);
+	nrc_stats_print();
+	nrc_wim_change_sta(hw->priv, vif, sta, WIM_STA_CMD_REMOVE, 0);
+
+	return 0;
+}
+
+static void nrc_init_sta_ba_session(struct ieee80211_sta *sta)
+{
+	struct nrc_sta *i_sta = NULL;
+	int i;
+
+	if (sta) {
+		i_sta = to_i_sta(sta);
+		if (i_sta) {
+			for (i=0 ; i < NRC_MAX_TID; i++) {
+				i_sta->tx_ba_session[i] = IEEE80211_BA_NONE;
+				i_sta->ba_req_last_jiffies[i] = 0;
+			}
+		}
+	}
+}
+
+#ifdef CONFIG_SUPPORT_AFTER_KERNEL_3_0_36
+static
+int nrc_wim_change_sta_state(struct nrc *nw, struct ieee80211_vif *vif,
+		struct ieee80211_sta *sta, int new_state)
+{
+	int state = WIM_STA_CMD_STATE_NOTEXIST;
+
+	switch (new_state) {
+		case IEEE80211_STA_NOTEXIST:
+			state = WIM_STA_CMD_STATE_NOTEXIST;
+			break;
+		case IEEE80211_STA_NONE:
+			state = WIM_STA_CMD_STATE_NONE;
+			break;
+		case IEEE80211_STA_AUTH:
+			state = WIM_STA_CMD_STATE_AUTH;
+			break;
+		case IEEE80211_STA_ASSOC:
+			state = WIM_STA_CMD_STATE_ASSOC;
+			break;
+		case IEEE80211_STA_AUTHORIZED:
+			state = WIM_STA_CMD_STATE_AUTHORIZED;
+
+			/* 6/14/2021 shinwoo: renewed auto BA session (on connection) feature */
+			if (auto_ba) {
+				nrc_dbg(NRC_DBG_STATE, "%s: Setting up BA session for TID 0 with peer (%pM)",
+					__func__, sta->addr);
+				nrc_init_sta_ba_session(sta);
+				nw->ampdu_supported = true;
+				nw->ampdu_reject = false;
+			} else {
+				nw->ampdu_supported = false;
+				nw->ampdu_reject = true;
+			}
+			break;
+	}
+
+	return nrc_wim_change_sta(nw, vif, sta, state, 0);
+}
+#endif
+
+#ifdef CONFIG_SUPPORT_AFTER_KERNEL_3_0_36
+static
+int nrc_mac_sta_state(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+		      struct ieee80211_sta *sta,
+		      enum ieee80211_sta_state old_state,
+		      enum ieee80211_sta_state new_state)
+{
+	struct nrc_vif *i_vif = to_i_vif(vif);
+	struct nrc_sta *i_sta = to_i_sta(sta);
+	unsigned long flags;
+	struct nrc_sta_handler *h;
+	struct nrc *nw = (struct nrc*)hw->priv;
+
+	nrc_dbg(NRC_DBG_STATE, "%s: sta:%pM, %d->%d", __func__, sta->addr,
+		old_state, new_state);
+
+	i_sta->state = new_state;
+
+#define state_changed(old, new) \
+(old_state == IEEE80211_STA_##old && new_state == IEEE80211_STA_##new)
+
+	if (state_changed(NOTEXIST, NONE)) {
+
+		memset(i_sta, 0, sizeof(*i_sta));
+		i_sta->nw = nw;
+		i_sta->vif = vif;
+
+		INIT_LIST_HEAD(&i_sta->list);
+
+		spin_lock_irqsave(&i_vif->preassoc_sta_lock, flags);
+		list_add_tail(&i_sta->list, &i_vif->preassoc_sta_list);
+		spin_unlock_irqrestore(&i_vif->preassoc_sta_lock, flags);
+
+	} else if (state_changed(NONE, AUTH)) {
+
+	} else if (state_changed(AUTH, ASSOC)) {
+
+		spin_lock_irqsave(&i_vif->preassoc_sta_lock, flags);
+		list_del_init(&i_sta->list);
+		spin_unlock_irqrestore(&i_vif->preassoc_sta_lock, flags);
+
+		i_sta->vif = vif;
+		nrc_mac_sta_add(hw, vif, sta);
+
+	} else if (state_changed(ASSOC, AUTH)) {
+		if (!atomic_read(&nw->d_deauth.delayed_deauth))
+			nrc_mac_sta_remove(hw, vif, sta);
+	}
+
+	if (!atomic_read(&nw->d_deauth.delayed_deauth))
+		nrc_wim_change_sta_state(nw, vif, sta, new_state);
+
+	for (h = &__sta_h_start; h < &__sta_h_end; h++)
+		h->sta_state(hw, vif, sta, old_state, new_state);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_SUPPORT_AFTER_KERNEL_3_0_36
+static void nrc_mac_sta_pre_rcu_remove(struct ieee80211_hw *hw,
+				       struct ieee80211_vif *vif,
+				       struct ieee80211_sta *sta)
+{
+	struct nrc_vif *i_vif = to_i_vif(vif);
+	struct nrc_sta *i_sta = to_i_sta(sta);
+	unsigned long flags;
+
+	spin_lock_irqsave(&i_vif->preassoc_sta_lock, flags);
+	list_del_init(&i_sta->list);
+	spin_unlock_irqrestore(&i_vif->preassoc_sta_lock, flags);
+}
+#endif
+
+
+static void nrc_mac_sta_notify(struct ieee80211_hw *hw,
+			       struct ieee80211_vif *vif,
+			       enum sta_notify_cmd cmd,
+			       struct ieee80211_sta *sta)
+{
+	nrc_wim_change_sta(hw->priv, vif, sta, WIM_STA_CMD_NOTIFY,
+			   cmd == STA_NOTIFY_SLEEP);
+}
+
+
+static int nrc_mac_set_tim(struct ieee80211_hw *hw, struct ieee80211_sta *sta,
+			   bool set)
+{
+	struct nrc *nw = hw->priv;
+	struct nrc_sta *i_sta = to_i_sta(sta);
+	struct sk_buff *skb;
+	struct wim_tim_param *tim;
+
+	if (WARN_ON(i_sta->vif == NULL))
+		return -EINVAL;
+
+	skb = nrc_wim_alloc_skb_vif(nw, i_sta->vif, WIM_CMD_SET,
+					WIM_MAX_SIZE);
+
+	tim = nrc_wim_skb_add_tlv(skb, WIM_TLV_TIM_PARAM, sizeof(*tim), NULL);
+	tim->aid = sta->aid;
+	tim->set = set;
+
+	if (!nrc_mac_is_s1g(nw)) {
+		struct sk_buff *b = ieee80211_beacon_get_template(hw,
+				i_sta->vif, NULL);
+		if (b) {
+			nrc_wim_skb_add_tlv(skb, WIM_TLV_BEACON, b->len,
+					b->data);
+			dev_kfree_skb_any(b);
+		}
+	}
+
+	return nrc_xmit_wim_request(nw, skb);
+}
+
+#ifdef CONFIG_SUPPORT_CHANNEL_INFO
+int nrc_mac_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+		    u16 ac, const struct ieee80211_tx_queue_params *params)
+#else
+int nrc_mac_conf_tx(struct ieee80211_hw *hw,
+		    u16 ac, const struct ieee80211_tx_queue_params *params)
+#endif
+{
+	struct nrc *nw = hw->priv;
+	struct sk_buff *skb;
+	static struct wim_tx_queue_param tqp[NRC_QUEUE_MAX];
+#ifdef CONFIG_SUPPORT_AFTER_KERNEL_3_0_36
+#else
+	struct ieee80211_vif *vif = nw->vif[0];
+#endif
+
+#ifdef CONFIG_SUPPORT_AFTER_KERNEL_3_0_36
+	ac = vif->hw_queue[ac];
+#endif
+
+	if (atomic_read(&nw->d_deauth.delayed_deauth))
+		memcpy(&nw->d_deauth.tqp[ac], params, sizeof(struct ieee80211_tx_queue_params));
+
+	if (nw->drv_state >= NRC_DRV_RUNNING) {
+		if (tqp[ac].txop != params->txop || tqp[ac].cw_min != params->cw_min ||
+			tqp[ac].cw_max != params->cw_max || tqp[ac].aifsn != params->aifs ||
+			tqp[ac].uapsd != params->uapsd || tqp[ac].ac != ac) {
+			skb = nrc_wim_alloc_skb_vif(nw, vif, WIM_CMD_SET, tlv_len(sizeof(struct wim_tx_queue_param)));
+			tqp[ac].ac = ac;
+			tqp[ac].txop = params->txop;
+			tqp[ac].cw_min = params->cw_min;
+			tqp[ac].cw_max = params->cw_max;
+			tqp[ac].aifsn = params->aifs;
+			tqp[ac].uapsd = params->uapsd;
+			nrc_wim_skb_add_tlv(skb, WIM_TLV_TXQ_PARAM, sizeof(struct wim_tx_queue_param), &tqp[ac]);
+
+			nrc_mac_dbg("%s: ac=%d txop=%d cw_min=%d cw_max=%d aifs=%d uapsd=%d", __func__,
+				ac, params->txop, params->cw_min, params->cw_max, params->aifs, params->uapsd);
+
+			return nrc_xmit_wim_request(nw, skb);
+		}
+	}
+	return 0;
+}
+
+static int nrc_mac_get_survey(struct ieee80211_hw *hw, int idx,
+			      struct survey_info *survey)
+{
+	struct ieee80211_conf *conf = &hw->conf;
+
+	nrc_mac_dbg("%s (idx=%d)", __func__, idx);
+
+	if (idx != 0)
+		return -ENOENT;
+
+	/* Current channel */
+#ifdef CONFIG_SUPPORT_CHANNEL_INFO
+	survey->channel = conf->chandef.chan;
+#else
+	survey->channel = conf->channel;
+#endif
+
+	/*
+	 * Magically conjured noise level
+	 * --- this is only ok for simulated hardware.
+	 *
+	 * A real driver which cannot determine the real channel noise MUST NOT
+	 * report any noise, especially not a magically conjured one :-)
+	 */
+	survey->filled = SURVEY_INFO_NOISE_DBM;
+	survey->noise = -92;
+
+	return 0;
+}
+
+#ifdef CONFIG_USE_IEEE80211_AMPDU_PARAMS
+static int nrc_mac_ampdu_action(struct ieee80211_hw *hw,
+				struct ieee80211_vif *vif,
+				struct ieee80211_ampdu_params *params)
+#else
+#ifdef CONFIG_SUPPORT_NEW_AMPDU_ACTION
+static int nrc_mac_ampdu_action(struct ieee80211_hw *hw,
+				struct ieee80211_vif *vif,
+				enum ieee80211_ampdu_mlme_action action,
+				struct ieee80211_sta *sta,
+				u16 tid,
+				u16 *ssn,
+				u8 buf_size,
+				bool amsdu)
+#else
+static int nrc_mac_ampdu_action(struct ieee80211_hw *hw,
+				struct ieee80211_vif *vif,
+				enum ieee80211_ampdu_mlme_action action,
+				struct ieee80211_sta *sta,
+				u16 tid,
+				u16 *ssn,
+				u8 buf_size)
+#endif
+#endif
+{
+	struct nrc *nw = hw->priv;
+	struct nrc_sta *i_sta = NULL;
+
+#ifdef CONFIG_USE_IEEE80211_AMPDU_PARAMS
+	enum ieee80211_ampdu_mlme_action action = params->action;
+	struct ieee80211_sta *sta = params->sta;
+	u16 tid = params->tid;
+#endif
+
+	if (!sta || tid >= NRC_MAX_TID) {
+		nrc_dbg(NRC_DBG_MAC, "%s: sta is NULL", __func__);
+		return -EOPNOTSUPP;
+	}
+
+	i_sta = to_i_sta(sta);
+	nrc_dbg(NRC_DBG_MAC, "%s: peer MAC(%pM) TID(%d)", __func__, sta->addr, tid);
+
+	switch (action) {
+	case IEEE80211_AMPDU_TX_START:
+		nrc_dbg(NRC_DBG_MAC, "%s: IEEE80211_AMPDU_TX_START", __func__);
+		if (!nw->ampdu_supported || !sta->ht_cap.ht_supported)
+			return -EOPNOTSUPP;
+
+		if (nrc_wim_ampdu_action(nw, vif, WIM_AMPDU_TX_START, sta, tid))
+			return -EOPNOTSUPP;
+
+		i_sta->tx_ba_session[tid] = IEEE80211_BA_REQUEST;
+		ieee80211_start_tx_ba_cb_irqsafe(vif, sta->addr, tid);
+		break;
+#ifdef CONFIG_SUPPORT_AFTER_KERNEL_3_0_36
+	case IEEE80211_AMPDU_TX_STOP_FLUSH:
+		nrc_dbg(NRC_DBG_MAC, "%s: IEEE80211_AMPDU_TX_STOP_FLUSH", __func__);
+		i_sta->tx_ba_session[tid] = IEEE80211_BA_CLOSE;
+		break;
+	case IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:
+		nrc_dbg(NRC_DBG_MAC, "%s: IEEE80211_AMPDU_TX_STOP_FLUSH_CONT", __func__);
+		i_sta->tx_ba_session[tid] = IEEE80211_BA_CLOSE;
+		break;
+	case IEEE80211_AMPDU_TX_STOP_CONT:
+		nrc_dbg(NRC_DBG_MAC, "%s: IEEE80211_AMPDU_TX_STOP_CONT", __func__);
+		if (nrc_wim_ampdu_action(nw, vif, WIM_AMPDU_TX_STOP, sta, tid))
+			return -EOPNOTSUPP;
+		i_sta->tx_ba_session[tid] = IEEE80211_BA_REJECT;
+		i_sta->ba_req_last_jiffies[tid] = jiffies;
+		ieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);
+		// nrc_set_auto_ba(false);
+		break;
+#endif
+	case IEEE80211_AMPDU_TX_OPERATIONAL:
+		nrc_dbg(NRC_DBG_MAC, "%s: IEEE80211_AMPDU_TX_OPERATIONAL", __func__);
+		i_sta->tx_ba_session[tid] = IEEE80211_BA_ACCEPT;
+		if (nrc_wim_ampdu_action(nw, vif, WIM_AMPDU_TX_OPERATIONAL, sta, tid))
+			return -EOPNOTSUPP;
+
+		// nrc_set_auto_ba(true);
+		return 0;
+	case IEEE80211_AMPDU_RX_START:
+		nrc_dbg(NRC_DBG_MAC, "%s: IEEE80211_AMPDU_RX_START", __func__);
+		if (nw->ampdu_reject) {
+			nrc_dbg(NRC_DBG_MAC, "%s: Reject AMPDU", __func__);
+			return -EOPNOTSUPP;
+		}
+		return 0;
+	case IEEE80211_AMPDU_RX_STOP:
+		nrc_dbg(NRC_DBG_MAC, "%s: IEEE80211_AMPDU_RX_STOP", __func__);
+		if (nw->ampdu_reject) {
+			nrc_dbg(NRC_DBG_MAC, "%s: Reject AMPDU", __func__);
+			return -EOPNOTSUPP;
+		}
+		return 0;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+#if defined(CONFIG_USE_IEEE80211_AMPDU_PARAMS)
+	params->amsdu = nw->amsdu_supported;
+#endif
+	return 0;
+}
+
+static void change_scan_mode(struct nrc *nw, enum NRC_SCAN_MODE new_mode)
+{
+	mutex_lock(&nw->state_mtx);
+	nw->scan_mode = new_mode;
+	mutex_unlock(&nw->state_mtx);
+}
+
+void scan_complete(struct ieee80211_hw *hw, bool aborted)
+{
+#ifdef CONFIG_USE_CFG80211_SCAN_INFO
+	struct cfg80211_scan_info info = {
+		.aborted = aborted,
+	};
+
+	ieee80211_scan_completed(hw, &info);
+#else
+	ieee80211_scan_completed(hw, aborted);
+#endif
+}
+
+static void nrc_cancel_hw_scan(struct ieee80211_hw *hw,
+			       struct ieee80211_vif *vif)
+{
+	struct nrc *nw = hw->priv;
+	struct sk_buff *skb;
+#ifdef CONFIG_USE_SCAN_TIMEOUT
+	struct nrc_vif *i_vif = to_i_vif(vif);
+
+	cancel_delayed_work_sync(&i_vif->scan_timeout);
+#endif
+
+	skb = nrc_wim_alloc_skb_vif(nw, vif, WIM_CMD_SCAN_STOP, 0);
+	nrc_xmit_wim_request(nw, skb);
+
+	change_scan_mode(nw, NRC_SCAN_MODE_IDLE);
+
+	scan_complete(hw, false);
+}
+
+void nrc_mac_cancel_hw_scan(struct ieee80211_hw *hw,
+					struct ieee80211_vif *vif)
+{
+	struct nrc *nw = hw->priv;
+
+	if (nw->scan_mode == NRC_SCAN_MODE_IDLE)
+		return;
+
+	nrc_cancel_hw_scan(hw, vif);
+}
+
+static int
+__nrc_mac_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+		  struct cfg80211_scan_request *req,
+		  struct ieee80211_scan_ies *ies)
+{
+	struct nrc *nw = hw->priv;
+	int scan_to = 30000; /* msec */
+#ifdef CONFIG_USE_SCAN_TIMEOUT
+	struct nrc_vif *i_vif = to_i_vif(vif);
+#endif
+
+	if (nw->block_frame ||
+			(int)atomic_read(&nw->fw_state) != NRC_FW_ACTIVE) {
+		nrc_mac_dbg("%s Scan Cancelled", __func__);
+		return -EBUSY;
+	}
+
+	if (nw->scan_mode != NRC_SCAN_MODE_IDLE)
+		nrc_mac_cancel_hw_scan(hw, vif);
+
+	scan_to += 120 * req->n_channels;
+
+	nrc_wim_hw_scan(nw, vif, req, ies);
+
+	change_scan_mode(nw, NRC_SCAN_MODE_SCANNING);
+
+#ifdef CONFIG_USE_SCAN_TIMEOUT
+	queue_delayed_work(nw->workqueue, &i_vif->scan_timeout,
+			msecs_to_jiffies(scan_to));
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_USE_NEW_SCAN_REQ
+static int
+nrc_mac_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+		struct ieee80211_scan_request *req)
+{
+	return __nrc_mac_hw_scan(hw, vif, &req->req, &req->ies);
+}
+
+#else
+static int
+nrc_mac_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+		struct cfg80211_scan_request *req)
+{
+	return __nrc_mac_hw_scan(hw, vif, req, NULL);
+}
+#endif
+
+#ifdef CONFIG_USE_SCAN_TIMEOUT
+static void nrc_mac_scan_timeout(struct work_struct *work)
+{
+	struct nrc_vif *i_vif;
+	struct sk_buff *skb;
+
+	i_vif = container_of(work, struct nrc_vif, scan_timeout.work);
+
+	skb = nrc_wim_alloc_skb_vif(i_vif->nw, to_ieee80211_vif(i_vif),
+				    WIM_CMD_SCAN_STOP, 0);
+
+	nrc_xmit_wim_request(i_vif->nw, skb);
+
+	change_scan_mode(i_vif->nw, NRC_SCAN_MODE_IDLE);
+
+	scan_complete(i_vif->nw->hw, true);
+}
+#endif
+
+static int
+nrc_mac_set_bitrate_mask(struct ieee80211_hw *hw,
+				   struct ieee80211_vif *vif,
+				   const struct cfg80211_bitrate_mask *mask)
+{
+	int i, ret;
+	uint8_t mcs_mask, mcs_level;
+	struct nrc *nw = hw->priv;
+	struct sk_buff *skb;
+	enum nl80211_band band = NL80211_BAND_2GHZ;
+
+	nrc_mac_dbg("%s legacy 0x%8X 0x%8X 0x%2X 0x%2X", __func__,
+			mask->control[0].legacy,
+			mask->control[1].legacy,
+			mask->control[0].ht_mcs[0],
+			mask->control[1].ht_mcs[0]);
+
+	if (mask->control[band].ht_mcs[0] == 0xFF)
+		band = NL80211_BAND_5GHZ;
+	mcs_mask = mask->control[band].ht_mcs[0] & 0xFF;
+
+	if (!mcs_mask) {
+		mcs_level = 8;
+	} else {
+		for (i = 0; i < 8; i++) {
+			if (mcs_mask & 0x1) {
+				mcs_level = (uint8_t) i;
+				nrc_mac_dbg("%s mcs level is %d", __func__,
+						   mcs_level);
+				break;
+			}
+			mcs_mask = mcs_mask>>1;
+		}
+	}
+	skb = nrc_wim_alloc_skb_vif(nw, vif, WIM_CMD_SET, WIM_MAX_SIZE);
+	nrc_wim_skb_add_tlv(skb, WIM_TLV_MCS, sizeof(mcs_level), &mcs_level);
+	ret = nrc_xmit_wim_request(nw, skb);
+
+	return ret;
+}
+
+#ifndef NRC_BUILD_USE_HWSCAN
+static void nrc_mac_sw_scan(struct ieee80211_hw *hw,
+			    struct ieee80211_vif *vif,
+			    const u8 *mac_addr)
+{
+	struct nrc *nw = hw->priv;
+
+	nrc_mac_dbg("%s", __func__);
+
+	mutex_lock(&nw->state_mtx);
+
+	if (nw->scan_mode == NRC_SCAN_MODE_IDLE) {
+		nrc_mac_dbg("two sw_scans detected!");
+		goto out;
+	}
+
+	nw->scan_mode = NRC_SCAN_MODE_SCANNING;
+ out:
+	mutex_unlock(&nw->state_mtx);
+}
+
+static void nrc_mac_sw_scan_complete(struct ieee80211_hw *hw,
+				     struct ieee80211_vif *vif)
+{
+	struct nrc *nw = hw->priv;
+
+	nrc_mac_dbg("%s", __func__);
+
+	mutex_lock(&nw->state_mtx);
+
+	if (nw->scan_mode == NRC_SCAN_MODE_SCANNING) {
+		nrc_mac_dbg("Scan has not started!");
+		goto out;
+	}
+
+	nw->scan_mode = NRC_SCAN_MODE_IDLE;
+ out:
+	mutex_unlock(&nw->state_mtx);
+}
+#endif
+
+#ifdef CONFIG_SUPPORT_NEW_FLUSH
+static void nrc_mac_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+			  u32 queues, bool drop)
+#else
+#ifdef CONFIG_SUPPORT_AFTER_KERNEL_3_0_36
+static void nrc_mac_flush(struct ieee80211_hw *hw, u32 queues, bool drop)
+#else
+static void nrc_mac_flush(struct ieee80211_hw *hw, bool drop)
+#endif
+#endif
+{
+
+}
+
+#ifdef CONFIG_SUPPORT_TX_FRAMES_PENDING
+static bool nrc_mac_tx_frames_pending(struct ieee80211_hw *hw)
+{
+
+#ifdef CONFIG_USE_TXQ
+	return (nrc_txq_pending(hw) > 0);
+#else
+	return false;
+#endif
+}
+#endif
+
+static inline u64 nrc_mac_get_tsf_raw(void)
+{
+	return ktime_to_us(ktime_get_real());
+}
+
+static __le64 _nrc_mac_get_tsf(struct nrc *nw)
+{
+	u64 now = nrc_mac_get_tsf_raw();
+
+	return cpu_to_le64(now + nw->tsf_offset);
+}
+
+#ifdef CONFIG_SUPPORT_AFTER_KERNEL_3_0_36
+static u64 nrc_mac_get_tsf(struct ieee80211_hw *hw,
+			   struct ieee80211_vif *vif)
+#else
+static u64 nrc_mac_get_tsf(struct ieee80211_hw *hw)
+#endif
+{
+	struct nrc *nw = hw->priv;
+
+	return le64_to_cpu(_nrc_mac_get_tsf(nw));
+}
+
+#ifdef CONFIG_SUPPORT_AFTER_KERNEL_3_0_36
+static void nrc_mac_set_tsf(struct ieee80211_hw *hw,
+			    struct ieee80211_vif *vif, u64 tsf)
+#else
+static void nrc_mac_set_tsf(struct ieee80211_hw *hw,
+			    u64 tsf)
+#endif
+{
+}
+
+#ifdef CONFIG_SUPPORT_AFTER_KERNEL_3_0_36
+static void nrc_mac_get_et_strings(struct ieee80211_hw *hw,
+				   struct ieee80211_vif *vif,
+				   u32 sset, u8 *data)
+{
+	if (sset == ETH_SS_STATS)
+		memcpy(data, *nrc_gstrings_stats, sizeof(nrc_gstrings_stats));
+}
+
+static int nrc_mac_get_et_sset_count(struct ieee80211_hw *hw,
+				     struct ieee80211_vif *vif,
+				     int sset)
+{
+	if (sset == ETH_SS_STATS)
+		return ARRAY_SIZE(nrc_gstrings_stats);
+	return 0;
+}
+
+static void nrc_mac_get_et_stats(struct ieee80211_hw *hw,
+				 struct ieee80211_vif *vif,
+				 struct ethtool_stats *stats,
+				 u64 *data)
+{
+
+}
+#endif
+
+static int nrc_mac_set_rts_threshold(struct ieee80211_hw *hw, u32 value)
+{
+	struct sk_buff *skb;
+	struct nrc *nw = hw->priv;
+	struct ieee80211_vif *vif = nw->vif[0];
+
+	skb = nrc_wim_alloc_skb_vif(nw, vif, WIM_CMD_SET, WIM_MAX_SIZE);
+	if (!skb)
+		return -ENOMEM;
+
+	nrc_mac_dbg("RTS Threshold: %u", value);
+	nrc_wim_skb_add_tlv(skb, WIM_TLV_RTS_THREASHOLD, sizeof(u32), &value);
+	nrc_xmit_wim_request(nw, skb);
+	return 0;
+}
+
+static int nrc_mac_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,
+			   struct ieee80211_vif *vif, struct ieee80211_sta *sta,
+			   struct ieee80211_key_conf *key)
+{
+	struct nrc *nw = hw->priv;
+	struct nrc_vif *i_vif = to_i_vif(vif);
+	int vif_id = i_vif->index;
+	int ret;
+
+	if (atomic_read(&nw->d_deauth.delayed_deauth)) {
+		if (key->flags & IEEE80211_KEY_FLAG_PAIRWISE)
+			memcpy(&nw->d_deauth.p, key, sizeof(struct ieee80211_key_conf));
+		else
+			memcpy(&nw->d_deauth.g, key, sizeof(struct ieee80211_key_conf));
+		return 0;
+	}
+
+	if (!(nw->cap.vif_caps[vif_id].cap_mask & WIM_SYSTEM_CAP_HWSEC)) {
+		pr_err("failed to set caps");
+		return 1;
+	}
+
+	if (sta == NULL && vif->type == NL80211_IFTYPE_STATION &&
+			!(key->flags & IEEE80211_KEY_FLAG_PAIRWISE)) {
+		sta = ieee80211_find_sta(vif, vif->bss_conf.bssid);
+	}
+
+	if (cmd == DISABLE_KEY) {
+		nrc_mac_dbg("%s delete key (flag:%u, cipher:%u)",
+			__func__, key->flags, key->cipher);
+
+		if ((key->flags & IEEE80211_KEY_FLAG_PAIRWISE) && sta == NULL) {
+			nrc_mac_dbg("%s delete ptk but sta is null! (key->flag:%u)",
+				__func__, key->flags);
+			return 1;
+		}
+
+		if (key->cipher == WLAN_CIPHER_SUITE_AES_CMAC ||
+			key->cipher == WLAN_CIPHER_SUITE_BIP_GMAC_128 ||
+			key->cipher == WLAN_CIPHER_SUITE_BIP_GMAC_256) {
+			nrc_mac_dbg("%s delete key but not supported key cipher (key->cipher:%u)",
+				__func__, key->cipher);
+			return 1;
+		}
+	}
+
+	if (sw_enc) {
+		nrc_mac_dbg("SW Encryption for vif type=%d", vif->type);
+		return 1;
+	}
+
+	/* Record key information to per-STA driver data structure for RX */
+	/* TODO: DISABLE_KEY -> later */
+	if (cmd == SET_KEY) {
+		/* HW does NOT Support BIP until now => need to SW-based Crypto => return 1 for this */
+		if (key->cipher == WLAN_CIPHER_SUITE_AES_CMAC ||
+			key->cipher == WLAN_CIPHER_SUITE_BIP_GMAC_128 ||
+			key->cipher == WLAN_CIPHER_SUITE_BIP_GMAC_256) {
+			nw->cipher_pairwise = key->cipher; //for PMF deauth for keep alive on AP
+			key->flags |= IEEE80211_KEY_FLAG_SW_MGMT_TX;
+			return 1;
+		}
+
+		if (sta) {
+			struct nrc_sta *i_sta = to_i_sta(sta);
+
+			if (key->flags & IEEE80211_KEY_FLAG_PAIRWISE)
+				i_sta->ptk = key;
+			else {
+				i_sta->gtk = key;
+				if (key->cipher == WLAN_CIPHER_SUITE_WEP40 ||
+				    key->cipher == WLAN_CIPHER_SUITE_WEP104)
+					i_sta->ptk = key;
+			}
+		} else
+			WARN_ON(!(vif->type == NL80211_IFTYPE_AP ||
+				  vif->type == NL80211_IFTYPE_P2P_GO));
+	}
+
+	ret = nrc_wim_install_key(nw, cmd, vif, sta, key);
+	if (ret < 0)
+		ret = 1; /* fallback to software crypto */
+
+	key->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;	/* IV by the stack */
+#if defined(CONFIG_SUPPORT_KEY_RESERVE_TAILROOM)
+	/* Check whether MMIC will be generated by HW */
+	if (nw->cap.cap_mask & WIM_SYSTEM_CAP_HWSEC_OFFL)
+		key->flags |= IEEE80211_KEY_FLAG_RESERVE_TAILROOM;
+#endif
+	return ret;
+}
+
+#ifdef CONFIG_SUPPORT_AFTER_KERNEL_3_0_36
+static void nrc_mac_set_default_unicast_key(struct ieee80211_hw *hw,
+					    struct ieee80211_vif *vif,
+					    int keyidx)
+{
+
+}
+#endif
+
+static void nrc_mac_channel_policy(void *data, u8 *mac,
+		struct ieee80211_vif *vif)
+{
+	struct sk_buff *skb;
+	struct nrc_vif *i_vif = to_i_vif(vif);
+	struct nrc *nw = i_vif->nw;
+#ifdef CONFIG_SUPPORT_CHANNEL_INFO
+	struct cfg80211_chan_def *chan_to_follow =
+		(struct cfg80211_chan_def *)data;
+	struct wireless_dev *wdev = ieee80211_vif_to_wdev(vif);
+#else
+	struct ieee80211_conf *chan_to_follow =
+		(struct ieee80211_conf *)data;
+	struct wireless_dev *wdev = i_vif->dev->ieee80211_ptr;
+#endif
+
+	if (!wdev)
+		return;
+
+#ifdef CONFIG_SUPPORT_CHANNEL_INFO
+	if (wdev->chandef.chan &&
+		wdev->chandef.chan->center_freq ==
+		chan_to_follow->chan->center_freq)
+#else
+	if (wdev->channel &&
+		wdev->channel->center_freq ==
+		chan_to_follow->channel->center_freq)
+#endif
+		return;
+
+	if (!(vif->type == NL80211_IFTYPE_STATION ||
+		vif->type == NL80211_IFTYPE_MESH_POINT))
+		return;
+
+	if (vif->bss_conf.assoc)
+		return;
+
+	skb = nrc_wim_alloc_skb_vif(nw, vif, WIM_CMD_SET, WIM_MAX_SIZE);
+
+	if (!skb)
+		return;
+
+	nrc_mac_add_tlv_channel(skb, chan_to_follow);
+	nrc_xmit_wim_request(nw, skb);
+}
+
+#ifdef CONFIG_SUPPORT_AFTER_KERNEL_3_0_36
+static int nrc_mac_roc(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+		struct ieee80211_channel *chan, int duration,
+		enum ieee80211_roc_type type)
+#else
+static int nrc_mac_roc(struct ieee80211_hw *hw, struct ieee80211_channel *chan,
+		enum nl80211_channel_type type, int duration)
+#endif
+{
+	struct nrc *nw = hw->priv;
+	struct sk_buff *skb;
+#ifdef CONFIG_SUPPORT_CHANNEL_INFO
+	struct cfg80211_chan_def chandef = {0};
+	struct cfg80211_chan_def *cdef;
+#else
+	struct ieee80211_conf chandef = {0};
+	struct ieee80211_conf *cdef;
+	struct ieee80211_vif *vif = nw->vif[0];
+#endif
+
+	nrc_mac_dbg("%s, ch=%d, dur=%d", __func__,
+			chan->center_freq, duration);
+
+	skb = nrc_wim_alloc_skb_vif(nw, vif, WIM_CMD_SET,
+			tlv_len(sizeof(u16))
+			+ tlv_len(ETH_ALEN));
+
+	if (!skb)
+		return -EINVAL;
+
+#ifdef CONFIG_SUPPORT_CHANNEL_INFO
+	if (!hw->conf.chandef.chan) {
+		chandef.chan = chan;
+		chandef.width = NL80211_CHAN_WIDTH_20;
+		cdef = &chandef;
+	} else
+		cdef = &hw->conf.chandef;
+
+	nrc_mac_add_tlv_channel(skb, cdef);
+#else
+	if (!hw->conf.channel) {
+		chandef.channel = chan;
+		cdef = &chandef;
+	} else
+		cdef = &hw->conf;
+
+	nrc_mac_add_tlv_channel(skb, cdef);
+#endif
+	nrc_xmit_wim_request(nw, skb);
+
+	ieee80211_ready_on_channel(hw);
+
+	nw->band = chan->band;
+	nw->center_freq = chan->center_freq;
+
+	ieee80211_queue_delayed_work(hw, &nw->roc_finish,
+			msecs_to_jiffies(duration));
+
+#ifdef CONFIG_SUPPORT_ITERATE_INTERFACE
+	ieee80211_iterate_interfaces(nw->hw, IEEE80211_IFACE_ITER_ACTIVE,
+			nrc_mac_channel_policy, cdef);
+#else
+	ieee80211_iterate_active_interfaces(nw->hw,
+			nrc_mac_channel_policy, cdef);
+#endif
+
+	return 0;
+}
+
+#if KERNEL_VERSION(5, 4, 0) <= NRC_TARGET_KERNEL_VERSION
+static int nrc_mac_cancel_roc(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
+#else
+static int nrc_mac_cancel_roc(struct ieee80211_hw *hw)
+#endif
+{
+	struct nrc *nw = hw->priv;
+
+	nrc_mac_dbg("%s", __func__);
+	cancel_delayed_work_sync(&nw->roc_finish);
+
+	return 0;
+}
+
+#ifdef CONFIG_USE_CHANNEL_CONTEXT
+static int nrc_mac_add_chanctx(struct ieee80211_hw *hw,
+		struct ieee80211_chanctx_conf *ctx)
+{
+	nrc_mac_dbg("%s, %d MHz/width: %d/cfreqs:%d/%d MHz\n",
+			__func__,
+			ctx->def.chan->center_freq, ctx->def.width,
+			ctx->def.center_freq1, ctx->def.center_freq2);
+	return 0;
+}
+
+static void nrc_mac_remove_chanctx(struct ieee80211_hw *hw,
+		struct ieee80211_chanctx_conf *ctx)
+{
+	nrc_mac_dbg("%s, %d MHz/width: %d/cfreqs:%d/%d MHz\n",
+			__func__,
+			ctx->def.chan->center_freq, ctx->def.width,
+			ctx->def.center_freq1, ctx->def.center_freq2);
+}
+
+static void nrc_mac_change_chanctx(struct ieee80211_hw *hw,
+		struct ieee80211_chanctx_conf *ctx,
+		u32 changed)
+{
+	nrc_mac_dbg("%s, %d MHz/width: %d/cfreqs:%d/%d MHz\n",
+			__func__,
+			ctx->def.chan->center_freq, ctx->def.width,
+			ctx->def.center_freq1, ctx->def.center_freq2);
+}
+
+static int nrc_mac_assign_vif_chanctx(struct ieee80211_hw *hw,
+		struct ieee80211_vif *vif,
+		struct ieee80211_chanctx_conf *ctx)
+{
+	struct nrc *nw = hw->priv;
+	struct sk_buff *skb;
+
+	nrc_mac_dbg("%s, vif[type:%d, addr:%pM] %d MHz/width: %d/cfreqs:%d/%d MHz\n",
+			__func__, vif->type, vif->addr,
+			ctx->def.chan->center_freq, ctx->def.width,
+			ctx->def.center_freq1, ctx->def.center_freq2);
+
+	skb = nrc_wim_alloc_skb_vif(nw, vif, WIM_CMD_SET, WIM_MAX_SIZE);
+	if (!skb)
+		return -EINVAL;
+
+	nrc_mac_add_tlv_channel(skb, &ctx->def);
+	nrc_xmit_wim_request(nw, skb);
+
+	if (vif->type != NL80211_IFTYPE_MONITOR)
+#ifdef CONFIG_SUPPORT_ITERATE_INTERFACE
+		ieee80211_iterate_interfaces(nw->hw,
+				IEEE80211_IFACE_ITER_ACTIVE,
+				nrc_mac_channel_policy, &ctx->def);
+#else
+		ieee80211_iterate_active_interfaces(nw->hw,
+				nrc_mac_channel_policy, &ctx->def);
+#endif
+
+	return 0;
+}
+
+static void nrc_mac_unassign_vif_chanctx(struct ieee80211_hw *hw,
+		struct ieee80211_vif *vif,
+		struct ieee80211_chanctx_conf *ctx)
+{
+	nrc_mac_dbg("%s, vif[type:%d, addr:%pM] %d MHz/width: %d/cfreqs:%d/%d MHz\n",
+			__func__, vif->type, vif->addr,
+			ctx->def.chan->center_freq, ctx->def.width,
+			ctx->def.center_freq1, ctx->def.center_freq2);
+}
+
+static int nrc_mac_switch_vif_chanctx(struct ieee80211_hw *hw,
+		struct ieee80211_vif_chanctx_switch *vifs,
+		int n_vifs,
+		enum ieee80211_chanctx_switch_mode mode)
+{
+	struct ieee80211_vif *vif = vifs->vif;
+	struct ieee80211_chanctx_conf *old_ctx = vifs->old_ctx;
+	struct ieee80211_chanctx_conf *new_ctx = vifs->new_ctx;
+
+	struct nrc *nw = hw->priv;
+	struct sk_buff *skb;
+
+	nrc_mac_dbg("%s, vif[type:%d, addr:%pM]\n",
+			__func__, vif->type, vif->addr);
+	nrc_mac_dbg("%s, old[%d MHz/width: %d/cfreqs:%d/%d MHz]\n",
+			__func__,
+			old_ctx->def.chan->center_freq, old_ctx->def.width,
+			old_ctx->def.center_freq1, old_ctx->def.center_freq2);
+	nrc_mac_dbg("%s, new[%d MHz/width: %d/cfreqs:%d/%d MHz]\n",
+			__func__,
+			new_ctx->def.chan->center_freq, new_ctx->def.width,
+			new_ctx->def.center_freq1, new_ctx->def.center_freq2);
+
+	skb = nrc_wim_alloc_skb_vif(nw, vif, WIM_CMD_SET, WIM_MAX_SIZE);
+	if (!skb)
+		return -EINVAL;
+
+	nrc_wim_skb_add_tlv(skb,
+			WIM_TLV_CHANNEL,
+			sizeof(new_ctx->def.chan->center_freq),
+			&new_ctx->def.chan->center_freq);
+
+	nrc_xmit_wim_request(nw, skb);
+
+#ifdef CONFIG_SUPPORT_ITERATE_INTERFACE
+	ieee80211_iterate_interfaces(nw->hw, IEEE80211_IFACE_ITER_ACTIVE,
+			nrc_mac_channel_policy, &new_ctx->def);
+#else
+	ieee80211_iterate_active_interfaces(nw->hw,
+			nrc_mac_channel_policy, &new_ctx->def);
+#endif
+
+	return 0;
+}
+#endif
+
+static void nrc_mac_channel_switch_beacon(struct ieee80211_hw *hw,struct ieee80211_vif *vif, struct cfg80211_chan_def *chandef)
+{
+	struct sk_buff *b;
+
+	b = ieee80211_beacon_get_template(hw, vif, NULL);
+
+	print_hex_dump(KERN_DEBUG, "new vendor elem: ", DUMP_PREFIX_NONE,
+		   16, 1, b->data, b->len, false);
+
+	nrc_vendor_update_beacon(hw, vif);
+	nrc_dbg(NRC_DBG_STATE, "[nrc_mac_channel_switch_beacon] Update Beacon for CSA\n");
+}
+
+static int nrc_pre_channel_switch(struct ieee80211_hw *hw,struct ieee80211_vif *vif, struct ieee80211_channel_switch *ch_switch)
+{
+	nrc_dbg(NRC_DBG_STATE, "[%s, %d] Channel switch start\n", __func__, __LINE__);
+	return 0;
+}
+
+static int nrc_post_channel_switch(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
+{
+	nrc_dbg(NRC_DBG_STATE, "[%s, %d] Channel switch complete\n", __func__, __LINE__);
+	return 0;
+}
+
+static void nrc_channel_switch(struct ieee80211_hw *hw,struct ieee80211_vif *vif, struct ieee80211_channel_switch *ch_switch)
+{
+	nrc_dbg(NRC_DBG_STATE, "[%s, %d] waiting for count less than 1 ... (CH to %d)\n", __func__, __LINE__, ch_switch->chandef.chan->center_freq);
+	// ieee80211_chswitch_done(vif, true);
+}
+
+#ifdef CONFIG_PM
+static struct wiphy_wowlan_support nrc_wowlan_support = {
+	.flags = WIPHY_WOWLAN_ANY,
+	/*
+	 * We only supports two patterns.
+	 */
+	.n_patterns = 2,
+	.pattern_max_len = 56,
+	.pattern_min_len = 16,
+	.max_pkt_offset = 16,
+};
+
+void nrc_mac_set_wakeup(struct ieee80211_hw *hw, bool enabled)
+{
+	struct nrc *nw = hw->priv;
+	nw->wowlan_enabled = enabled;
+	nrc_ps_dbg("[%s, L%d] wowlan enabled:%d\n", __func__, __LINE__, nw->wowlan_enabled);
+	return;
+}
+
+int nrc_mac_resume(struct ieee80211_hw *hw)
+{
+	struct nrc *nw = hw->priv;
+
+	nrc_ps_dbg("[%s, L%d]\n", __func__, __LINE__);
+
+	/* Resume rx queue */
+	nrc_hif_resume_rx_thread(nw->hif);
+	ieee80211_wake_queues(nw->hw);
+
+	nrc_hif_resume(nw->hif);
+
+	return 0;
+}
+
+int nrc_mac_suspend(struct ieee80211_hw *hw, struct cfg80211_wowlan *wowlan)
+{
+	struct nrc *nw = hw->priv;
+	struct sk_buff *skb;
+	int ret = 0, i;
+	struct nrc_txq *ntxq;
+	struct wim_pm_param *p;
+
+	nrc_ps_dbg("[%s,L%d] any:%d patterns(%p) n_patterns(%d)", __func__, __LINE__,
+			wowlan->any, wowlan->patterns, wowlan->n_patterns);
+
+	/*
+	 * If the target is already in deepsleep state(running uCode),
+	 * it's necessary to wake up the target first
+	 * and then the wowlan info should be transferred.
+	 */
+	if (nw->drv_state == NRC_DRV_PS) {
+		gpio_set_value(RPI_GPIO_FOR_PS, 1);
+		while (nw->drv_state == NRC_DRV_PS) {
+			msleep(100);
+		}
+	}
+
+	skb = nrc_wim_alloc_skb(nw, WIM_CMD_SET, WIM_MAX_SIZE);
+	
+	p = nrc_wim_skb_add_tlv(skb, WIM_TLV_PS_ENABLE,
+				sizeof(struct wim_pm_param) + 64, NULL);
+	memset(p, 0, sizeof(struct wim_pm_param));
+	p->ps_mode = NRC_PS_DEEPSLEEP_TIM;
+	p->ps_enable = true;
+	p->ps_wakeup_pin = TARGET_GPIO_FOR_WAKEUP;
+	p->wowlan_wakeup_host_pin = TARGET_GPIO_FOR_WAKEUP_HOST;
+	p->wowlan_enable_any = wowlan->any;
+	p->wowlan_enable_magicpacket = wowlan->magic_pkt;
+	p->wowlan_enable_disconnect = wowlan->disconnect;
+	p->wowlan_n_patterns = wowlan->n_patterns;
+	for (i = 0; i < wowlan->n_patterns; i++) {
+		p->wp[i].offset = (u8)wowlan->patterns[i].pkt_offset;
+		p->wp[i].pattern_len = (u8)wowlan->patterns[i].pattern_len;
+		p->wp[i].mask_len = DIV_ROUND_UP(p->wp[i].pattern_len, 8);
+		memcpy(p->wp[i].pattern, wowlan->patterns[i].pattern, p->wp[i].pattern_len);
+		memcpy(p->wp[i].mask, wowlan->patterns[i].mask, p->wp[i].mask_len);
+	}
+
+	gpio_set_value(RPI_GPIO_FOR_PS, 0);
+
+	/* Stop rx queue */
+	ieee80211_stop_queues(nw->hw);
+	for (i = 0; i < NRC_QUEUE_MAX; i++) {
+		ntxq = &nw->ntxq[i];
+		skb_queue_purge(&ntxq->queue);
+#ifdef CONFIG_CHECK_DATA_SIZE
+		ntxq->data_size = 0;
+#endif
+	}
+	nrc_hif_suspend_rx_thread(nw->hif);
+
+	/* TX WIM  */
+	ret = nrc_xmit_wim_request(nw, skb);
+
+	msleep(100);
+	nrc_hif_flush_wq(nw->hif);
+
+	if (!disable_cqm) {
+		del_timer(&nw->bcn_mon_timer);
+	}
+
+	/* SPI suspend for deepsleep  */
+	if (!ieee80211_hw_check(hw, SUPPORTS_DYNAMIC_PS)) {
+		nrc_hif_suspend(nw->hif);
+	}
+	nrc_ps_dbg("[%s,L%d] Enter DEEPSLEEP(%d)!!!", __func__, __LINE__, ret);
+
+	return 0;
+}
+#endif
+
+#if KERNEL_VERSION(4, 8, 0) <= NRC_TARGET_KERNEL_VERSION
+static u32 nrc_get_expected_throughput(struct ieee80211_hw *hw,
+		struct ieee80211_sta *sta)
+#else
+static u32 nrc_get_expected_throughput(struct ieee80211_sta *sta)
+#endif
+{
+	uint32_t tput = 0;
+
+	if (!sta)
+		return 0;
+
+	tput = nrc_stats_metric(sta->addr);
+	/* prevent overflow in mac80211 */
+	if (tput < 200)
+		tput = 200;
+
+	return tput;
+}
+
+static int nrc_set_frag_threshold(struct ieee80211_hw *hw, u32 value)
+{
+	return -1;
+}
+
+static const struct ieee80211_ops nrc_mac80211_ops = {
+	.tx = nrc_mac_tx,
+	.start = nrc_mac_start,
+	.stop = nrc_mac_stop,
+#ifdef CONFIG_PM
+	.suspend = nrc_mac_suspend,
+	.resume = nrc_mac_resume,
+	.set_wakeup = nrc_mac_set_wakeup,
+#endif
+	.add_interface = nrc_mac_add_interface,
+	.change_interface = nrc_mac_change_interface,
+	.remove_interface = nrc_mac_remove_interface,
+	.config = nrc_mac_config,
+	.configure_filter = nrc_mac_configure_filter,
+	.bss_info_changed = nrc_mac_bss_info_changed,
+#ifdef CONFIG_USE_TXQ
+	.wake_tx_queue = nrc_wake_tx_queue,
+#endif
+#ifdef NRC_BUILD_USE_HWSCAN
+	.hw_scan = nrc_mac_hw_scan,
+#ifdef CONFIG_SUPPORT_AFTER_KERNEL_3_0_36
+	.cancel_hw_scan = nrc_mac_cancel_hw_scan,
+#endif
+#endif
+	.set_key = nrc_mac_set_key,
+#ifdef CONFIG_SUPPORT_AFTER_KERNEL_3_0_36
+	.set_default_unicast_key = nrc_mac_set_default_unicast_key,
+	.sta_state = nrc_mac_sta_state,
+	.sta_pre_rcu_remove = nrc_mac_sta_pre_rcu_remove,
+#else
+	.sta_add = nrc_mac_sta_add,
+	.sta_remove = nrc_mac_sta_remove,
+#endif
+	.sta_notify = nrc_mac_sta_notify,
+	.set_tim = nrc_mac_set_tim,
+	.set_rts_threshold = nrc_mac_set_rts_threshold,
+	.set_frag_threshold = nrc_set_frag_threshold,
+	.conf_tx = nrc_mac_conf_tx,
+	.get_survey = nrc_mac_get_survey,
+	.ampdu_action = nrc_mac_ampdu_action,
+	.set_bitrate_mask = nrc_mac_set_bitrate_mask,
+#ifndef NRC_BUILD_USE_HWSCAN
+	.sw_scan_start = nrc_mac_sw_scan,
+	.sw_scan_complete = nrc_mac_sw_scan_complete,
+#endif
+	.flush = nrc_mac_flush,
+#ifdef CONFIG_SUPPORT_TX_FRAMES_PENDING
+	.tx_frames_pending = nrc_mac_tx_frames_pending,
+#endif
+	.get_tsf = nrc_mac_get_tsf,
+	.set_tsf = nrc_mac_set_tsf,
+	.remain_on_channel = nrc_mac_roc,
+	.cancel_remain_on_channel = nrc_mac_cancel_roc,
+#ifdef CONFIG_SUPPORT_AFTER_KERNEL_3_0_36
+	.get_et_sset_count = nrc_mac_get_et_sset_count,
+	.get_et_stats = nrc_mac_get_et_stats,
+	.get_et_strings = nrc_mac_get_et_strings,
+#endif
+#ifdef CONFIG_USE_CHANNEL_CONTEXT
+	.add_chanctx = nrc_mac_add_chanctx,
+	.remove_chanctx = nrc_mac_remove_chanctx,
+	.change_chanctx = nrc_mac_change_chanctx,
+	.assign_vif_chanctx = nrc_mac_assign_vif_chanctx,
+	.unassign_vif_chanctx = nrc_mac_unassign_vif_chanctx,
+	.switch_vif_chanctx = nrc_mac_switch_vif_chanctx,
+#endif
+	.channel_switch_beacon = nrc_mac_channel_switch_beacon,
+	.pre_channel_switch = nrc_pre_channel_switch,
+	.post_channel_switch = nrc_post_channel_switch,
+	.channel_switch = nrc_channel_switch,
+	.get_expected_throughput = nrc_get_expected_throughput
+};
+
+struct nrc *nrc_alloc_hw(struct platform_device *pdev)
+{
+	struct ieee80211_hw *hw;
+	struct nrc *nw;
+
+#ifdef CONFIG_SUPPORT_HWDEV_NAME
+	hw = ieee80211_alloc_hw_nm(sizeof(struct nrc), &nrc_mac80211_ops,
+				   dev_name(&pdev->dev));
+#else
+	hw = ieee80211_alloc_hw(sizeof(struct nrc),
+				   &nrc_mac80211_ops);
+#endif
+
+	if (!hw)
+		return NULL;
+
+	nw = hw->priv;
+	nw->hw = hw;
+	nw->pdev = pdev;
+
+	return nw;
+}
+
+void nrc_free_hw(struct nrc *nw)
+{
+	ieee80211_free_hw(nw->hw);
+	nw->hw = NULL; /* MERGE CHECK */
+}
+
+#ifdef CONFIG_NEW_REG_NOTIFIER
+void nrc_reg_notifier(struct wiphy *wiphy,
+		struct regulatory_request *request)
+#else
+int nrc_reg_notifier(struct wiphy *wiphy,
+		struct regulatory_request *request)
+#endif
+{
+#if defined(CONFIG_SUPPORT_BD)
+	int i;
+	struct wim_bd_param *bd_param = NULL;
+#endif /* CONFIG_SUPPORT_BD */
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct nrc *nw = hw->priv;
+	struct sk_buff *skb;
+
+	nrc_mac_dbg("info: cfg80211 regulatory domain callback for %c%c",
+			request->alpha2[0], request->alpha2[1]);
+	nrc_mac_dbg("request->initiator:%d", request->initiator);
+	nrc_cc[0] = request->alpha2[0];
+	nrc_cc[1] = request->alpha2[1];
+	if((request->alpha2[0] == '0' && request->alpha2[1] == '0') ||
+		(request->alpha2[0] == '9' && request->alpha2[1] == '9')) {
+		nrc_mac_dbg("CC is 00 or 99. Skip loading BD and setting CC");
+#ifdef CONFIG_NEW_REG_NOTIFIER
+		return;
+#else
+		return 0;
+#endif
+	}
+
+	if (!strncmp("JP", request->alpha2,2)) {
+		nrc_mac_dbg("CC is JP. LBT is enabled");
+		enable_usn = true;
+	}
+
+#if defined(CONFIG_SUPPORT_BD)
+	//Read board data and save buffer
+	/* Check the state of undefined CC and update it with default country(US) for intialization of channel list */
+	if((request->alpha2[0] == '0' && request->alpha2[1] == '0') ||
+		(request->alpha2[0] == '9' && request->alpha2[1] == '9')) {
+		bd_param = nrc_read_bd_tx_pwr(nw, "US");
+	} else {
+		bd_param = nrc_read_bd_tx_pwr(nw, request->alpha2);
+	}
+
+	if(bd_param) {
+		nrc_dbg(NRC_DBG_BD,"type %04X length %04X checksum %04X target_ver %04X",
+				bd_param->type, bd_param->length, bd_param->checksum, bd_param->hw_version);
+		for(i=0; i < bd_param->length - 4;) {
+			nrc_dbg(NRC_DBG_BD,"%02d %02d %02d %02d %02d %02d %02d %02d %02d %02d %02d %02d",
+				(bd_param->value[i]), (bd_param->value[i+1]), (bd_param->value[i+2]),
+				(bd_param->value[i+3]), (bd_param->value[i+4]), (bd_param->value[i+5]),
+				(bd_param->value[i+6]), (bd_param->value[i+7]), (bd_param->value[i+8]),
+				(bd_param->value[i+9]), (bd_param->value[i+10]), (bd_param->value[i+11])
+				);
+			i += 12;
+		}
+	} else {
+		/* Default policy is that if board data is invalid, block loading of FW */
+		nrc_mac_dbg("BD file is invalid..Exit!!");
+		nw->bd_valid = false;
+		nw->drv_state = NRC_DRV_STOP;
+#ifdef CONFIG_NEW_REG_NOTIFIER
+		return;
+#else
+		return -1;
+#endif
+	}
+#endif /* defined(CONFIG_SUPPORT_BD) */
+
+	nw->alpha2[0] = request->alpha2[0];
+	nw->alpha2[1] = request->alpha2[1];
+
+	skb = nrc_wim_alloc_skb(nw, WIM_CMD_SET, WIM_MAX_SIZE);
+	nrc_wim_skb_add_tlv(skb, WIM_TLV_COUNTRY_CODE,
+		sizeof(u16), request->alpha2);
+
+#if defined(CONFIG_SUPPORT_BD)
+	if(bd_param) {
+		nrc_dbg(NRC_DBG_STATE,"succeed in loading board data on target");
+		nrc_wim_skb_add_tlv(skb, WIM_TLV_BD, sizeof(*bd_param), bd_param);
+		kfree(bd_param);
+	} else {
+		nrc_dbg(NRC_DBG_STATE,"fail to load board data on target");
+	}
+#endif /* defined(CONFIG_SUPPORT_BD) */
+	nrc_xmit_wim_request(nw, skb);
+
+#ifdef CONFIG_NEW_REG_NOTIFIER
+	return;
+#else
+	return 0;
+#endif
+}
+
+static u8* nrc_vendor_remove(struct nrc *nw, u8 subcmd)
+{
+	u8 *pos = NULL;
+
+	if (!nw->vendor_skb)
+		return NULL;
+
+	pos = (u8*)cfg80211_find_vendor_ie(OUI_IEEE_REGISTRATION_AUTHORITY, subcmd,
+			nw->vendor_skb->data, nw->vendor_skb->len);
+
+	if (pos) {
+		u8 len = *(pos + 1);
+		memmove(pos, pos + len + 2, nw->vendor_skb->len -
+			(pos - nw->vendor_skb->data) - (len + 2));
+		skb_trim(nw->vendor_skb, nw->vendor_skb->len - (len + 2));
+	}
+
+	nrc_mac_dbg("%s: removed vendor IE", __func__);
+	return pos;
+}
+
+static int nrc_vendor_update(struct nrc *nw, u8 subcmd,
+				const u8 *data, int data_len)
+{
+	const int OUI_LEN = 3;
+	const int MAX_DATALEN = 255;
+	int new_elem_len = data_len + 2 /* EID + LEN */ + OUI_LEN + 1;
+	u8 *pos;
+
+	if (!data || data_len < 1 || (data_len + OUI_LEN + 1) > MAX_DATALEN)
+		return -EINVAL;
+
+	if (!nw->vendor_skb)
+		nw->vendor_skb = dev_alloc_skb(IEEE80211_MAX_FRAME_LEN);
+
+	// Remove old data first
+	pos = nrc_vendor_remove(nw, subcmd);
+
+	/* Append new data */
+	pos = skb_put(nw->vendor_skb, new_elem_len);
+	*pos++ = WLAN_EID_VENDOR_SPECIFIC;
+	*pos++ = data_len + OUI_LEN + 1;
+	*pos++ = 0xFC;
+	*pos++ = 0xFF;
+	*pos++ = 0xAA;
+	*pos++ = subcmd;
+	memcpy(pos, data, data_len);
+
+	print_hex_dump(KERN_DEBUG, "new vendor elem: ", DUMP_PREFIX_NONE,
+		   16, 1, nw->vendor_skb->data, nw->vendor_skb->len, false);
+
+	return 0;
+}
+
+static int nrc_vendor_cmd_remove(struct wiphy *wiphy,
+				struct wireless_dev *wdev, u8 subcmd)
+{
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct ieee80211_vif *vif = wdev_to_ieee80211_vif(wdev);
+	struct nrc *nw = hw->priv;
+
+	/* Remove the vendor ie */
+	if (nrc_vendor_remove(nw, subcmd) == NULL)
+		return -EINVAL;
+	/* Update beacon */
+	return nrc_vendor_update_beacon(hw, vif);
+}
+
+static int nrc_vendor_cmd_append(struct wiphy *wiphy, struct wireless_dev *wdev,
+				u8 subcmd, const void *data, int data_len)
+{
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct ieee80211_vif *vif = wdev_to_ieee80211_vif(wdev);
+	struct nrc *nw = hw->priv;
+
+	/* Update local vendor data */
+	if (nrc_vendor_update(nw, subcmd, data, data_len) != 0)
+		return -EINVAL;
+
+	/* Update beacon */
+	return nrc_vendor_update_beacon(hw, vif);
+}
+
+static int nrc_vendor_cmd_wowlan_pattern(struct wiphy *wiphy,
+				struct wireless_dev *wdev,
+				const void *data, int data_len)
+{
+	struct sk_buff *skb;
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct nrc *nw = hw->priv;
+	u8* new_data = (u8*)data;
+	u8 count = *new_data;
+
+	nrc_vendor_cmd_append(wiphy, wdev, NRC_SUBCMD_WOWLAN_PATTERN,
+				(void*)(new_data + 1), data_len - 1);
+
+	queue_delayed_work(nw->workqueue, &nw->rm_vendor_ie_wowlan_pattern,
+							msecs_to_jiffies(count * nw->beacon_int));
+
+	/* Send a response to the command */
+	skb = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, 10);
+	if (!skb)
+		return -ENOMEM;
+
+	nla_put_u32(skb, NRC_SUBCMD_WOWLAN_PATTERN, 0x11223344);
+
+	return cfg80211_vendor_cmd_reply(skb);
+}
+
+static int nrc_vendor_cmd_announce1(struct wiphy *wiphy,
+				struct wireless_dev *wdev,
+				const void *data, int data_len)
+{
+	return nrc_vendor_cmd_append(wiphy, wdev, NRC_SUBCMD_ANNOUNCE1,
+				 data, data_len);
+}
+
+static int nrc_vendor_cmd_announce2(struct wiphy *wiphy,
+				struct wireless_dev *wdev,
+				const void *data, int data_len)
+{
+	return nrc_vendor_cmd_append(wiphy, wdev, NRC_SUBCMD_ANNOUNCE2,
+				 data, data_len);
+}
+
+static int nrc_vendor_cmd_announce3(struct wiphy *wiphy,
+				struct wireless_dev *wdev,
+				const void *data, int data_len)
+{
+	return nrc_vendor_cmd_append(wiphy, wdev, NRC_SUBCMD_ANNOUNCE3,
+				 data, data_len);
+}
+
+static int nrc_vendor_cmd_announce4(struct wiphy *wiphy,
+				struct wireless_dev *wdev,
+				const void *data, int data_len)
+{
+	return nrc_vendor_cmd_append(wiphy, wdev, NRC_SUBCMD_ANNOUNCE4,
+				 data, data_len);
+}
+
+static int nrc_vendor_cmd_announce5(struct wiphy *wiphy,
+				struct wireless_dev *wdev,
+				const void *data, int data_len)
+{
+	return nrc_vendor_cmd_append(wiphy, wdev, NRC_SUBCMD_ANNOUNCE5,
+				 data, data_len);
+}
+
+static int nrc_vendor_cmd_remove_vendor_ie(struct wiphy *wiphy,
+				struct wireless_dev *wdev,
+				const void *data, int data_len)
+{
+	return nrc_vendor_cmd_remove(wiphy, wdev, *((u8*)data));
+}
+
+static struct wiphy_vendor_command nrc_vendor_cmds[] = {
+	{
+		.info = {
+			.vendor_id = OUI_IEEE_REGISTRATION_AUTHORITY,
+			.subcmd = NRC_SUBCMD_WOWLAN_PATTERN
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = nrc_vendor_cmd_wowlan_pattern,
+#if KERNEL_VERSION(5, 3, 0) <= NRC_TARGET_KERNEL_VERSION
+		.policy = VENDOR_CMD_RAW_DATA,
+		.maxattr = MAX_VENDOR_ATTR,
+#endif
+	},
+	{
+		.info = {
+			.vendor_id = OUI_IEEE_REGISTRATION_AUTHORITY,
+			.subcmd = NRC_SUBCMD_ANNOUNCE1
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = nrc_vendor_cmd_announce1,
+#if KERNEL_VERSION(5, 3, 0) <= NRC_TARGET_KERNEL_VERSION
+		.policy = VENDOR_CMD_RAW_DATA,
+		.maxattr = MAX_VENDOR_ATTR,
+#endif
+	},
+	{
+		.info = {
+			.vendor_id = OUI_IEEE_REGISTRATION_AUTHORITY,
+			.subcmd = NRC_SUBCMD_ANNOUNCE2
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = nrc_vendor_cmd_announce2,
+#if KERNEL_VERSION(5, 3, 0) <= NRC_TARGET_KERNEL_VERSION
+		.policy = VENDOR_CMD_RAW_DATA,
+		.maxattr = MAX_VENDOR_ATTR,
+#endif
+	},
+	{
+		.info = {
+			.vendor_id = OUI_IEEE_REGISTRATION_AUTHORITY,
+			.subcmd = NRC_SUBCMD_ANNOUNCE3
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = nrc_vendor_cmd_announce3,
+#if KERNEL_VERSION(5, 3, 0) <= NRC_TARGET_KERNEL_VERSION
+		.policy = VENDOR_CMD_RAW_DATA,
+		.maxattr = MAX_VENDOR_ATTR,
+#endif
+	},
+	{
+		.info = {
+			.vendor_id = OUI_IEEE_REGISTRATION_AUTHORITY,
+			.subcmd = NRC_SUBCMD_ANNOUNCE4
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = nrc_vendor_cmd_announce4,
+#if KERNEL_VERSION(5, 3, 0) <= NRC_TARGET_KERNEL_VERSION
+		.policy = VENDOR_CMD_RAW_DATA,
+		.maxattr = MAX_VENDOR_ATTR,
+#endif
+	},
+	{
+		.info = {
+			.vendor_id = OUI_IEEE_REGISTRATION_AUTHORITY,
+			.subcmd = NRC_SUBCMD_ANNOUNCE5
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = nrc_vendor_cmd_announce5,
+#if KERNEL_VERSION(5, 3, 0) <= NRC_TARGET_KERNEL_VERSION
+		.policy = VENDOR_CMD_RAW_DATA,
+		.maxattr = MAX_VENDOR_ATTR,
+#endif
+	},
+	{
+		.info = { .vendor_id = OUI_IEEE_REGISTRATION_AUTHORITY,
+			  .subcmd = NRC_SUBCMD_RM_VENDOR_IE },
+		.flags = WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = nrc_vendor_cmd_remove_vendor_ie,
+#if KERNEL_VERSION(5, 3, 0) <= NRC_TARGET_KERNEL_VERSION
+		.policy = VENDOR_CMD_RAW_DATA,
+		.maxattr = MAX_VENDOR_ATTR,
+#endif
+	},
+};
+
+static const struct nl80211_vendor_cmd_info nrc_vendor_events[] = {
+	{
+		.vendor_id = OUI_IEEE_REGISTRATION_AUTHORITY,
+		.subcmd = NRC_SUBCMD_ANNOUNCE1
+	},
+	{
+		.vendor_id = OUI_IEEE_REGISTRATION_AUTHORITY,
+		.subcmd = NRC_SUBCMD_ANNOUNCE2
+	},
+	{
+		.vendor_id = OUI_IEEE_REGISTRATION_AUTHORITY,
+		.subcmd = NRC_SUBCMD_ANNOUNCE3
+	},
+	{
+		.vendor_id = OUI_IEEE_REGISTRATION_AUTHORITY,
+		.subcmd = NRC_SUBCMD_ANNOUNCE4
+	},
+	{
+		.vendor_id = OUI_IEEE_REGISTRATION_AUTHORITY,
+		.subcmd = NRC_SUBCMD_ANNOUNCE5
+	},
+	{
+		.vendor_id = OUI_IEEE_REGISTRATION_AUTHORITY,
+		.subcmd = NRC_SUBCMD_WOWLAN_PATTERN
+	},
+};
+
+static void nrc_rm_vendor_ie_wowlan_pattern(struct work_struct *work)
+{
+	struct nrc *nw = container_of(work, struct nrc, rm_vendor_ie_wowlan_pattern.work);
+
+	/* Remove the vendor ie */
+	nrc_vendor_remove(nw, NRC_SUBCMD_WOWLAN_PATTERN);
+	/* Update beacon */
+	nrc_vendor_update_beacon(nw->hw, nw->vif[0]);
+}
+
+#if KERNEL_VERSION(4, 15, 0) > LINUX_VERSION_CODE
+static void nrc_bcn_mon_timer(unsigned long data)
+{
+	struct nrc *nw = (struct nrc *)data;
+#else
+static void nrc_bcn_mon_timer(struct timer_list *t)
+{
+	struct nrc *nw = from_timer(nw, t, bcn_mon_timer);
+#endif
+	if (nw->drv_state == NRC_DRV_PS) {
+		nrc_mac_dbg("In PS state, ignore bcn_mon_timeout\n");
+		return;
+	}
+	ieee80211_beacon_loss(nw->vif[0]);
+}
+
+#if defined(ENABLE_DYNAMIC_PS)
+#if KERNEL_VERSION(4, 15, 0) > LINUX_VERSION_CODE
+static void nrc_ps_timeout_timer(unsigned long data)
+{
+	struct nrc *nw = (struct nrc *)data;
+#else
+static void nrc_ps_timeout_timer(struct timer_list *t)
+{
+	struct nrc *nw = from_timer(nw, t, dynamic_ps_timer);
+#endif
+	struct nrc_hif_device *hdev = nw->hif;
+
+	nrc_ps_dbg("[%s,L%d] ps_enable:%d dynamic_ps_timeout:%d\n",
+				__func__, __LINE__, nw->ps_enabled, nw->hw->conf.dynamic_ps_timeout);
+
+	if (nw->ps_enabled) {
+		if (nw->drv_state == NRC_DRV_PS) {
+			/*
+			 * if the current state is already NRC_DRV_PS,
+			 * there's nothing to do in here even if mac80211 notifies wake-up.
+			 * the actual action to wake up for target will be done by
+			 * nrc_wake_tx_queue() with changing gpio signal.
+			 * (when driver receives a data frame.)
+			 */
+			nrc_ps_dbg("Target is already in deepsleep...\n");
+
+			return;
+		}
+		if (nw->ps_wq != NULL)
+			queue_work(nw->ps_wq, &hdev->ps_work);
+	}
+}
+#endif /* if defined(ENABLE_DYNAMIC_PS) */
+
+/**
+ * nrc_hw_register - initialize struct ieee80211_hw instance
+ */
+int nrc_register_hw(struct nrc *nw)
+{
+	struct ieee80211_hw *hw = nw->hw;
+	struct ieee80211_supported_band *sband = NULL;
+#ifdef CONFIG_USE_NEW_BAND_ENUM
+	enum nl80211_band band;
+#else
+	enum ieee80211_band band;
+#endif
+	int ret;
+	int i;
+/*	char tmp[2];*/
+
+	mutex_init(&nw->target_mtx);
+	mutex_init(&nw->state_mtx);
+
+	for (i = 0; i < NR_NRC_VIF; i++) {
+		if (!nw->has_macaddr[i])
+			set_mac_address(&nw->mac_addr[i], i);
+	}
+
+	SET_IEEE80211_PERM_ADDR(hw, nw->mac_addr[0].addr);
+	hw->wiphy->n_addresses = NR_NRC_VIF;
+	hw->wiphy->addresses = nw->mac_addr;
+
+	SET_IEEE80211_DEV(hw, &nw->pdev->dev);
+
+	hw->wiphy->max_scan_ssids = WIM_MAX_SCAN_SSID;
+	hw->wiphy->max_scan_ie_len = WIM_MAX_TLV_SCAN_IE;
+	hw->wiphy->max_remain_on_channel_duration = NRC_MAC80211_ROC_DURATION;
+	hw->wiphy->interface_modes =
+		BIT(NL80211_IFTYPE_STATION) | BIT(NL80211_IFTYPE_AP) |
+#ifdef CONFIG_MAC80211_MESH
+		BIT(NL80211_IFTYPE_MESH_POINT) |
+#endif
+#if !defined(CONFIG_S1G_CHANNEL)
+#ifdef CONFIG_SUPPORT_P2P
+		BIT(NL80211_IFTYPE_P2P_CLIENT) | BIT(NL80211_IFTYPE_P2P_GO) |
+		BIT(NL80211_IFTYPE_P2P_DEVICE) |
+#endif
+#endif /* CONFIG_S1G_CHANNEL */
+#if defined(CONFIG_WIRELESS_WDS)
+		BIT(NL80211_IFTYPE_WDS) |
+#endif
+		BIT(NL80211_IFTYPE_MONITOR);
+	hw->queues = IEEE80211_MAX_QUEUES;
+#ifdef	CONFIG_USE_HW_QUEUE
+	hw->offchannel_tx_hw_queue = (IEEE80211_MAX_QUEUES - 1);
+#endif
+
+	for (i = 0; i < ARRAY_SIZE(nw->ntxq); i++) {
+		struct nrc_txq *ntxq = &nw->ntxq[i];
+
+		INIT_LIST_HEAD(&ntxq->list);
+		skb_queue_head_init(&ntxq->queue);
+#ifdef CONFIG_CHECK_DATA_SIZE
+		ntxq->data_size = 0;
+#endif
+		ntxq->hw_queue = i;
+	}
+
+	if (nw->cap.cap_mask & WIM_SYSTEM_CAP_MULTI_VIF) {
+		hw->wiphy->iface_combinations = if_comb_multi;
+		hw->wiphy->n_iface_combinations = ARRAY_SIZE(if_comb_multi);
+	}
+
+	ieee80211_hw_set(hw, HAS_RATE_CONTROL);
+	ieee80211_hw_set(hw, AMPDU_AGGREGATION);
+	ieee80211_hw_set(hw, MFP_CAPABLE);
+	ieee80211_hw_set(hw, SIGNAL_DBM);
+	ieee80211_hw_set(hw, SUPPORTS_PER_STA_GTK);
+	ieee80211_hw_set(hw, SINGLE_SCAN_ON_ALL_BANDS);
+
+#ifdef CONFIG_USE_MONITOR_VIF
+	ieee80211_hw_set(hw, WANT_MONITOR_VIF);
+#endif
+	ieee80211_hw_set(hw, CONNECTION_MONITOR);
+	if (!disable_cqm) {
+		nrc_mac_dbg("CQM is disabled");
+		nw->beacon_timeout = 0;
+#if KERNEL_VERSION(4, 15, 0) > LINUX_VERSION_CODE
+		setup_timer(&nw->bcn_mon_timer,
+			nrc_bcn_mon_timer, (unsigned long)nw);
+#else
+		timer_setup(&nw->bcn_mon_timer, nrc_bcn_mon_timer, 0);
+#endif
+	}
+
+	if (power_save >= NRC_PS_MODEMSLEEP) {
+		ieee80211_hw_set(hw, SUPPORTS_PS);
+#if defined(ENABLE_DYNAMIC_PS)
+		/* Do NOT use HW Dynamic PS if nullfunc_enable is enabled */
+		if (!nullfunc_enable) {
+		//if (power_save >= NRC_PS_DEEPSLEEP_TIM) {
+			ieee80211_hw_set(hw, SUPPORTS_DYNAMIC_PS);
+#if KERNEL_VERSION(4, 15, 0) > LINUX_VERSION_CODE
+			setup_timer(&nw->dynamic_ps_timer,
+				nrc_ps_timeout_timer, (unsigned long)nw);
+#else
+			timer_setup(&nw->dynamic_ps_timer, nrc_ps_timeout_timer, 0);
+#endif
+		//}
+		}
+#endif /* ENABLE_DYNAMIC_PS */
+
+		/* README - yj.kim 06/05/2020
+		 * Target FW handles qos_null frame for power save mode
+		 */
+		if (nullfunc_enable) {
+			ieee80211_hw_set(hw, PS_NULLFUNC_STACK);
+		}
+		/* ieee80211_hw_set(hw, HOST_BROADCAST_PS_BUFFERING); */
+	}
+
+#ifdef CONFIG_SUPPORT_AFTER_KERNEL_3_0_36
+	hw->wiphy->flags |=  WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;
+	hw->wiphy->flags |=  WIPHY_FLAG_HAS_CHANNEL_SWITCH;
+
+	hw->wiphy->features |= NL80211_FEATURE_INACTIVITY_TIMER;
+	/* hostapd ver > 2.6 need for NL80211_FEATURE_FULL_AP_CLIENT_STATE */
+	hw->wiphy->features |= NL80211_FEATURE_FULL_AP_CLIENT_STATE;
+#endif
+	hw->vif_data_size = sizeof(struct nrc_vif);
+	hw->sta_data_size = sizeof(struct nrc_sta);
+#ifdef CONFIG_USE_TXQ
+	hw->txq_data_size = sizeof(struct nrc_txq);
+#endif
+#ifdef CONFIG_SUPPORT_AFTER_KERNEL_3_0_36
+	hw->chanctx_data_size = 0;
+
+	/* FW handles probe-requests in AP-mode */
+	hw->wiphy->flags |= WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD;
+	hw->wiphy->flags |= WIPHY_FLAG_AP_UAPSD;
+	hw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN;
+
+	hw->wiphy->probe_resp_offload = NL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS2
+		| NL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS2
+		| NL80211_PROBE_RESP_OFFLOAD_SUPPORT_P2P;
+#endif
+
+#ifdef CONFIG_USE_NEW_BAND_ENUM
+	for (band = NL80211_BAND_2GHZ; band < NUM_NL80211_BANDS; band++) {
+#else
+	for (band = NL80211_BAND_2GHZ; band < IEEE80211_NUM_BANDS; band++) {
+#endif
+		sband = &nw->bands[band];
+
+		switch (band) {
+#if defined(CONFIG_S1G_CHANNEL)
+		case NL80211_BAND_S1GHZ:
+			sband->channels = nrc_channels_s1ghz;
+			sband->n_channels = ARRAY_SIZE(nrc_channels_s1ghz);
+			sband->bitrates = nrc_rates;
+			sband->n_bitrates = ARRAY_SIZE(nrc_rates);
+
+			sband->s1g_cap.s1g_supported = true;
+			hw->wiphy->bands[band] = sband;
+			continue;
+			break;
+#else
+		case NL80211_BAND_5GHZ:
+			if (!(nw->cap.cap_mask & WIM_SYSTEM_CAP_CHANNEL_5G))
+				continue;
+			sband->channels = nrc_channels_5ghz;
+			sband->n_channels = ARRAY_SIZE(nrc_channels_5ghz);
+			sband->bitrates = nrc_rates + 4;
+			sband->n_bitrates = ARRAY_SIZE(nrc_rates) - 4;
+			sband->band = NL80211_BAND_5GHZ;
+			sband->ht_cap.ht_supported = true;
+			sband->ht_cap.cap = IEEE80211_HT_CAP_SGI_20;
+			sband->ht_cap.cap |= IEEE80211_HT_CAP_SGI_40;
+			/* wpa_supplicant-2.10 checks HT40 allowed channel pair.
+			 * possible HT40+ channels: 36, 44, 52, 60, 100, 108, 116, 124,
+			 * 132, 149, 157.
+			 * possible HT40- channels: 40, 48, 56, 64, 104, 112, 120, 128,
+			 * 136, 153, 161.
+			 * but we use other 5Ghz channels to match S1G channels.
+			 *
+			 * sband->ht_cap.cap |= IEEE80211_HT_CAP_SUP_WIDTH_20_40;
+			 */
+			sband->ht_cap.cap |=
+				(1 << IEEE80211_HT_CAP_RX_STBC_SHIFT);
+			sband->ht_cap.ampdu_factor =
+				IEEE80211_HT_MAX_AMPDU_16K;
+			sband->ht_cap.ampdu_density =
+				IEEE80211_HT_MPDU_DENSITY_8;
+			break;
+
+		case NL80211_BAND_2GHZ:
+			if (!(nw->cap.cap_mask & WIM_SYSTEM_CAP_CHANNEL_2G))
+				continue;
+			sband->channels = nrc_channels_2ghz;
+			sband->n_channels = ARRAY_SIZE(nrc_channels_2ghz);
+			sband->bitrates = nrc_rates;
+			sband->n_bitrates = ARRAY_SIZE(nrc_rates);
+			sband->band = NL80211_BAND_2GHZ;
+			sband->ht_cap.ht_supported = true;
+			sband->ht_cap.cap = IEEE80211_HT_CAP_SGI_20;
+			sband->ht_cap.cap |= IEEE80211_HT_CAP_SGI_40;
+			sband->ht_cap.cap |= IEEE80211_HT_CAP_SUP_WIDTH_20_40;
+			sband->ht_cap.cap |= IEEE80211_HT_CAP_DSSSCCK40;
+			sband->ht_cap.cap |=
+				(1 << IEEE80211_HT_CAP_RX_STBC_SHIFT);
+			sband->ht_cap.ampdu_factor =
+				IEEE80211_HT_MAX_AMPDU_16K;
+			sband->ht_cap.ampdu_density =
+				IEEE80211_HT_MPDU_DENSITY_8;
+			break;
+#endif /* CONFIG_S1G_CHANNEL */
+		default:
+			continue;
+		}
+
+		memset(&sband->ht_cap.mcs, 0, sizeof(sband->ht_cap.mcs));
+
+		sband->ht_cap.mcs.rx_mask[0] = 0xff;
+		sband->ht_cap.mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED;
+
+		hw->wiphy->bands[band] = sband;
+	}
+
+	hw->wiphy->cipher_suites = nrc_cipher_supported;
+	hw->wiphy->n_cipher_suites = ARRAY_SIZE(nrc_cipher_supported);
+
+	hw->extra_tx_headroom =
+		(sizeof(struct hif) + sizeof(struct frame_hdr) + 32);
+	hw->max_rates = 4;
+	hw->max_rate_tries = 11;
+
+	hw->wiphy->vendor_commands = nrc_vendor_cmds;
+	hw->wiphy->n_vendor_commands = ARRAY_SIZE(nrc_vendor_cmds);
+
+	hw->wiphy->vendor_events = nrc_vendor_events;
+	hw->wiphy->n_vendor_events = ARRAY_SIZE(nrc_vendor_events);
+
+#ifdef CONFIG_SUPPORT_AFTER_KERNEL_3_0_36
+	hw->wiphy->regulatory_flags =
+		REGULATORY_CUSTOM_REG|WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;
+#endif
+
+#ifdef CONFIG_PM
+	hw->wiphy->wowlan = &nrc_wowlan_support;
+#endif
+
+	wiphy_apply_custom_regulatory(hw->wiphy, &mac80211_regdom);
+	nw->alpha2[0] = '9';
+	nw->alpha2[1] = '9';
+	nw->bd_valid = true;
+
+	if (nrc_mac_is_s1g(nw)) {
+		/*this is only for 802.11ah*/
+		hw->wiphy->reg_notifier = nrc_reg_notifier;
+	}
+
+#ifdef CONFIG_SUPPORT_AFTER_KERNEL_3_0_36
+	hw->uapsd_queues = IEEE80211_WMM_IE_STA_QOSINFO_AC_BK
+		| IEEE80211_WMM_IE_STA_QOSINFO_AC_BE
+		| IEEE80211_WMM_IE_STA_QOSINFO_AC_VI
+		| IEEE80211_WMM_IE_STA_QOSINFO_AC_VO;
+#endif
+	nw->ampdu_supported = false;
+	nw->amsdu_supported = true;
+	nw->block_frame = false;
+	nw->ampdu_reject = false;
+
+	INIT_DELAYED_WORK(&nw->roc_finish, nrc_mac_roc_finish);
+	INIT_DELAYED_WORK(&nw->rm_vendor_ie_wowlan_pattern, nrc_rm_vendor_ie_wowlan_pattern);
+
+	/* trx */
+	nrc_mac_trx_init(nw);
+	spin_lock_init(&nw->vif_lock);
+
+	init_completion(&nw->hif_tx_stopped);
+	init_completion(&nw->hif_rx_stopped);
+	init_completion(&nw->hif_irq_stopped);
+	atomic_set(&nw->fw_state, NRC_FW_ACTIVE);
+
+	ret = ieee80211_register_hw(hw);
+	if (ret < 0) {
+		nrc_mac_dbg("ieee80211_register_hw failed (%d)", ret);
+		ieee80211_free_hw(hw);
+		hw = NULL;
+		return -EINVAL;
+	}
+
+	/* debugfs */
+	nrc_init_debugfs(nw);
+
+	return 0;
+}
+
+void nrc_unregister_hw(struct nrc *nw)
+{
+	ieee80211_unregister_hw(nw->hw);
+	SET_IEEE80211_DEV(nw->hw, NULL);
+	nrc_hif_cleanup(nw->hif);
+
+	if (ieee80211_hw_check(nw->hw, SUPPORTS_DYNAMIC_PS)) {
+		del_timer(&nw->dynamic_ps_timer);
+	}
+
+	if (!disable_cqm) {
+		del_timer(&nw->bcn_mon_timer);
+	}
+
+	if (nw->workqueue != NULL) {
+		flush_workqueue(nw->workqueue);
+		destroy_workqueue(nw->workqueue);
+	}
+	nw->workqueue = NULL;
+	if (nw->ps_wq != NULL) {
+		flush_workqueue(nw->ps_wq);
+		destroy_workqueue(nw->ps_wq);
+	}
+	nw->ps_wq = NULL;
+	if (nw->vendor_skb) {
+		dev_kfree_skb_any(nw->vendor_skb);
+		nw->vendor_skb = NULL;
+	}
+
+	nrc_cleanup_txq(nw);
+}
+
+bool nrc_mac_is_s1g(struct nrc *nw)
+{
+	return (nw->fwinfo.version != WIM_SYSTEM_VER_11N);
+}
+
+void nrc_mac_clean_txq(struct nrc *nw)
+{
+	nrc_cleanup_txq(nw);
+}
diff --git a/drivers/staging/nrc/nrc-mac80211.h b/drivers/staging/nrc/nrc-mac80211.h
new file mode 100644
index 000000000000..e08aee82eb0b
--- /dev/null
+++ b/drivers/staging/nrc/nrc-mac80211.h
@@ -0,0 +1,108 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _NRC_MAC80211_H_
+#define _NRC_MAC80211_H_
+
+#include "nrc.h"
+#include "mac80211-ext.h"
+
+#define NRC_MAC80211_MAX_SCANSSID   (32)
+#define NRC_MAC80211_MAX_SCANIELEN  (IEEE80211_MAX_DATA_LEN)
+#define NRC_MAC80211_ROC_DURATION   (1000)
+#define NRC_MAC80211_RCU_LOCK_THRESHOLD	(1000)
+
+#ifdef CONFIG_SUPPORT_TX_CONTROL
+#else
+struct ieee80211_tx_control {
+	struct ieee80211_sta *sta;
+};
+#endif
+
+#ifdef CONFIG_SUPPORT_AFTER_KERNEL_3_0_36
+#else
+#define NL80211_IFTYPE_P2P_DEVICE	10
+#define WLAN_EID_BSS_MAX_IDLE_PERIOD	90
+
+struct ieee80211_scan_ies {
+	const u8 *ies[IEEE80211_NUM_BANDS];
+	size_t len[IEEE80211_NUM_BANDS];
+	const u8 *common_ies;
+	size_t common_ie_len;
+};
+#endif
+
+int nrc_mac80211_init(struct nrc *nr);
+void nrc_mac80211_exit(struct nrc *nr);
+
+struct nrc *nrc_alloc_hw(struct platform_device *pdev);
+void nrc_free_hw(struct nrc *nw);
+
+int nrc_register_hw(struct nrc *nw);
+void nrc_unregister_hw(struct nrc *nw);
+
+void nrc_kick_txq(struct ieee80211_hw *hw);
+int nrc_handle_frame(struct nrc *nw, struct sk_buff *skb);
+void nrc_mac_cancel_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
+
+struct net_device *nrc_get_intf_by_name(const char *intf_name);
+
+#ifdef CONFIG_SUPPORT_AFTER_KERNEL_3_0_36
+void nrc_mac_tx(struct ieee80211_hw *hw, struct ieee80211_tx_control *control,
+		struct sk_buff *skb);
+#else
+void nrc_mac_tx(struct ieee80211_hw *hw,
+		struct sk_buff *skb);
+#endif
+#ifdef CONFIG_SUPPORT_CHANNEL_INFO
+int nrc_mac_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+		    u16 ac, const struct ieee80211_tx_queue_params *params);
+#else
+int nrc_mac_conf_tx(struct ieee80211_hw *hw,
+		    u16 ac, const struct ieee80211_tx_queue_params *params);
+#endif
+void nrc_mac_bss_info_changed(struct ieee80211_hw *hw,
+				     struct ieee80211_vif *vif,
+				     struct ieee80211_bss_conf *info,
+				     u32 changed);
+#ifdef CONFIG_SUPPORT_CHANNEL_INFO
+void nrc_mac_add_tlv_channel(struct sk_buff *skb,
+					struct cfg80211_chan_def *chandef);
+#else
+void nrc_mac_add_tlv_channel(struct sk_buff *skb,
+			struct ieee80211_conf *chandef);
+#endif
+int nrc_mac_sta_remove(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+		       struct ieee80211_sta *sta);
+void nrc_mac_stop(struct ieee80211_hw *hw);
+
+int nrc_mac_rx(struct nrc *nw, struct sk_buff *skb);
+void nrc_mac_trx_init(struct nrc *nw);
+
+bool nrc_mac_is_s1g(struct nrc *nw);
+bool nrc_access_vif(struct nrc *nw);
+
+void nrc_free_vif_index(struct nrc *nw, struct ieee80211_vif *vif);
+
+#ifdef CONFIG_NEW_REG_NOTIFIER
+void nrc_reg_notifier(struct wiphy *wiphy, struct regulatory_request *request);
+#else
+int nrc_reg_notifier(struct wiphy *wiphy, struct regulatory_request *request);
+#endif
+
+void nrc_mac_clean_txq(struct nrc *nw);
+
+#endif
diff --git a/drivers/staging/nrc/nrc-netlink.c b/drivers/staging/nrc/nrc-netlink.c
new file mode 100644
index 000000000000..5f16d4f9163d
--- /dev/null
+++ b/drivers/staging/nrc/nrc-netlink.c
@@ -0,0 +1,1744 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <net/genetlink.h>
+#include "nrc-mac80211.h"
+#include "nrc-netlink.h"
+#include "nrc.h"
+#include "wim.h"
+#include "nrc-debug.h"
+#include "nrc-hif.h"
+#include "nrc-stats.h"
+
+#define NRC_NETLINK_FAMILY_NAME	("NRC-NL-FAM")
+#define MAX_CAPIREQ_SIZE (32)
+#define MAX_HALOW_SIZE (32)
+
+static struct nrc *nrc_nw;
+
+
+#ifdef CONFIG_SUPPORT_NEW_NETLINK
+static int nrc_nl_pre_doit(const struct genl_ops *ops,
+			   struct sk_buff *skb, struct genl_info *info)
+#else
+static int nrc_nl_pre_doit(struct genl_ops *ops,
+			   struct sk_buff *skb, struct genl_info *info)
+#endif
+{
+	return 0;
+}
+
+#ifdef CONFIG_SUPPORT_NEW_NETLINK
+static void nrc_nl_post_doit(const struct genl_ops *ops,
+			     struct sk_buff *skb, struct genl_info *info)
+#else
+static void nrc_nl_post_doit(struct genl_ops *ops,
+			     struct sk_buff *skb, struct genl_info *info)
+#endif
+{
+}
+
+static bool nrc_set_stbc_rx(struct nrc *nw, u8 stream)
+{
+	struct ieee80211_supported_band *sband = NULL;
+
+	sband = &nw->bands[NL80211_BAND_2GHZ];
+
+	if (stream > 4)
+		return false;
+
+	if (stream == 0) {
+		sband->ht_cap.cap &= ~(IEEE80211_HT_CAP_RX_STBC);
+		return true;
+	}
+
+	sband->ht_cap.cap |= (stream << IEEE80211_HT_CAP_RX_STBC_SHIFT);
+
+	return true;
+}
+
+
+static const struct nla_policy nl_umac_policy[NL_WFA_CAPI_ATTR_LAST] = {
+	[NL_WFA_CAPI_INTF_ID]		= {.type = NLA_NUL_STRING},
+	[NL_WFA_CAPI_PARAM_NAME]	= {.type = NLA_NUL_STRING},
+	[NL_WFA_CAPI_PARAM_STR_VAL]	= {.type = NLA_NUL_STRING},
+	[NL_WFA_CAPI_PARAM_DESTADDR]	= {.type = NLA_UNSPEC, .len = ETH_ALEN},
+	[NL_WFA_CAPI_PARAM_MCS]		= {.type = NLA_U8},
+	[NL_WFA_CAPI_PARAM_TID]		= {.type = NLA_U8},
+	[NL_WFA_CAPI_PARAM_SMPS]	= {.type = NLA_U8},
+	[NL_WFA_CAPI_PARAM_STBC]	= {.type = NLA_U8},
+	[NL_WFA_CAPI_PARAM_VENDOR1]	= {.type = NLA_NUL_STRING},
+	[NL_WFA_CAPI_PARAM_VENDOR2]	= {.type = NLA_NUL_STRING},
+	[NL_WFA_CAPI_PARAM_VENDOR3]	= {.type = NLA_NUL_STRING},
+	[NL_WFA_CAPI_PARAM_RESPONSE]	= {.type = NLA_NUL_STRING},
+	[NL_WFA_CAPI_PARAM_VIF_ID]  = {.type = NLA_S32},
+	[NL_WFA_CAPI_PARAM_BSS_MAX_IDLE_OFFSET]	= {.type = NLA_S32},
+	[NL_WFA_CAPI_PARAM_BSS_MAX_IDLE]		= {.type = NLA_S32},
+	[NL_SHELL_RUN_CMD]		= {.type = NLA_NUL_STRING},
+	[NL_CMD_LOG_MSG]		= {.type = NLA_NUL_STRING},
+	[NL_CMD_LOG_TYPE]		= {.type = NLA_U8},
+	[NL_MGMT_FRAME_INJECTION]	= {.type = NLA_U8},
+	[NL_HALOW_PARAM_NAME]		= {.type = NLA_NUL_STRING},
+	[NL_HALOW_PARAM_STR_VAL]	= {.type = NLA_NUL_STRING},
+	[NL_MIC_SCAN_CHANNEL_START] = {.type = NLA_S32},
+	[NL_MIC_SCAN_CHANNEL_END] = {.type = NLA_S32},
+	[NL_CMD_RECOVERY_MSG] = {.type = NLA_NUL_STRING},
+	[NL_FRAME_INJECTION_BUFFER] = {.type = NLA_NUL_STRING},
+	[NL_SET_IE_EID] = {.type = NLA_U16},
+	[NL_SET_IE_LENGTH] = {.type = NLA_U8},
+	[NL_SET_IE_DATA] = {.type = NLA_NUL_STRING},
+	[NL_SET_SAE_EID] = {.type = NLA_U16},
+	[NL_SET_SAE_LENGTH] = {.type = NLA_U16},
+	[NL_SET_SAE_DATA] = {.type = NLA_NUL_STRING},
+	[NL_SHELL_RUN_CMD_RAW]		= {.type = NLA_NUL_STRING},
+	[NL_AUTO_BA_ON]		= {.type = NLA_U8},
+};
+
+static const struct genl_multicast_group nl_umac_mcast_grps[] = {
+	[NL_MCGRP_WFA_CAPI_RESPONSE] = { .name = "response", },
+	[NL_MCGRP_NRC_LOG]			= { .name = "nrc-log", },
+};
+
+static struct genl_family nrc_nl_fam = {
+	.id		= GENL_ID_GENERATE,
+	.hdrsize	= 0,
+	.name		= NRC_NETLINK_FAMILY_NAME,
+	.version	= 1,
+	.maxattr	= MAX_NL_WFA_CAPI_ATTR,
+#if KERNEL_VERSION(5, 2, 0) <= NRC_TARGET_KERNEL_VERSION
+	.policy = nl_umac_policy,
+#endif
+#ifdef CONFIG_SUPPORT_NEW_NETLINK
+	.parallel_ops	= false,
+#endif
+	.netnsok	= true,
+	.pre_doit	= nrc_nl_pre_doit,
+	.post_doit	= nrc_nl_post_doit,
+#ifdef CONFIG_SUPPORT_AFTER_KERNEL_3_0_36
+	.mcgrps = nl_umac_mcast_grps,
+	.n_mcgrps = ARRAY_SIZE(nl_umac_mcast_grps),
+#endif
+};
+
+
+int nrc_netlink_rx(struct nrc *nw, struct sk_buff *skb, u8 subtype)
+{
+	struct sk_buff *mcast_skb;
+	void *data;
+
+#ifdef CONFIG_SUPPORT_GENLMSG_DEFAULT
+	mcast_skb = genlmsg_new(GENLMSG_DEFAULT_SIZE, GFP_KERNEL);
+#else
+	mcast_skb = genlmsg_new(NLMSG_DEFAULT_SIZE - GENL_HDRLEN, GFP_KERNEL);
+#endif
+
+	if (!mcast_skb)
+		return -1;
+
+	data = genlmsg_put(mcast_skb, 0, 0, &nrc_nl_fam, 0, NL_CMD_LOG_EVENT);
+
+	skb_put(skb, 1);
+	skb->data[skb->len-1] = 0;
+
+	nla_put_string(mcast_skb, NL_CMD_LOG_MSG, skb->data);
+	nla_put_u8(mcast_skb, NL_CMD_LOG_TYPE, subtype);
+	genlmsg_end(mcast_skb, data);
+
+#ifdef CONFIG_SUPPORT_GENLMSG_DEFAULT
+	genlmsg_multicast(&nrc_nl_fam,
+			mcast_skb,
+			0,
+			NL_MCGRP_NRC_LOG,
+			GFP_KERNEL);
+#else
+	genlmsg_multicast(mcast_skb,
+			0,
+			NL_MCGRP_NRC_LOG,
+			GFP_KERNEL);
+#endif
+
+	dev_kfree_skb(skb);
+
+	return 0;
+}
+
+int nrc_netlink_trigger_recovery(struct nrc *nw)
+{
+	struct sk_buff *mcast_skb;
+	void *data;
+
+#ifdef CONFIG_SUPPORT_GENLMSG_DEFAULT
+	mcast_skb = genlmsg_new(GENLMSG_DEFAULT_SIZE, GFP_KERNEL);
+#else
+	mcast_skb = genlmsg_new(NLMSG_DEFAULT_SIZE - GENL_HDRLEN, GFP_KERNEL);
+#endif
+
+	if (!mcast_skb)
+		return -1;
+
+	data = genlmsg_put(mcast_skb, 0, 0, &nrc_nl_fam, 0, NL_CMD_RECOVERY);
+	nla_put_string(mcast_skb, NL_CMD_RECOVERY_MSG, "recovery");
+	genlmsg_end(mcast_skb, data);
+
+#ifdef CONFIG_SUPPORT_GENLMSG_DEFAULT
+	genlmsg_multicast(&nrc_nl_fam,
+			mcast_skb,
+			0,
+			NL_MCGRP_NRC_LOG,
+			GFP_KERNEL);
+#else
+	genlmsg_multicast(mcast_skb,
+			0,
+			NL_MCGRP_NRC_LOG,
+			GFP_KERNEL);
+#endif
+
+	return 0;
+}
+
+static int capi_sta_reply(int id, struct genl_info *info, const char *response)
+{
+	struct sk_buff *msg;
+	void *hdr;
+
+#ifdef CONFIG_SUPPORT_GENLMSG_DEFAULT
+	msg = genlmsg_new(GENLMSG_DEFAULT_SIZE, GFP_KERNEL);
+	hdr = genlmsg_put(msg, info->snd_portid, info->snd_seq, &nrc_nl_fam,
+			0 /*no flags*/, id);
+#else
+	msg = genlmsg_new(NLMSG_DEFAULT_SIZE - GENL_HDRLEN, GFP_KERNEL);
+	hdr = genlmsg_put(msg, info->snd_pid, info->snd_seq, &nrc_nl_fam,
+			0 /*no flags*/, id);
+#endif
+	nla_put_string(msg, NL_WFA_CAPI_PARAM_RESPONSE, response);
+	genlmsg_end(msg, hdr);
+
+	return genlmsg_reply(msg, info);
+}
+
+static int capi_sta_reply_ok(int id, struct genl_info *info)
+{
+	return capi_sta_reply(id, info, NL_WFA_CAPI_RESP_OK);
+}
+
+static int capi_sta_reply_fail(int id, struct genl_info *info)
+{
+	return capi_sta_reply(id, info, NL_WFA_CAPI_RESP_ERR);
+}
+
+static int halow_reply(int id, struct genl_info *info, const char *response)
+{
+	struct sk_buff *msg;
+	void *hdr;
+
+#ifdef CONFIG_SUPPORT_GENLMSG_DEFAULT
+	msg = genlmsg_new(GENLMSG_DEFAULT_SIZE, GFP_KERNEL);
+	hdr = genlmsg_put(msg, info->snd_portid, info->snd_seq, &nrc_nl_fam,
+			0 /*no flags*/, id);
+#else
+	msg = genlmsg_new(NLMSG_DEFAULT_SIZE - GENL_HDRLEN, GFP_KERNEL);
+	hdr = genlmsg_put(msg, info->snd_pid, info->snd_seq, &nrc_nl_fam,
+			0 /*no flags*/, id);
+#endif
+
+	nla_put_string(msg, NL_HALOW_RESPONSE, response);
+	genlmsg_end(msg, hdr);
+
+	return genlmsg_reply(msg, info);
+}
+
+
+/* capi_sta_get_info - return vendor specific information
+ *
+ * Wi-Fi Test Suite Control API Spec 7.17
+ *
+ * Return: vendor specfic information (can be multiple)
+ */
+static int capi_sta_get_info(struct sk_buff *skb, struct genl_info *info)
+{
+	struct sk_buff *msg;
+	void *hdr;
+	int rc = 0;
+
+	nrc_dbg(NRC_DBG_CAPI, "%s()", __func__);
+
+#ifdef CONFIG_SUPPORT_GENLMSG_DEFAULT
+	msg = genlmsg_new(GENLMSG_DEFAULT_SIZE, GFP_KERNEL);
+
+	hdr = genlmsg_put(msg, info->snd_portid, info->snd_seq, &nrc_nl_fam,
+			0, NL_WFA_CAPI_STA_GET_INFO);
+#else
+	msg = genlmsg_new(NLMSG_DEFAULT_SIZE - GENL_HDRLEN, GFP_KERNEL);
+
+	hdr = genlmsg_put(msg, info->snd_pid, info->snd_seq, &nrc_nl_fam,
+			0, NL_WFA_CAPI_STA_GET_INFO);
+#endif
+
+	if (hdr == NULL) {
+		nrc_dbg(NRC_DBG_CAPI, "Failed to generate resp. nlmsg");
+		return -EMSGSIZE;
+	}
+
+	nla_put_string(msg, NL_WFA_CAPI_PARAM_VENDOR1, "vendor_test1");
+	nla_put_string(msg, NL_WFA_CAPI_PARAM_VENDOR2, "vendor_test2");
+	nla_put_string(msg, NL_WFA_CAPI_PARAM_VENDOR3, "vendor_test3");
+
+	genlmsg_end(msg, hdr);
+
+	rc = genlmsg_reply(msg, info);
+
+	return rc;
+}
+
+static int halow_set_dut(struct sk_buff *skb, struct genl_info *info)
+{
+	uint8_t param_name[MAX_HALOW_SIZE] = {0,};
+	uint8_t str_value[MAX_HALOW_SIZE] = {0,};
+#if KERNEL_VERSION(5, 11, 0) <= NRC_TARGET_KERNEL_VERSION
+	nla_strscpy(param_name, info->attrs[NL_HALOW_PARAM_NAME],
+			nla_len(info->attrs[NL_HALOW_PARAM_NAME]));
+
+	nla_strscpy(str_value, info->attrs[NL_HALOW_PARAM_STR_VAL],
+			nla_len(info->attrs[NL_HALOW_PARAM_STR_VAL]));
+#else
+	nla_strlcpy(param_name, info->attrs[NL_HALOW_PARAM_NAME],
+			nla_len(info->attrs[NL_HALOW_PARAM_NAME]));
+
+	nla_strlcpy(str_value, info->attrs[NL_HALOW_PARAM_STR_VAL],
+			nla_len(info->attrs[NL_HALOW_PARAM_STR_VAL]));
+#endif
+
+	nrc_dbg(NRC_DBG_CAPI, "%s(name:\"%s\",val:\"%s\")", __func__,
+			param_name, str_value);
+
+	if (!strcasecmp(param_name, "AMPDU")) {
+		/* Enable or disable the AMPDU Aggregation feature
+		 * param = ["Enable"|"Disable"]
+		 */
+		if (!strcasecmp(str_value, "Enable")) {
+			nrc_nw->ampdu_supported = true;
+			nrc_nw->ampdu_reject = false;
+			nrc_nw->amsdu_supported = true;
+		} else if (!strcasecmp(str_value, "Disable")) {
+			nrc_nw->ampdu_supported = false;
+			nrc_nw->ampdu_reject = true;
+			nrc_nw->amsdu_supported = false;
+		} else {
+			nrc_dbg(NRC_DBG_CAPI, "%s Unsupported value (%s)",
+					__func__, str_value);
+			goto halow_not_supported;
+		}
+		skb = nrc_wim_alloc_skb(nrc_nw, WIM_CMD_SET, WIM_MAX_SIZE);
+		nrc_wim_skb_add_tlv(skb, WIM_TLV_AMSDU_SUPPORT,
+				sizeof(nrc_nw->ampdu_supported),
+				&nrc_nw->ampdu_supported);
+		nrc_xmit_wim_request(nrc_nw, skb);
+	} else if (!strcasecmp(param_name, "AMSDU")) {
+		/* Enable or disable the AMSDU Aggregation feature
+		 * param = ["Enable"|"Disable"]
+		 */
+		if (!strcasecmp(str_value, "enable"))
+			nrc_nw->amsdu_supported = false;
+		else if (!strcasecmp(str_value, "disable"))
+			nrc_nw->amsdu_supported = true;
+		else {
+			nrc_dbg(NRC_DBG_CAPI, "%s Unsupported value (%s)",
+					__func__, str_value);
+			goto halow_not_supported;
+		}
+		skb = nrc_wim_alloc_skb(nrc_nw, WIM_CMD_SET, WIM_MAX_SIZE);
+		nrc_wim_skb_add_tlv(skb, WIM_TLV_AMSDU_SUPPORT,
+				sizeof(nrc_nw->amsdu_supported),
+				&nrc_nw->amsdu_supported);
+		nrc_xmit_wim_request(nrc_nw, skb);
+	} else if (!strcasecmp(param_name, "Enable_SGI")) {
+		/* param = ["1M"|"2M"|"4M"|"8M"|"16M"|"All"] */
+		u32 sgi = BIT(WIM_BW_1M) | BIT(WIM_BW_2M) | BIT(WIM_BW_4M);
+
+		if (strcasecmp(str_value, "All") != 0)
+			goto halow_not_supported;
+
+		skb = nrc_wim_alloc_skb(nrc_nw, WIM_CMD_SET, WIM_MAX_SIZE);
+		nrc_wim_skb_add_tlv(skb, WIM_TLV_SGI, sizeof(sgi), &sgi);
+		nrc_xmit_wim_request(nrc_nw, skb);
+	} else if (!strcasecmp(param_name, "1mhz_ctrl_resp")) {
+		u32 val = 0;
+
+		if (!strcasecmp(str_value, "Enable"))
+			val = 1;
+		else if (!strcasecmp(str_value, "Disable"))
+			val = 0;
+		else
+			goto halow_not_supported;
+
+		skb = nrc_wim_alloc_skb(nrc_nw, WIM_CMD_SET, WIM_MAX_SIZE);
+		nrc_wim_skb_add_tlv(skb, WIM_TLV_1MHZ_CTRL_RSP, sizeof(val),
+				&val);
+		nrc_xmit_wim_request(nrc_nw, skb);
+
+	} else if (!strcasecmp(param_name, "Color_Indication")) {
+		long lcolor  = 0;
+		u32 color = 0;
+
+		if (kstrtol(str_value, 10, &lcolor) < 0)
+			goto halow_not_supported;
+		color = lcolor;
+		skb = nrc_wim_alloc_skb(nrc_nw, WIM_CMD_SET, WIM_MAX_SIZE);
+		nrc_wim_skb_add_tlv(skb, WIM_TLV_COLOR_IND, sizeof(color),
+				&color);
+		nrc_xmit_wim_request(nrc_nw, skb);
+
+	} else if (!strcasecmp(param_name, "Tim_Mode")) {
+		u32 val = 0;
+
+		if (!strcasecmp(str_value, "OLB"))
+			val = WIM_TIM_OLB;
+		else if (!strcasecmp(str_value, "Single_AID"))
+			val = WIM_TIM_SINGLE_AID;
+		else if (!strcasecmp(str_value, "BlockBitmap"))
+			val = WIM_TIM_BLOCK_BMP;
+		else
+			goto halow_not_supported;
+
+		skb = nrc_wim_alloc_skb(nrc_nw, WIM_CMD_SET, WIM_MAX_SIZE);
+		nrc_wim_skb_add_tlv(skb, WIM_TLV_S1G_TIM_MODE, sizeof(val),
+				&val);
+		nrc_xmit_wim_request(nrc_nw, skb);
+
+	} else if (!strcasecmp(param_name, "Disable_SGI")) {
+		u32 sgi = 0;
+
+		if (strcasecmp(str_value, "All") != 0)
+			goto halow_not_supported;
+
+		skb = nrc_wim_alloc_skb(nrc_nw, WIM_CMD_SET, WIM_MAX_SIZE);
+		nrc_wim_skb_add_tlv(skb, WIM_TLV_SGI, sizeof(sgi), &sgi);
+		nrc_xmit_wim_request(nrc_nw, skb);
+	} else if (!strcasecmp(param_name, "Block_Frame")) {
+		if (!strcasecmp(str_value, "Enable"))
+			nrc_nw->block_frame = true;
+		else if (!strcasecmp(str_value, "Disable"))
+			nrc_nw->block_frame = false;
+		else
+			goto halow_not_supported;
+	} else if (!strcasecmp(param_name, "Keep_Alive")) {
+		if (!strcasecmp(str_value, "data")) {
+			int band;
+			struct sk_buff *b;
+			struct ieee80211_vif *vif = nrc_nw->vif[0];
+#ifdef CONFIG_SUPPORT_CHANNEL_INFO
+			struct ieee80211_chanctx_conf *chanctx_conf;
+#else
+			struct ieee80211_conf *chanctx_conf;
+#endif
+			struct ieee80211_tx_control control = {
+				.sta = ieee80211_find_sta(vif,
+						vif->bss_conf.bssid)
+			};
+#if KERNEL_VERSION(4, 14, 17) <= NRC_TARGET_KERNEL_VERSION
+			b = ieee80211_nullfunc_get(nrc_nw->hw, vif, false);
+#else
+			b = ieee80211_nullfunc_get(nrc_nw->hw, vif);
+#endif
+			skb_set_queue_mapping(b, IEEE80211_AC_VO);
+#ifdef CONFIG_SUPPORT_CHANNEL_INFO
+			chanctx_conf = rcu_dereference(vif->chanctx_conf);
+			band = chanctx_conf->def.chan->band;
+
+			if (!ieee80211_tx_prepare_skb(nrc_nw->hw,
+				   vif, b, band, NULL))
+				goto halow_not_supported;
+#else
+			chanctx_conf = &nrc_nw->hw->conf;
+			band = chanctx_conf->channel->band;
+#endif
+			nrc_xmit_frame(nrc_nw, hw_vifindex(vif), (!!control.sta ? control.sta->aid : 0), b);
+		} else
+			goto halow_not_supported;
+
+	} else if (!strcasecmp(param_name, "STA_Type")) {
+		/* SGI20 Enable or disable the Short Guard Interval feature
+		 * param = ["Sensor"|"Non-sensor"|"Both"]
+		 */
+		u32 sta = 0;
+		bool pv1_enable = false;
+
+		if (!strcasecmp(str_value, "Sensor")) {
+			sta = WIM_S1G_STA_TYPE_SENSOR;
+			pv1_enable = true;
+		} else if (!strcasecmp(str_value, "Non_Sensor")) {
+			sta = WIM_S1G_STA_TYPE_NON_SENSOR;
+		} else if (!strcasecmp(str_value, "Both")) {
+			sta = WIM_S1G_STA_TYPE_BOTH;
+			pv1_enable = true;
+		} else
+			goto halow_not_supported;
+
+		skb = nrc_wim_alloc_skb(nrc_nw, WIM_CMD_SET, WIM_MAX_SIZE);
+		nrc_wim_skb_add_tlv(skb, WIM_TLV_S1G_STA_TYPE, sizeof(sta),
+				&sta);
+		nrc_wim_skb_add_tlv(skb, WIM_TLV_S1G_PV1, sizeof(pv1_enable),
+				&pv1_enable);
+		nrc_xmit_wim_request(nrc_nw, skb);
+	} else if (!strcasecmp(param_name, "Operating_Channel")) {
+		goto halow_not_supported;
+	} else if (!strcasecmp(param_name, "Primary_Channel")) {
+		goto halow_not_supported;
+	} else if (!strcasecmp(param_name, "Bandwidth")) {
+		goto halow_not_supported;
+	} else if (!strcasecmp(param_name, "1Mhz_Duplicated_PPDU")) {
+		goto halow_not_supported;
+	} else if (!strcasecmp(param_name, "ACK_Policy")) {
+		goto halow_not_supported;
+	} else
+		goto halow_not_supported;
+
+	return halow_reply(NL_HALOW_SET_DUT, info, NL_HALOW_RESP_OK);
+
+halow_not_supported:
+	return halow_reply(NL_HALOW_SET_DUT, info, NL_HALOW_RESP_NOT_SUPP);
+}
+
+
+/* capi_sta_set_11n - set 11n STA settings
+ *
+ * This function must not be called during RIFS testing.
+ *
+ * According to the spec, CA should send "ERROR" response back
+ * when the request command is not supported,
+ * otherwise CA does not need to response
+ *
+ * Wi-Fi Test Suite Control API Spec 7.47
+ *
+ * Return: "COMPLETE" or "ERROR"
+ *
+ */
+static int capi_sta_set_11n(struct sk_buff *skb, struct genl_info *info)
+{
+	uint8_t param_name[MAX_CAPIREQ_SIZE] = {0,};
+	uint8_t str_value[MAX_CAPIREQ_SIZE] = {0,};
+	uint16_t u8_value = 0;
+
+#if KERNEL_VERSION(5, 11, 0) <= NRC_TARGET_KERNEL_VERSION
+	nla_strscpy(param_name, info->attrs[NL_WFA_CAPI_PARAM_NAME],
+			nla_len(info->attrs[NL_WFA_CAPI_PARAM_NAME]));
+
+	nla_strscpy(str_value, info->attrs[NL_WFA_CAPI_PARAM_STR_VAL],
+			nla_len(info->attrs[NL_WFA_CAPI_PARAM_STR_VAL]));
+#else
+	nla_strlcpy(param_name, info->attrs[NL_WFA_CAPI_PARAM_NAME],
+			nla_len(info->attrs[NL_WFA_CAPI_PARAM_NAME]));
+
+	nla_strlcpy(str_value, info->attrs[NL_WFA_CAPI_PARAM_STR_VAL],
+			nla_len(info->attrs[NL_WFA_CAPI_PARAM_STR_VAL]));
+#endif
+
+	nrc_dbg(NRC_DBG_CAPI, "%s(name:\"%s\",val:\"%s\")", __func__,
+			param_name, str_value);
+
+	if (!strcasecmp(param_name, "40_Intolerant")) {
+		/* Enable or disable the 40 MHz Intolerant feature
+		 * param = ["Enable"|"Disable"]
+		 */
+		nrc_dbg(NRC_DBG_CAPI, "%s(%s, %s)", __func__, param_name,
+				str_value);
+		goto wfa_not_supported;
+	} else if (!strcasecmp(param_name, "ADDBA_Reject")) {
+		/* Enable or disable the rejecting any ADDBA request by sending
+		 * ADDBA response with the status decline
+		 * param = ["Enable"|"Disable"]
+		 */
+		nrc_dbg(NRC_DBG_CAPI, "%s(%s, %s)", __func__, param_name,
+				str_value);
+
+		if (!strcasecmp(str_value, "enable")) {
+			nrc_nw->ampdu_supported = false;
+
+		} else if (!strcasecmp(str_value, "disable")) {
+			nrc_nw->ampdu_supported = true;
+		} else {
+			nrc_dbg(NRC_DBG_CAPI, "%s Unsupported value (%s)",
+					__func__, str_value);
+		}
+
+	} else if (!strcasecmp(param_name, "AMPDU")) {
+		/* Enable or disable the AMPDU Aggregation feature
+		 * param = ["Enable"|"Disable"]
+		 */
+		nrc_dbg(NRC_DBG_CAPI, "%s(%s, %s)", __func__, param_name,
+				str_value);
+		if (!strcasecmp(str_value, "enable")) {
+			nrc_nw->ampdu_supported = false;
+
+		} else if (!strcasecmp(str_value, "disable")) {
+			nrc_nw->ampdu_supported = true;
+		} else {
+			nrc_dbg(NRC_DBG_CAPI, "%s Unsupported value (%s)",
+					__func__, str_value);
+		}
+
+	} else if (!strcasecmp(param_name, "AMSDU")) {
+		/* Enable or disable the AMSDU Aggregation feature
+		 * param = ["Enable"|"Disable"]
+		 */
+		nrc_dbg(NRC_DBG_CAPI, "%s(%s, %s)", __func__, param_name,
+				str_value);
+
+		if (!strcasecmp(str_value, "enable")) {
+			nrc_nw->amsdu_supported = false;
+
+		} else if (!strcasecmp(str_value, "disable")) {
+			nrc_nw->amsdu_supported = true;
+		} else {
+			nrc_dbg(NRC_DBG_CAPI, "%s Unsupported value (%s)",
+					__func__, str_value);
+		}
+
+	} else if (!strcasecmp(param_name, "Greenfield")) {
+		/* Enable or disable the HT Greenfield feature
+		 * param = ["Enable"|"Disable"]
+		 */
+		nrc_dbg(NRC_DBG_CAPI, "%s(%s, %s)", __func__, param_name,
+				str_value);
+		goto wfa_not_supported;
+	} else if (!strcasecmp(param_name, "MCS_FixedRate")) {
+		/* Fixed MCS rate
+		 * param = [0...31]
+		 */
+		long lmcs = 0;
+		u32 mcs = 0;
+		int ret;
+
+		if (kstrtol(str_value, 10, &lmcs) < 0)
+			goto wfa_not_supported;
+		if (lmcs < 0 || lmcs > 32)
+			goto wfa_not_supported;
+		mcs = lmcs;
+		if (!nrc_nw)
+			goto wfa_not_supported;
+		skb = nrc_wim_alloc_skb(nrc_nw, WIM_CMD_SET, WIM_MAX_SIZE);
+		nrc_wim_skb_add_tlv(skb, WIM_TLV_MCS, sizeof(mcs), &mcs);
+		ret = nrc_xmit_wim_request(nrc_nw, skb);
+
+		if (ret < 0) {
+			nrc_dbg(NRC_DBG_CAPI, "%s: Failed to send WIM_CMD (MCS) ",
+				__func__);
+			goto wfa_not_supported;
+		}
+
+	} else if (!strcasecmp(param_name, "MCS32")) {
+		/* Enable or disable HT Duplicate Mode
+		 * param = ["Enable"|"Disable"]
+		 */
+		nrc_dbg(NRC_DBG_CAPI, "%s(%s, %s)", __func__, param_name,
+				str_value);
+		goto wfa_not_supported;
+	} else if (!strcasecmp(param_name, "Reset_Default")) {
+		/* Reset the station to program's default configuration
+		 * param = "11n"
+		 */
+		nrc_dbg(NRC_DBG_CAPI, "%s(%s, %s)", __func__, param_name,
+				str_value);
+	} else if (!strcasecmp(param_name, "RIFS")) {
+		/* Enable/disable the RIFS feature
+		 * param = ["Enable"|"Disable"]
+		 */
+		nrc_dbg(NRC_DBG_CAPI, "%s(%s, %s)", __func__, param_name,
+				str_value);
+	} else if (!strcasecmp(param_name, "RXSP_Stream")) {
+		/* Rx spatial streams
+		 * param = ["1SS"|"2SS"|"3SS"]
+		 */
+		nrc_dbg(NRC_DBG_CAPI, "%s(%s, %s)", __func__, param_name,
+				str_value);
+
+	} else if (!strcasecmp(param_name, "SGI20")) {
+		/* SGI20 Enable or disable the Short Guard Interval feature
+		 * param = ["Enable"|"Disable"]
+		 */
+		nrc_dbg(NRC_DBG_CAPI, "%s(%s, %s)", __func__, param_name,
+				str_value);
+	} else if (!strcasecmp(param_name, "SMPS")) {
+		/* SM Power Save Mode
+		 * param = [0...2]
+		 */
+		nrc_dbg(NRC_DBG_CAPI, "%s(%s, %d)", __func__, param_name,
+				u8_value);
+		goto wfa_not_supported;
+	} else if (!strcasecmp(param_name, "STBC_RX")) {
+		/* STBC receive streams
+		 * param = [0...4]
+		 */
+		long lstbc;
+
+		if (kstrtol(str_value, 10, &lstbc) < 0)
+			goto wfa_not_supported;
+
+		if (lstbc < 0 || lstbc > 4)
+			goto wfa_not_supported;
+
+		if (!nrc_set_stbc_rx(nrc_nw, (u8)lstbc))
+			goto wfa_not_supported;
+	} else if (!strcasecmp(param_name, "STBC_TX")) {
+		/* STBC transmit streams
+		 * param = [0...4]
+		 */
+		u8 stbc;
+
+		if (!info->attrs[NL_WFA_CAPI_PARAM_STBC])
+			return -EINVAL;
+		stbc = nla_get_u8(info->attrs[NL_WFA_CAPI_PARAM_STBC]);
+
+		nrc_dbg(NRC_DBG_CAPI, "%s(%s, %d)", __func__, param_name,
+				stbc);
+		goto wfa_not_supported;
+	} else if (!strcasecmp(param_name, "TXSP_Stream")) {
+		/* Tx spatial stream
+		 * param = ["1SS"|"2SS"|"3SS"]
+		 */
+		nrc_dbg(NRC_DBG_CAPI, "%s(%s, %s)", __func__, param_name,
+				str_value);
+	} else if (!strcasecmp(param_name, "Width")) {
+		/* 802.11n channel width
+		 * param = ["20"|"40"|"Auto"]
+		 */
+		nrc_dbg(NRC_DBG_CAPI, "%s(%s, %s)", __func__, param_name,
+				str_value);
+	} else {
+		return capi_sta_reply_fail(NL_WFA_CAPI_STA_SET_11N, info);
+	}
+	return capi_sta_reply_ok(NL_WFA_CAPI_STA_SET_11N, info);
+
+wfa_not_supported:
+		return capi_sta_reply_fail(NL_WFA_CAPI_STA_SET_11N, info);
+}
+
+/**
+ * Design: find the station vif, and sta corresponding to the
+ * serving AP. If there are more than one active station interface,
+ * we simply find the first one.
+ */
+struct capi_data {
+	struct ieee80211_vif *vif;
+	struct ieee80211_sta *sta;
+	u8 tid;
+	u8 *addr;
+	bool done;
+};
+
+static void capi_send_addba(void *data, u8 *mac, struct ieee80211_vif *vif)
+{
+	struct capi_data *c = data;
+	struct ieee80211_sta *sta;
+	u64 now = 0, diff = 0;
+
+	now = ktime_to_us(ktime_get_real());
+
+	rcu_read_lock();
+	if (vif->type == NL80211_IFTYPE_STATION) {
+		if (!vif->bss_conf.assoc)
+			goto out;
+
+		if (c->addr && !ether_addr_equal(c->addr, vif->bss_conf.bssid))
+			goto out;
+
+		sta = ieee80211_find_sta(vif, vif->bss_conf.bssid);
+	} else {
+		if (!c->addr)
+			goto out;
+		sta = ieee80211_find_sta(vif, c->addr);
+	}
+
+	if (!sta)
+		goto out;
+
+	ieee80211_start_tx_ba_session(sta, c->tid, 0);
+	c->done = true;
+
+ out:
+	rcu_read_unlock();
+	diff = ktime_to_us(ktime_get_real()) - now;
+	if ((!diff) || (diff > NRC_MAC80211_RCU_LOCK_THRESHOLD))
+		nrc_mac_dbg("%s, diff=%lu", __func__, (unsigned long)diff);
+}
+
+/* capi_sta_send_addba - Send ADDBA Request to associated AP
+ *
+ * Wi-Fi Test Suite Control API Spec 7.47
+ *
+ * @Interface : Interface ID
+ * @TID : Traffic ID
+ * Return: "None"
+ */
+static int capi_sta_send_addba(struct sk_buff *skb, struct genl_info *info)
+{
+	struct capi_data param = { 0 };
+
+	nrc_nw->ampdu_supported = true;
+
+	if (!info->attrs[NL_WFA_CAPI_PARAM_TID])
+		return capi_sta_reply(NL_WFA_CAPI_SEND_ADDBA, info,
+				NL_WFA_CAPI_RESP_ERR);
+
+	param.tid  = nla_get_u8(info->attrs[NL_WFA_CAPI_PARAM_TID]);
+	if (info->attrs[NL_WFA_CAPI_PARAM_DESTADDR])
+		param.addr = nla_data(info->attrs[NL_WFA_CAPI_PARAM_DESTADDR]);
+
+	nrc_dbg(NRC_DBG_CAPI, "%s(%d,%pM)", __func__, param.tid, param.addr);
+
+#ifdef CONFIG_SUPPORT_ITERATE_INTERFACE
+	ieee80211_iterate_active_interfaces(nrc_nw->hw, 0, capi_send_addba,
+					    &param);
+#else
+	ieee80211_iterate_active_interfaces(nrc_nw->hw, capi_send_addba,
+					    &param);
+#endif
+	if (!param.done)
+		pr_err("WFA_CAPI: failed to send ADDBA");
+
+	return capi_sta_reply(NL_WFA_CAPI_SEND_ADDBA, info,
+			      param.done ?
+			      NL_WFA_CAPI_RESP_OK : NL_WFA_CAPI_RESP_ERR);
+}
+
+static void capi_send_delba(void *data, u8 *mac, struct ieee80211_vif *vif)
+{
+	struct capi_data *c = data;
+	struct ieee80211_sta *sta;
+	u64 now = 0, diff = 0;
+
+	now = ktime_to_us(ktime_get_real());
+
+	rcu_read_lock();
+	if (vif->type == NL80211_IFTYPE_STATION) {
+		if (!vif->bss_conf.assoc)
+			goto out;
+
+		if (c->addr && !ether_addr_equal(c->addr, vif->bss_conf.bssid))
+			goto out;
+
+		sta = ieee80211_find_sta(vif, vif->bss_conf.bssid);
+	} else {
+		if (!c->addr)
+			goto out;
+		sta = ieee80211_find_sta(vif, c->addr);
+	}
+
+	if (!sta)
+		goto out;
+
+	ieee80211_stop_tx_ba_session(sta, c->tid);
+	c->done = true;
+
+ out:
+	rcu_read_unlock();
+	diff = ktime_to_us(ktime_get_real()) - now;
+	if ((!diff) || (diff > NRC_MAC80211_RCU_LOCK_THRESHOLD))
+		nrc_mac_dbg("%s, diff=%lu", __func__, (unsigned long)diff);
+}
+
+/* capi_sta_send_delba - Send DELBA Request to associated AP
+ */
+static int capi_sta_send_delba(struct sk_buff *skb, struct genl_info *info)
+{
+	struct capi_data param = { 0 };
+
+	nrc_nw->ampdu_supported = true;
+
+	if (!info->attrs[NL_WFA_CAPI_PARAM_TID])
+		return capi_sta_reply(NL_WFA_CAPI_SEND_DELBA, info,
+				NL_WFA_CAPI_RESP_ERR);
+
+	param.tid  = nla_get_u8(info->attrs[NL_WFA_CAPI_PARAM_TID]);
+	if (info->attrs[NL_WFA_CAPI_PARAM_DESTADDR])
+		param.addr = nla_data(info->attrs[NL_WFA_CAPI_PARAM_DESTADDR]);
+
+	nrc_dbg(NRC_DBG_CAPI, "%s(%d,%pM)", __func__, param.tid, param.addr);
+
+#ifdef CONFIG_SUPPORT_ITERATE_INTERFACE
+	ieee80211_iterate_active_interfaces(nrc_nw->hw, 0, capi_send_delba,
+					    &param);
+#else
+	ieee80211_iterate_active_interfaces(nrc_nw->hw, capi_send_delba,
+					    &param);
+#endif
+	if (!param.done)
+		pr_err("WFA_CAPI: failed to send DELBA");
+
+	return capi_sta_reply(NL_WFA_CAPI_SEND_DELBA, info,
+			      param.done ?
+			      NL_WFA_CAPI_RESP_OK : NL_WFA_CAPI_RESP_ERR);
+}
+
+/**************************************************************************//**
+ * FunctionName	: capi_bss_max_idle_offset
+ * Description	: Set the offset of max bss idle timer through netlink.
+ *				  Use below parameter passed via Netlink
+ *				  NL_WFA_CAPI_PARAM_BSS_MAX_IDLE_OFFSET: S32
+ * Parameters	: skb(struct sk_buff*)
+ *				: info(struct genl_info*)
+ * Returns		: int(capi_sta_reply)
+ */
+static int capi_bss_max_idle_offset(struct sk_buff *skb, struct genl_info *info)
+{
+	int32_t bss_max_idle_offset;
+
+	if (!info->attrs[NL_WFA_CAPI_PARAM_BSS_MAX_IDLE_OFFSET])
+		return capi_sta_reply(NL_WFA_CAPI_BSS_MAX_IDLE_OFFSET, info,
+				NL_WFA_CAPI_RESP_ERR);
+
+	bss_max_idle_offset = nla_get_s32(
+		   info->attrs[NL_WFA_CAPI_PARAM_BSS_MAX_IDLE_OFFSET]);
+	nrc_set_bss_max_idle_offset(bss_max_idle_offset);
+
+	nrc_dbg(NRC_DBG_CAPI, "%s(%d)", __func__, bss_max_idle_offset);
+
+	return capi_sta_reply(NL_WFA_CAPI_BSS_MAX_IDLE_OFFSET, info,
+			NL_WFA_CAPI_RESP_NONE);
+}
+
+static int s1g_unscaled_interval_max = 0x3fff;
+static int convert_usf(int interval)
+{
+	int ui, usf = 0, interval_usf;
+
+	if (interval <= s1g_unscaled_interval_max) {
+		ui = interval;
+		usf = 0;
+	} else if (interval / 10 <= s1g_unscaled_interval_max) {
+		ui= interval / 10;
+		usf = 1;
+	} else if (interval / 1000 <= s1g_unscaled_interval_max) {
+		ui = interval / 1000;
+		usf = 2;
+        } else if (interval / 10000 <= s1g_unscaled_interval_max) {
+		ui = interval / 10000;
+		usf = 3;
+	} else {
+		ui = 0;
+		usf = 0;
+        }
+
+	interval_usf = (usf << 14) + ui;
+
+	return interval_usf;
+}
+
+/*
+ * FunctionName	: capi_bss_max_idle
+ * Description	: Set the max bss idle through netlink.
+ *					Use below parameter passed via Netlink
+ *					NL_WFA_CAPI_PARAM_BSS_MAX_IDLE: S32
+ *					NL_WFA_CAPI_PARAM_VIF_ID: S32
+ *					NL_WFA_CAPI_PARAM_BSS_MAX_IDLE_OFFSET: S32 //AUTO_USF Setting
+ * Parameters	: skb(struct sk_buff*)
+ *				: info(struct genl_info*)
+ * Returns		: int(capi_sta_reply)
+ */
+static int capi_bss_max_idle(struct sk_buff *skb, struct genl_info *info)
+{
+	int32_t max_idle, vif_id, no_usf_auto_convert;
+	struct ieee80211_vif *vif;
+
+	if ((!info->attrs[NL_WFA_CAPI_PARAM_BSS_MAX_IDLE]) ||
+		(!info->attrs[NL_WFA_CAPI_PARAM_VIF_ID])) {
+		return capi_sta_reply(NL_WFA_CAPI_BSS_MAX_IDLE, info,
+				NL_WFA_CAPI_RESP_ERR);
+	}
+
+	max_idle = nla_get_s32(info->attrs[NL_WFA_CAPI_PARAM_BSS_MAX_IDLE]);
+	vif_id = nla_get_s32(info->attrs[NL_WFA_CAPI_PARAM_VIF_ID]);
+	no_usf_auto_convert = nla_get_s32(info->attrs[NL_WFA_CAPI_PARAM_BSS_MAX_IDLE_OFFSET]);
+
+	vif = nrc_nw->vif[vif_id];
+
+	nrc_dbg(NRC_DBG_CAPI, "%s (no_usf_auto_convert:%d) (max_idle:%d)",
+		__func__, no_usf_auto_convert, max_idle);
+
+	if (vif) {
+		struct nrc_vif *i_vif;
+		i_vif = to_i_vif(vif);
+		if (nrc_mac_is_s1g(nrc_nw->hw->priv) && max_idle) {
+			/* bss_max_idle: in unit of 1000 TUs (1024ms = 1.024 seconds) */
+			if (max_idle > 16383 * 10000 || max_idle <= 0) {
+				i_vif->max_idle_period = 0;
+			} else {
+				/* (Default) Convert in USF Format (Value (14bit) * USF(2bit)) and save it */
+				if (no_usf_auto_convert) {
+					i_vif->max_idle_period = max_idle;
+				} else {
+					i_vif->max_idle_period = convert_usf(max_idle);
+				}
+			}
+		} else {
+			if (max_idle > 65535 || max_idle <= 0) {
+				i_vif->max_idle_period = 0;
+			} else {
+				i_vif->max_idle_period = max_idle;
+			}
+		}
+		nrc_dbg(NRC_DBG_CAPI, "%s max_idle(%d) vs converted_max_idle(%d)", __func__, max_idle, i_vif->max_idle_period);
+	}
+
+	return capi_sta_reply(NL_WFA_CAPI_BSS_MAX_IDLE, info,
+			vif != NULL ?
+			NL_WFA_CAPI_RESP_NONE : NL_WFA_CAPI_RESP_ERR);
+}
+
+static void generate_mmic_error(void *data, u8 *mac, struct ieee80211_vif *vif)
+{
+	struct capi_data *c = data;
+	struct ieee80211_sta *sta;
+	struct sk_buff *skb;
+	struct ieee80211_rx_status *rx_status;
+	struct ieee80211_hdr *hdr;
+#ifdef CONFIG_SUPPORT_CHANNEL_INFO
+	struct ieee80211_chanctx_conf *chan;
+#else
+	struct ieee80211_conf *chan;
+#endif
+	u64 now = 0, diff = 0;
+
+	if (vif->type != NL80211_IFTYPE_STATION || !vif->bss_conf.assoc)
+		return;
+
+	if (c->addr && !ether_addr_equal(c->addr, vif->bss_conf.bssid))
+		return;
+
+	now = ktime_to_us(ktime_get_real());
+
+	rcu_read_lock();
+	sta = ieee80211_find_sta(vif, vif->bss_conf.bssid);
+	if (!sta)
+		goto out;
+
+	skb = dev_alloc_skb(1000);
+
+	hdr = (struct ieee80211_hdr *)skb_put(skb, sizeof(*hdr));
+	skb_put(skb, 500);
+
+	hdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_DATA |
+					 IEEE80211_STYPE_DATA |
+					 IEEE80211_FCTL_FROMDS);
+
+	ether_addr_copy(hdr->addr1, mac);
+	ether_addr_copy(hdr->addr2, vif->bss_conf.bssid);
+	ether_addr_copy(hdr->addr3, vif->bss_conf.bssid);
+
+	rx_status = IEEE80211_SKB_RXCB(skb);
+
+#ifdef CONFIG_SUPPORT_CHANNEL_INFO
+	chan = rcu_dereference(vif->chanctx_conf);
+	if (!chan)
+		goto out;
+
+	rx_status->freq = chan->def.chan->center_freq;
+	rx_status->band = chan->def.chan->band;
+#else
+	chan = &nrc_nw->hw->conf;
+	if (!chan)
+		goto out;
+
+	rx_status->freq = chan->channel->center_freq;
+	rx_status->band = chan->channel->band;
+#endif
+	rx_status->flag = (RX_FLAG_DECRYPTED | RX_FLAG_MMIC_STRIPPED |
+			   RX_FLAG_MMIC_ERROR);
+
+	ieee80211_rx_irqsafe(nrc_nw->hw, skb);
+
+	c->done = true;
+
+ out:
+	rcu_read_unlock();
+	diff = ktime_to_us(ktime_get_real()) - now;
+	if ((!diff) || (diff > NRC_MAC80211_RCU_LOCK_THRESHOLD))
+		nrc_mac_dbg("%s, diff=%lu", __func__, (unsigned long)diff);
+}
+
+/* test_mmic_failure - Trigger MMIC failture event to cfg80211
+ *
+ * @ TID : Traffic ID, "0" will be used if TID is omitted.
+ * @ SA	: Source Address,  BSSID will be used if SA is omitted.
+ * Return: "Ok" if success, "Fail" if failed
+ */
+static int test_mmic_failure(struct sk_buff *skb, struct genl_info *info)
+{
+	struct capi_data param = { 0 };
+
+	if (info->attrs[NL_WFA_CAPI_PARAM_TID])
+		param.tid  = nla_get_u8(info->attrs[NL_WFA_CAPI_PARAM_TID]);
+
+	if (info->attrs[NL_WFA_CAPI_PARAM_DESTADDR])
+		param.addr = nla_data(info->attrs[NL_WFA_CAPI_PARAM_DESTADDR]);
+
+	nrc_dbg(NRC_DBG_CAPI, "%s(%d,%pM)", __func__, param.tid, param.addr);
+
+#ifdef CONFIG_SUPPORT_ITERATE_INTERFACE
+	ieee80211_iterate_active_interfaces(nrc_nw->hw, 0, generate_mmic_error,
+					    &param);
+#else
+	ieee80211_iterate_active_interfaces(nrc_nw->hw, generate_mmic_error,
+					    &param);
+#endif
+
+	if (!param.done)
+		pr_err("WFA_CAPI: failed to generate MMIC failure");
+
+	return capi_sta_reply(NL_TEST_MMIC_FAILURE, info,
+			      param.done ?
+			      NL_WFA_CAPI_RESP_NONE : NL_WFA_CAPI_RESP_ERR);
+}
+
+static int nrc_inject_mgmt_frame(struct sk_buff *skb, struct genl_info *info)
+{
+	struct sk_buff *skb_mgmt = NULL;
+	struct ieee80211_hdr_3addr *hdr = NULL;
+	const int tailroom = 100;
+	u8 injector[ETH_ALEN] = {0x2, 0x0, 0x1, 0x1, 0x1, 0x1};
+	/*u8 *pos;*/
+	u8 stype = 0;
+
+	if (info->attrs[NL_MGMT_FRAME_INJECTION_STYPE])
+		stype = nla_get_u8(info->attrs[NL_MGMT_FRAME_INJECTION_STYPE]);
+	else
+		goto fail_over;
+
+	skb_mgmt = dev_alloc_skb(nrc_nw->hw->extra_tx_headroom + sizeof(*hdr) +
+			+ tailroom);
+	skb_reserve(skb_mgmt, nrc_nw->hw->extra_tx_headroom);
+
+	hdr = (struct ieee80211_hdr_3addr *) skb_put(skb_mgmt, sizeof(*hdr));
+	hdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT | (stype << 4));
+	/* TO DO - consider multiple vifs */
+	ether_addr_copy(hdr->addr1, nrc_nw->mac_addr[0].addr);
+	ether_addr_copy(hdr->addr2, injector);
+	/* TO DO - consider multiple vifs */
+	ether_addr_copy(hdr->addr3, nrc_nw->mac_addr[0].addr);
+
+	switch (stype << 4) {
+	case IEEE80211_STYPE_AUTH:
+		/* Authentication Algorithm */
+		put_unaligned_le16(0, skb_put(skb_mgmt, 2));
+		/* Authentication SEQ */
+		put_unaligned_le16(1, skb_put(skb_mgmt, 2));
+		/* Status code */
+		put_unaligned_le16(0, skb_put(skb_mgmt, 2));
+		break;
+	case IEEE80211_STYPE_ASSOC_REQ:
+		/* Capabilities Information */
+		put_unaligned_le16(0x0421, skb_put(skb_mgmt, 2));
+		/* Listen Interval */
+		put_unaligned_le16(10, skb_put(skb_mgmt, 2));
+		break;
+	default:
+		goto fail_over;
+	}
+	ieee80211_rx_irqsafe(nrc_nw->hw, skb_mgmt);
+	return 0;
+
+fail_over:
+	if (skb_mgmt)
+		dev_kfree_skb(skb_mgmt);
+
+	return 0;
+}
+
+static int nrc_shell_run_simple(struct sk_buff *skb, struct genl_info *info)
+{
+	char *cmd = NULL;
+	struct sk_buff *wim_skb;
+
+	if (!nrc_access_vif(nrc_nw)) {
+		nrc_dbg(NRC_DBG_CAPI, "%s Can't send command", __func__);
+		return -EIO;
+	}
+
+	if (info->attrs[NL_SHELL_RUN_CMD])
+		cmd = nla_data(info->attrs[NL_SHELL_RUN_CMD]);
+
+	if (!cmd)
+		return -EINVAL;
+
+	wim_skb = nrc_wim_alloc_skb(nrc_nw, WIM_CMD_SHELL, WIM_MAX_SIZE);
+
+	if (!wim_skb)
+		return -EINVAL;
+
+	nrc_wim_skb_add_tlv(wim_skb, WIM_TLV_SHELL_CMD, strlen(cmd)+1, cmd);
+	nrc_xmit_wim_request(nrc_nw, wim_skb);
+
+	return 0;
+}
+
+enum nrc_shell_run_state {
+	NRC_SHELL_IDLE,
+	NRC_SHELL_RUNNING
+};
+
+static int nrc_shell_running_state;
+
+static void set_shell_run_state(int state)
+{
+	nrc_shell_running_state = state;
+}
+
+static int get_shell_run_state(void)
+{
+	return nrc_shell_running_state;
+}
+
+static int nrc_shell_run(struct sk_buff *skb, struct genl_info *info)
+{
+	char *cmd = NULL;
+	char cmd_resp[512];
+	struct sk_buff *msg, *wim_skb, *wim_resp;
+	void *hdr;
+
+	if (!nrc_access_vif(nrc_nw)) {
+		nrc_dbg(NRC_DBG_CAPI, "%s Can't send command", __func__);
+		return -EIO;
+	}
+
+#ifdef CONFIG_SUPPORT_GENLMSG_DEFAULT
+	msg = genlmsg_new(GENLMSG_DEFAULT_SIZE, GFP_KERNEL);
+	hdr = genlmsg_put(msg, info->snd_portid, info->snd_seq, &nrc_nl_fam,
+			0 /*no flags*/, NL_SHELL_RUN_CMD);
+#else
+	msg = genlmsg_new(NLMSG_DEFAULT_SIZE - GENL_HDRLEN, GFP_KERNEL);
+	hdr = genlmsg_put(msg, info->snd_pid, info->snd_seq, &nrc_nl_fam,
+			0 /*no flags*/, NL_SHELL_RUN_CMD);
+#endif
+
+	if (info->attrs[NL_SHELL_RUN_CMD])
+		cmd = nla_data(info->attrs[NL_SHELL_RUN_CMD]);
+
+	if (get_shell_run_state() != NRC_SHELL_IDLE) {
+		strcpy(cmd_resp, "Failed");
+		nla_put_string(msg, NL_SHELL_RUN_CMD_RESP, cmd_resp);
+		genlmsg_end(msg, hdr);
+		return genlmsg_reply(msg, info);
+	}
+	set_shell_run_state(NRC_SHELL_RUNNING);
+
+	if (!cmd)
+		return -EINVAL;
+
+	wim_skb = nrc_wim_alloc_skb(nrc_nw, WIM_CMD_SHELL, WIM_MAX_SIZE);
+
+	if (!wim_skb)
+		return -EINVAL;
+
+	nrc_wim_skb_add_tlv(wim_skb, WIM_TLV_SHELL_CMD, strlen(cmd)+1, cmd);
+
+	wim_resp = nrc_xmit_wim_request_wait(nrc_nw, wim_skb,
+			(WIM_RESP_TIMEOUT * 300));
+
+	if (wim_resp) {
+		struct wim *wim = (struct wim *)wim_resp->data;
+
+		if (wim->cmd == WIM_CMD_SHELL) {
+			struct wim_tlv *tlv = (struct wim_tlv *)(wim + 1);
+
+			memcpy(cmd_resp, &tlv->v, tlv->l);
+			cmd_resp[tlv->l] = 0;
+			nrc_dbg(NRC_DBG_CAPI, "%s[%s]", __func__,
+					cmd_resp);
+		}
+		dev_kfree_skb(wim_resp);
+	} else {
+		strcpy(cmd_resp, "Failed");
+	}
+
+	nla_put_string(msg, NL_SHELL_RUN_CMD_RESP, cmd_resp);
+	genlmsg_end(msg, hdr);
+
+	set_shell_run_state(NRC_SHELL_IDLE);
+
+	return genlmsg_reply(msg, info);
+}
+
+static int nrc_shell_run_raw(struct sk_buff *skb, struct genl_info *info)
+{
+	char *cmd = NULL;
+	char cmd_resp[512];
+	struct sk_buff *msg, *wim_skb, *wim_resp;
+	void *hdr;
+
+	if (!nrc_access_vif(nrc_nw)) {
+		nrc_dbg(NRC_DBG_CAPI, "%s Can't send command", __func__);
+		return -EIO;
+	}
+
+#ifdef CONFIG_SUPPORT_GENLMSG_DEFAULT
+	msg = genlmsg_new(GENLMSG_DEFAULT_SIZE, GFP_KERNEL);
+	hdr = genlmsg_put(msg, info->snd_portid, info->snd_seq, &nrc_nl_fam,
+			0 /*no flags*/, NL_SHELL_RUN_CMD_RAW);
+#else
+	msg = genlmsg_new(NLMSG_DEFAULT_SIZE - GENL_HDRLEN, GFP_KERNEL);
+	hdr = genlmsg_put(msg, info->snd_pid, info->snd_seq, &nrc_nl_fam,
+			0 /*no flags*/, NL_SHELL_RUN_CMD);
+#endif
+	if (info->attrs[NL_SHELL_RUN_CMD_RAW])
+		cmd = nla_data(info->attrs[NL_SHELL_RUN_CMD_RAW]);
+
+	if (get_shell_run_state() != NRC_SHELL_IDLE) {
+		strcpy(cmd_resp, "Failed");
+		nla_put_string(msg, NL_SHELL_RUN_CMD_RESP_RAW, cmd_resp);
+		genlmsg_end(msg, hdr);
+		return genlmsg_reply(msg, info);
+	}
+	set_shell_run_state(NRC_SHELL_RUNNING);
+	if (!cmd)
+		return -EINVAL;
+
+	wim_skb = nrc_wim_alloc_skb(nrc_nw, WIM_CMD_SHELL_RAW, WIM_MAX_SIZE);
+	if (!wim_skb)
+		return -EINVAL;
+
+	nrc_wim_skb_add_tlv(wim_skb, WIM_TLV_SHELL_CMD, strlen(cmd)+1, cmd);
+	wim_resp = nrc_xmit_wim_request_wait(nrc_nw, wim_skb,
+			(WIM_RESP_TIMEOUT * 300));
+	if (wim_resp) {
+		struct wim *wim = (struct wim *)wim_resp->data;
+		if (wim->cmd == WIM_CMD_SHELL_RAW) {
+			struct wim_tlv *tlv = (struct wim_tlv *)(wim + 1);
+			memcpy(cmd_resp, &tlv->v, tlv->l);
+			//cmd_resp[tlv->l] = 0;
+			//nrc_dbg(NRC_DBG_CAPI, "%s[%s]", __func__,
+			//		cmd_resp);
+			nla_put(msg, NL_SHELL_RUN_CMD_RESP_RAW, tlv->l, cmd_resp);
+		}
+		dev_kfree_skb(wim_resp);
+	} else {
+		strcpy(cmd_resp, "Failed");
+	}
+
+	//nla_put_string(msg, NL_SHELL_RUN_CMD_RESP_RAW, cmd_resp);
+
+	genlmsg_end(msg, hdr);
+
+	set_shell_run_state(NRC_SHELL_IDLE);
+
+	return genlmsg_reply(msg, info);
+}
+
+/* cli_app_get_info - api for cli application
+ *
+ * Return: rssi & snr
+ */
+static int cli_app_get_info(struct sk_buff *skb, struct genl_info *info)
+{
+	char *cmd = NULL;
+	char cmd_resp[512];
+	struct sk_buff *msg;
+	void *hdr;
+	int total_count = 0;
+	int start_point = 0;
+	const int max_number_per_response = 20;
+	char *str = NULL;
+	int i = 0;
+
+	memset(cmd_resp, 0x0, sizeof(cmd_resp));
+
+	if (!nrc_access_vif(nrc_nw)) {
+		nrc_dbg(NRC_DBG_CAPI, "%s Can't send command", __func__);
+		return -EIO;
+	}
+
+#ifdef CONFIG_SUPPORT_GENLMSG_DEFAULT
+	msg = genlmsg_new(GENLMSG_DEFAULT_SIZE, GFP_KERNEL);
+	hdr = genlmsg_put(msg, info->snd_portid, info->snd_seq, &nrc_nl_fam,
+			0 /*no flags*/, NL_SHELL_RUN_CMD);
+#else
+	msg = genlmsg_new(NLMSG_DEFAULT_SIZE - GENL_HDRLEN, GFP_KERNEL);
+	hdr = genlmsg_put(msg, info->snd_pid, info->snd_seq, &nrc_nl_fam,
+			0 /*no flags*/, NL_SHELL_RUN_CMD);
+#endif
+
+	if (info->attrs[NL_SHELL_RUN_CMD])
+		cmd = nla_data(info->attrs[NL_SHELL_RUN_CMD]);
+
+	if (!cmd)
+		return -EINVAL;
+
+	if (strcmp(cmd, "show signal -sr -num") == 0) {
+		//start monitoring
+		signal_monitor = true;
+		nrc_dbg(NRC_DBG_CAPI, "%s Start Signal Monitor (%d)", __func__, signal_monitor);
+		total_count = nrc_stats_report_count();
+		sprintf(cmd_resp, "%d,%d", total_count,
+				   max_number_per_response);
+	} else if (strcmp(cmd, "show signal stop") == 0) {
+		//stop monitoring
+		signal_monitor = false;
+		nrc_dbg(NRC_DBG_CAPI, "%s Stop Signal Monitor (%d)", __func__, signal_monitor);
+		sprintf(cmd_resp, "okay");
+	} else {
+		str = strrchr(cmd, ' ');
+		for (i = 1; str[i] != '\0'; ++i)
+			start_point = start_point * 10 + str[i] - '0';
+
+		nrc_stats_report(cmd_resp, start_point, max_number_per_response);
+	}
+	nla_put_string(msg, NL_SHELL_RUN_CMD_RESP, cmd_resp);
+	genlmsg_end(msg, hdr);
+
+	return genlmsg_reply(msg, info);
+}
+
+static int nrc_mic_scan(struct sk_buff *skb, struct genl_info *info)
+{
+	struct sk_buff *msg, *wim_skb, *wim_resp;
+	struct wim_channel_1m_param channel;
+	struct wim_channel_1m_param resp;
+	void *hdr;
+	int count = 0;
+
+	channel.channel_start = nla_get_s32(
+				   info->attrs[NL_MIC_SCAN_CHANNEL_START]);
+	channel.channel_end = nla_get_s32(
+				   info->attrs[NL_MIC_SCAN_CHANNEL_END]);
+
+	wim_skb = nrc_wim_alloc_skb(nrc_nw, WIM_CMD_MIC_SCAN,
+				   sizeof(struct wim_channel_1m_param));
+
+	if (!wim_skb)
+		return -EINVAL;
+
+	count = (channel.channel_end - channel.channel_start) / 10;
+	nrc_wim_skb_add_tlv(wim_skb, WIM_TLV_CCA_1M,
+				   sizeof(struct wim_channel_1m), &channel);
+
+	wim_resp = nrc_xmit_wim_request_wait(nrc_nw, wim_skb,
+				   (WIM_RESP_TIMEOUT * 10 * count));
+
+	if (wim_resp) {
+		struct wim *wim = (struct wim *)wim_resp->data;
+
+		if (wim->cmd == WIM_CMD_MIC_SCAN) {
+			struct wim_tlv *tlv = (struct wim_tlv *)(wim + 1);
+
+			memcpy(&resp, &tlv->v, tlv->l);
+		}
+		dev_kfree_skb(wim_resp);
+	}
+
+	msg = genlmsg_new(NLMSG_DEFAULT_SIZE - GENL_HDRLEN, GFP_KERNEL);
+	hdr = genlmsg_put(msg, info->snd_portid, info->snd_seq, &nrc_nl_fam,
+			0 /*no flags*/, NL_MIC_SCAN);
+
+	nla_put_u32(msg, NL_MIC_SCAN_CHANNEL_BITMAP, resp.cca_bitmap);
+	genlmsg_end(msg, hdr);
+
+	return genlmsg_reply(msg, info);
+}
+
+static int nrc_inject_frame(struct sk_buff *skb, struct genl_info *info)
+{
+	struct sk_buff *buffer;
+	uint8_t *frame;
+	int length = nla_len(info->attrs[NL_FRAME_INJECTION_BUFFER]);
+
+	buffer = dev_alloc_skb(nrc_nw->hw->extra_tx_headroom + length);
+	skb_reserve(buffer, nrc_nw->hw->extra_tx_headroom);
+	frame = skb_put(buffer, length - 1);
+#if KERNEL_VERSION(5, 11, 0) <= NRC_TARGET_KERNEL_VERSION
+	nla_strscpy(frame, info->attrs[NL_FRAME_INJECTION_BUFFER], length);
+#else
+	nla_strlcpy(frame, info->attrs[NL_FRAME_INJECTION_BUFFER], length);
+#endif
+
+	nrc_xmit_injected_frame(nrc_nw, NULL, NULL, buffer);
+
+	return 0;
+}
+
+static int nrc_set_ie(struct sk_buff *skb, struct genl_info *info)
+{
+	struct sk_buff *wim_skb;
+	struct wim_set_ie_param ie;
+
+	ie.eid = nla_get_u16(info->attrs[NL_SET_IE_EID]);
+	ie.length = nla_get_u8(info->attrs[NL_SET_IE_LENGTH]);
+
+#if KERNEL_VERSION(5, 11, 0) <= NRC_TARGET_KERNEL_VERSION
+	nla_strscpy(ie.data, info->attrs[NL_SET_IE_DATA],
+		nla_len(info->attrs[NL_SET_IE_DATA]));
+#else
+	nla_strlcpy(ie.data, info->attrs[NL_SET_IE_DATA],
+		nla_len(info->attrs[NL_SET_IE_DATA]));
+#endif
+	wim_skb = nrc_wim_alloc_skb(nrc_nw, WIM_CMD_SET_IE,
+		sizeof(struct wim_set_ie_param));
+
+	if (!wim_skb)
+		return -EINVAL;
+
+	nrc_wim_skb_add_tlv(wim_skb, WIM_TLV_IE_PARAM,
+		sizeof(struct wim_set_ie_param), &ie);
+	nrc_xmit_wim_request(nrc_nw, wim_skb);
+
+	return 0;
+}
+
+static int nrc_set_sae(struct sk_buff *skb, struct genl_info *info)
+{
+	// 10/27/2020 Shinwoo Lee
+	// Annotated debug messages out, but left them for future debugging
+
+	struct sk_buff *wim_skb;
+	struct wim_set_sae_param sae;
+	int i;
+	// nrc_dbg(NRC_DBG_WIM, "nrc-netlink driver Log (before copying eid)\n");
+	sae.eid = nla_get_u16(info->attrs[NL_SET_SAE_EID]);
+	// nrc_dbg(NRC_DBG_WIM, "nrc-netlink driver Log (before copying length)\n");
+	sae.length = nla_get_u16(info->attrs[NL_SET_SAE_LENGTH]);
+
+	for (i=0; i< sae.length; i++) {
+		if (i==0) nrc_dbg(NRC_DBG_WIM, "Data: %x", *(info->attrs[NL_SET_SAE_DATA]));
+		else nrc_dbg(NRC_DBG_WIM, "%x", *(info->attrs[NL_SET_SAE_DATA]+i));
+	}
+	// nrc_dbg(NRC_DBG_WIM, "nrc-netlink driver Log (before copying data)\n");
+#if KERNEL_VERSION(5, 11, 0) <= NRC_TARGET_KERNEL_VERSION
+	nla_strscpy(sae.data, info->attrs[NL_SET_SAE_DATA], sae.length+1);
+#else
+	nla_strlcpy(sae.data, info->attrs[NL_SET_SAE_DATA], sae.length+1);
+#endif
+	wim_skb = nrc_wim_alloc_skb(nrc_nw, WIM_CMD_SET_SAE,
+		sizeof(struct wim_set_sae_param));
+
+	// nrc_dbg_enable(NRC_DBG_WIM);
+	// nrc_dbg(NRC_DBG_WIM, "nrc-netlink driver log (after copying data)\n");
+	// nrc_dbg(NRC_DBG_WIM, "----------------------\n");
+	// nrc_dbg(NRC_DBG_WIM, "EID: %d\n", sae.eid);
+	// nrc_dbg(NRC_DBG_WIM, "Length: %d\n", sae.length);
+	// for (i=0; i<sae.length; i++) {
+	// 	if (i==0) nrc_dbg(NRC_DBG_WIM, "Data: %x", *(sae.data+i));
+	// 	else nrc_dbg(NRC_DBG_WIM, "%x", *(sae.data+i));
+	// }
+	// nrc_dbg(NRC_DBG_WIM, "\n----------------------\n");
+
+	if (!wim_skb)
+		return -EINVAL;
+
+	// nrc_dbg(NRC_DBG_WIM, "nrc-netlink driver log (add tlv)\n");
+	// nrc_dbg(NRC_DBG_WIM, "----------------------\n");
+	// nrc_dbg(NRC_DBG_WIM, "size of tlv : %d\n", sizeof(struct wim_set_sae_param));
+
+	nrc_wim_skb_add_tlv(wim_skb, WIM_TLV_SAE_PARAM, sizeof(struct wim_set_sae_param), &sae);
+	nrc_xmit_wim_request(nrc_nw, wim_skb);
+
+	return 0;
+}
+
+static int nrc_auto_ba_toggle(struct sk_buff *skb, struct genl_info *info)
+{
+	nrc_set_auto_ba(nla_get_u8(info->attrs[NL_AUTO_BA_ON]) ? true : false);
+	return 0;
+}
+
+#ifdef CONFIG_SUPPORT_GENLMSG_DEFAULT
+static const struct genl_ops nl_umac_nl_ops[] = {
+#else
+static struct genl_ops nl_umac_nl_ops[] = {
+#endif
+	{
+		.cmd	= NL_WFA_CAPI_STA_GET_INFO,
+		.doit	= capi_sta_get_info,
+#if KERNEL_VERSION(5, 2, 0) > NRC_TARGET_KERNEL_VERSION
+		.policy = nl_umac_policy,
+#endif
+	},
+	{
+		.cmd	= NL_WFA_CAPI_STA_SET_11N,
+		.doit	= capi_sta_set_11n,
+#if KERNEL_VERSION(5, 2, 0) > NRC_TARGET_KERNEL_VERSION
+		.policy = nl_umac_policy,
+#endif
+	},
+	{
+		.cmd	= NL_WFA_CAPI_SEND_ADDBA,
+		.doit	= capi_sta_send_addba,
+#if KERNEL_VERSION(5, 2, 0) > NRC_TARGET_KERNEL_VERSION
+		.policy = nl_umac_policy,
+#endif
+	},
+	{
+		.cmd	= NL_WFA_CAPI_SEND_DELBA,
+		.doit	= capi_sta_send_delba,
+#if KERNEL_VERSION(5, 2, 0) > NRC_TARGET_KERNEL_VERSION
+		.policy = nl_umac_policy,
+#endif
+	},
+	{
+		.cmd	= NL_WFA_CAPI_BSS_MAX_IDLE,
+		.doit	= capi_bss_max_idle,
+#if KERNEL_VERSION(5, 2, 0) > NRC_TARGET_KERNEL_VERSION
+		.policy = nl_umac_policy,
+#endif
+	},
+	{
+		.cmd	= NL_WFA_CAPI_BSS_MAX_IDLE_OFFSET,
+		.doit	= capi_bss_max_idle_offset,
+#if KERNEL_VERSION(5, 2, 0) > NRC_TARGET_KERNEL_VERSION
+		.policy = nl_umac_policy,
+#endif
+	},
+	{
+		.cmd	= NL_TEST_MMIC_FAILURE,
+		.doit	= test_mmic_failure,
+#if KERNEL_VERSION(5, 2, 0) > NRC_TARGET_KERNEL_VERSION
+		.policy = nl_umac_policy,
+#endif
+	},
+	{
+		.cmd	= NL_SHELL_RUN,
+		.doit	= nrc_shell_run,
+#if KERNEL_VERSION(5, 2, 0) > NRC_TARGET_KERNEL_VERSION
+		.policy = nl_umac_policy,
+#endif
+	},
+	{
+		.cmd	= NL_SHELL_RUN_SIMPLE,
+		.doit	= nrc_shell_run_simple,
+#if KERNEL_VERSION(5, 2, 0) > NRC_TARGET_KERNEL_VERSION
+		.policy = nl_umac_policy,
+#endif
+	},
+	{
+		.cmd	= NL_MGMT_FRAME_INJECTION,
+		.doit	= nrc_inject_mgmt_frame,
+#if KERNEL_VERSION(5, 2, 0) > NRC_TARGET_KERNEL_VERSION
+		.policy = nl_umac_policy,
+#endif
+	},
+	{
+		.cmd	= NL_HALOW_SET_DUT,
+		.doit	= halow_set_dut,
+#if KERNEL_VERSION(5, 2, 0) > NRC_TARGET_KERNEL_VERSION
+		.policy = nl_umac_policy,
+#endif
+	},
+	{
+		.cmd	= NL_CLI_APP_GET_INFO,
+		.doit	= cli_app_get_info,
+#if KERNEL_VERSION(5, 2, 0) > NRC_TARGET_KERNEL_VERSION
+		.policy = nl_umac_policy,
+#endif
+	},
+	{
+		.cmd	= NL_MIC_SCAN,
+		.doit	= nrc_mic_scan,
+#if KERNEL_VERSION(5, 2, 0) > NRC_TARGET_KERNEL_VERSION
+		.policy = nl_umac_policy,
+#endif
+	},
+	{
+		.cmd	= NL_FRAME_INJECTION,
+		.doit	= nrc_inject_frame,
+#if KERNEL_VERSION(5, 2, 0) > NRC_TARGET_KERNEL_VERSION
+		.policy = nl_umac_policy,
+#endif
+	},
+	{
+		.cmd	= NL_SET_IE,
+		.doit	= nrc_set_ie,
+#if KERNEL_VERSION(5, 2, 0) > NRC_TARGET_KERNEL_VERSION
+		.policy = nl_umac_policy,
+#endif
+	},
+	{
+		.cmd	= NL_SET_SAE_DATA,
+		.doit	= nrc_set_sae,
+#if KERNEL_VERSION(5, 2, 0) > NRC_TARGET_KERNEL_VERSION
+		.policy = nl_umac_policy,
+#endif
+	},
+	{
+		.cmd	= NL_SHELL_RUN_RAW,
+		.doit	= nrc_shell_run_raw,
+#if KERNEL_VERSION(5, 2, 0) > NRC_TARGET_KERNEL_VERSION
+		.policy = nl_umac_policy,
+#endif
+	},
+	{
+		.cmd	= NL_AUTO_BA_TOGGLE,
+		.doit	= nrc_auto_ba_toggle,
+#if KERNEL_VERSION(5, 2, 0) > NRC_TARGET_KERNEL_VERSION
+		.policy = nl_umac_policy,
+#endif
+	},
+};
+
+
+static int nl_umac_notify(struct notifier_block *nb, unsigned long state,
+		void *notifier)
+{
+	if (state != NETLINK_URELEASE)
+		return NOTIFY_DONE;
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block nl_umac_netlink_notifier = {
+	.notifier_call = nl_umac_notify,
+};
+
+
+int nrc_netlink_init(struct nrc *nw)
+{
+	int rc = 0;
+#if KERNEL_VERSION(4, 10, 0) <= NRC_TARGET_KERNEL_VERSION
+	nrc_nl_fam.ops = nl_umac_nl_ops;
+	nrc_nl_fam.n_ops = ARRAY_SIZE(nl_umac_nl_ops);
+	rc = genl_register_family(&nrc_nl_fam);
+#else
+#ifdef CONFIG_SUPPORT_GENLMSG_DEFAULT
+	rc = genl_register_family_with_ops_groups(&nrc_nl_fam,
+						  nl_umac_nl_ops,
+						  nl_umac_mcast_grps);
+#else
+	rc = genl_register_family_with_ops(&nrc_nl_fam,
+					  nl_umac_nl_ops,
+					  ARRAY_SIZE(nl_umac_nl_ops));
+#endif
+#endif
+
+	if (rc) {
+		pr_err("genl_register_family_with_ops_groups() is failed (%d).",
+				rc);
+		return -EINVAL;
+	}
+
+	rc = netlink_register_notifier(&nl_umac_netlink_notifier);
+
+	if (rc) {
+		pr_err("netlink_register_notifier() is failed (%d).",
+				rc);
+		genl_unregister_family(&nrc_nl_fam);
+		return -EINVAL;
+	}
+
+	nrc_nw = nw;
+	return 0;
+}
+
+void nrc_netlink_exit(void)
+{
+	pr_err("%s", __func__);
+	netlink_unregister_notifier(&nl_umac_netlink_notifier);
+	genl_unregister_family(&nrc_nl_fam);
+}
diff --git a/drivers/staging/nrc/nrc-netlink.h b/drivers/staging/nrc/nrc-netlink.h
new file mode 100644
index 000000000000..dd54685ae306
--- /dev/null
+++ b/drivers/staging/nrc/nrc-netlink.h
@@ -0,0 +1,113 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _NRC_NETLINK_H_
+#define _NRC_NETLINK_H_
+
+struct nrc;
+
+/**
+ * README: match the numeric definition with nrcnetlink.py
+ * Must match nl cmd, attr as defined by the driver.
+ */
+enum nrc_nl_op_cmds {
+	NL_WFA_CAPI_STA_GET_INFO			= 0,
+	NL_WFA_CAPI_STA_SET_11N				= 1,
+	NL_WFA_CAPI_SEND_ADDBA				= 2,
+	NL_WFA_CAPI_SEND_DELBA				= 3,
+	NL_TEST_MMIC_FAILURE				= 4,
+	NL_SHELL_RUN						= 5,
+	NL_MGMT_FRAME_INJECTION				= 6,
+	NL_CMD_LOG_EVENT					= 7,
+	NL_SHELL_RUN_SIMPLE					= 8,
+	NL_HALOW_SET_DUT					= 9,
+	NL_CLI_APP_GET_INFO					= 10,
+	NL_WFA_CAPI_LISTEN_INTERVAL			= 11,
+	NL_WFA_CAPI_BSS_MAX_IDLE			= 12,
+	NL_WFA_CAPI_BSS_MAX_IDLE_OFFSET		= 13,
+	NL_MIC_SCAN							= 14,
+	NL_CMD_RECOVERY						= 15,
+	NL_FRAME_INJECTION					= 16,
+	NL_SET_IE							= 17,
+	NL_SET_SAE							= 18,
+	NL_SHELL_RUN_RAW                    = 19,
+	NL_AUTO_BA_TOGGLE                   = 20,
+};
+
+enum nrc_nl_op_attrs {
+	NL_WFA_CAPI_INTF_ID					= 0,
+	NL_WFA_CAPI_PARAM_NAME				= 1,
+	NL_WFA_CAPI_PARAM_STR_VAL			= 2,
+	NL_WFA_CAPI_PARAM_DESTADDR			= 3,
+	NL_WFA_CAPI_PARAM_MCS				= 4,
+	NL_WFA_CAPI_PARAM_TID				= 5,
+	NL_WFA_CAPI_PARAM_SMPS				= 6,
+	NL_WFA_CAPI_PARAM_STBC				= 7,
+	NL_WFA_CAPI_PARAM_VENDOR1			= 8,
+	NL_WFA_CAPI_PARAM_VENDOR2			= 9,
+	NL_WFA_CAPI_PARAM_VENDOR3			= 10,
+	NL_WFA_CAPI_PARAM_RESPONSE			= 11,
+	NL_SHELL_RUN_CMD					= 12,
+	NL_SHELL_RUN_CMD_RESP				= 13,
+	NL_MGMT_FRAME_INJECTION_STYPE		= 14,
+	NL_CMD_LOG_MSG						= 15,
+	NL_CMD_LOG_TYPE						= 16,
+	NL_HALOW_PARAM_NAME					= 17,
+	NL_HALOW_PARAM_STR_VAL				= 18,
+	NL_HALOW_RESPONSE					= 19,
+	NL_WFA_CAPI_PARAM_VIF_ID			= 20,
+	NL_WFA_CAPI_PARAM_BSS_MAX_IDLE		= 21,
+	NL_WFA_CAPI_PARAM_BSS_MAX_IDLE_OFFSET	= 22,
+	NL_WFA_CAPI_PARAM_LISTEN_INTERVAL	= 23,
+	NL_MIC_SCAN_CHANNEL_START			= 24,
+	NL_MIC_SCAN_CHANNEL_END				= 25,
+	NL_MIC_SCAN_CHANNEL_BITMAP			= 26,
+	NL_CMD_RECOVERY_MSG					= 27,
+	NL_FRAME_INJECTION_BUFFER			= 28,
+	NL_SET_IE_EID						= 29,
+	NL_SET_IE_LENGTH					= 30,
+	NL_SET_IE_DATA						= 31,
+	NL_SET_SAE_EID						= 32,
+	NL_SET_SAE_LENGTH					= 33,
+	NL_SET_SAE_DATA						= 34,
+	NL_SHELL_RUN_CMD_RAW				= 35,
+	NL_SHELL_RUN_CMD_RESP_RAW			= 36,
+	NL_AUTO_BA_ON						= 37,
+	NL_WFA_CAPI_ATTR_LAST,
+	MAX_NL_WFA_CAPI_ATTR = NL_WFA_CAPI_ATTR_LAST-1,
+};
+
+#define NL_WFA_CAPI_RESP_OK   ("COMPLETE")
+#define NL_WFA_CAPI_RESP_ERR  ("ERROR")
+#define NL_WFA_CAPI_RESP_NONE ("NONE")
+
+#define NL_HALOW_RESP_OK   ("OK")
+#define NL_HALOW_RESP_ERR  ("ERROR")
+#define NL_HALOW_RESP_NOT_SUPP  ("Not supported")
+
+
+enum nrc_nl_multicast_grp {
+	NL_MCGRP_WFA_CAPI_RESPONSE,
+	NL_MCGRP_NRC_LOG,
+	NL_MCGRP_LAST,
+};
+
+int nrc_netlink_init(struct nrc *nw);
+void nrc_netlink_exit(void);
+int nrc_netlink_rx(struct nrc *nw, struct sk_buff *skb, u8 subtype);
+int nrc_netlink_trigger_recovery(struct nrc *nw);
+
+#endif
diff --git a/drivers/staging/nrc/nrc-pm.c b/drivers/staging/nrc/nrc-pm.c
new file mode 100644
index 000000000000..8f57fc6ad150
--- /dev/null
+++ b/drivers/staging/nrc/nrc-pm.c
@@ -0,0 +1,683 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Power management features
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#include <linux/list.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <net/dst.h>
+#include <net/xfrm.h>
+#include <net/mac80211.h>
+#include <net/ieee80211_radiotap.h>
+#include <linux/if_arp.h>
+#include <linux/rtnetlink.h>
+#include <linux/etherdevice.h>
+#include <linux/platform_device.h>
+#include <linux/debugfs.h>
+#include <linux/module.h>
+#include <linux/ktime.h>
+#include <net/genetlink.h>
+#include <linux/spi/spi.h>
+#include <linux/ieee80211.h>
+
+#include "nrc-mac80211.h"
+#include "nrc-hif.h"
+#include "wim.h"
+#include "nrc-debug.h"
+
+/**
+ * DOC: STA powersaving
+ */
+
+static int tx_h_sta_pm(struct nrc_trx_data *tx)
+{
+#ifdef CONFIG_SUPPORT_AFTER_KERNEL_3_0_36
+	struct ieee80211_hw *hw = tx->nw->hw;
+#endif
+	struct sk_buff *skb = tx->skb;
+	struct ieee80211_tx_info *txi = IEEE80211_SKB_CB(skb);
+	struct ieee80211_hdr *mh = (void *) skb->data;
+	__le16 fc = mh->frame_control;
+
+#ifdef CONFIG_SUPPORT_PS
+	if (!ieee80211_hw_check(hw, SUPPORTS_PS) ||
+	    !(hw->conf.flags & IEEE80211_CONF_PS) ||
+	    hw->conf.dynamic_ps_timeout > 0)
+		return 0;
+#endif
+
+	if (tx->vif->type != NL80211_IFTYPE_STATION)
+		return 0;
+
+	/*
+	 * mac80211 does not set PM field for normal data frames, so we
+	 * need to update that based on the current PS mode.
+	 */
+	if (!(txi->flags & IEEE80211_TX_CTL_NO_ACK) &&
+	    ieee80211_is_data(fc) && !ieee80211_has_pm(fc)) {
+		mh->frame_control |= cpu_to_le16(IEEE80211_FCTL_PM);
+		fc = mh->frame_control;
+	}
+
+	if (ieee80211_is_pspoll(fc)) {
+		struct nrc_vif *i_vif = to_i_vif(tx->vif);
+
+		i_vif->ps_polling = true;
+	}
+
+	return 0;
+}
+TXH(tx_h_sta_pm, BIT(NL80211_IFTYPE_STATION));
+
+
+static void nrc_mac_rx_fictitious_ps_poll_response(struct ieee80211_vif *vif)
+{
+	struct nrc_vif *nvif = (struct nrc_vif *) vif->drv_priv;
+	struct nrc *nw = nvif->nw;
+	struct sk_buff *skb;
+	struct ieee80211_hdr_3addr *nullfunc;
+	struct ieee80211_rx_status *status;
+
+#if KERNEL_VERSION(4, 14, 17) <= NRC_TARGET_KERNEL_VERSION
+	skb = ieee80211_nullfunc_get(nw->hw, vif, false);
+#else
+	skb = ieee80211_nullfunc_get(nw->hw, vif);
+#endif
+	if (!skb)
+		return;
+
+	nullfunc = (struct ieee80211_hdr_3addr *) skb->data;
+	nullfunc->frame_control = cpu_to_le16(IEEE80211_FTYPE_DATA |
+					      IEEE80211_STYPE_NULLFUNC |
+					      IEEE80211_FCTL_FROMDS);
+
+	/* RA: vif->addr,TA = SA: vif->bss_conf->bssid */
+	ether_addr_copy(nullfunc->addr1, vif->addr);
+	ether_addr_copy(nullfunc->addr2, vif->bss_conf.bssid);
+	ether_addr_copy(nullfunc->addr3, vif->bss_conf.bssid);
+
+	status = IEEE80211_SKB_RXCB(skb);
+	memset(status, 0, sizeof(*status));
+	status->freq = nw->center_freq;
+	status->band = nw->band;
+	status->rate_idx = 0;
+
+	ieee80211_rx_irqsafe(nw->hw, skb);
+}
+
+/**
+ * rx_h_fixup_ps_poll_sp() - fix up the incomplete PS-Poll SP
+ *
+ * Once a non-AP STA does not receive a buffered frame in response
+ * to the PS-Poll it sent, the mac80211 does not send further PS-Poll
+ * even if TIM in the subsequent beacons includes the AID for this STA,
+ * until it receives a unicast frame destined to it.
+ *
+ * Our workaround is to pretend as if we had received a Null frame from
+ * the AP, when we receive another beacon from the AP (whether or not
+ * TIM includes the STA).
+ */
+static int rx_h_fixup_ps_poll_sp(struct nrc_trx_data *rx)
+{
+	struct ieee80211_hw *hw = rx->nw->hw;
+	struct nrc_vif *i_vif = to_i_vif(rx->vif);
+	struct ieee80211_hdr *mh = (void *) rx->skb->data;
+	__le16 fc = mh->frame_control;
+
+	if (!(hw->conf.flags & IEEE80211_CONF_PS) ||
+	    hw->conf.dynamic_ps_timeout > 0)
+		return 0;
+
+	/*
+	 * I am only interested if @rx->vif is of STATION type, and
+	 * it is in PS-Poll service period
+	 */
+	if (rx->vif->type != NL80211_IFTYPE_STATION || !i_vif->ps_polling)
+		return 0;
+
+	/* This frame is not coming from the serving AP */
+	if (!ether_addr_equal(ieee80211_get_SA(mh), rx->vif->bss_conf.bssid))
+		return 0;
+
+	if (ieee80211_is_beacon(fc)) {
+		i_vif->ps_polling = false;
+		nrc_mac_rx_fictitious_ps_poll_response(rx->vif);
+	} else if (ieee80211_is_data(fc))
+		i_vif->ps_polling = false;
+
+	return 0;
+}
+RXH(rx_h_fixup_ps_poll_sp, BIT(NL80211_IFTYPE_STATION));
+
+
+/**
+ * DOC: 802.11v
+ *
+ */
+
+static u8 *find_bss_max_idle_ie(struct sk_buff *skb)
+{
+	struct ieee80211_mgmt *mgmt = (void *) skb->data;
+	__le16 fc = mgmt->frame_control;
+	u8 *start, *end, *pos;
+
+	if (ieee80211_is_assoc_req(fc))
+		start = (u8 *) mgmt->u.assoc_req.variable;
+	else if (ieee80211_is_reassoc_req(fc))
+		start = (u8 *) mgmt->u.reassoc_req.variable;
+	else if (ieee80211_is_assoc_resp(fc) || ieee80211_is_reassoc_resp(fc))
+		start = (u8 *)mgmt->u.assoc_resp.variable;
+	else
+		return NULL;
+
+	end = skb->data + skb->len;
+
+	pos = (u8 *) cfg80211_find_ie(WLAN_EID_BSS_MAX_IDLE_PERIOD,
+				      start, end - start);
+	if (!pos || pos[1] != 3)
+		return NULL;
+
+	return pos + 2;
+}
+
+static int ieee80211_disconnect_sta(struct ieee80211_vif *vif,
+				    struct ieee80211_sta *sta)
+{
+	struct nrc_sta *i_sta = to_i_sta(sta);
+	struct ieee80211_hw *hw = i_sta->nw->hw;
+	struct sk_buff *skb;
+	struct ieee80211_tx_info *txi;
+#ifdef CONFIG_SUPPORT_TX_CONTROL
+	struct ieee80211_tx_control control = { .sta = sta, };
+#endif
+
+	/* Send a deauth to @sta */
+	skb = ieee80211_deauth_get(hw, sta->addr, vif->addr, vif->addr,
+				   WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY, sta, true);
+	if (!skb)
+		return -1;
+
+	skb_set_queue_mapping(skb, IEEE80211_AC_VO);
+
+	txi = IEEE80211_SKB_CB(skb);
+	txi->control.vif = vif;
+
+#ifdef CONFIG_SUPPORT_NEW_MAC_TX
+	nrc_mac_tx(hw, &control, skb);
+#else
+	nrc_mac_tx(hw, skb);
+#endif
+
+	/* Pretend to receive a deauth from @sta */
+	skb = ieee80211_deauth_get(hw, vif->addr, sta->addr, vif->addr,
+				   WLAN_REASON_DEAUTH_LEAVING, sta, false);
+	if (!skb)
+		return -1;
+
+	ieee80211_rx_irqsafe(hw, skb);
+
+
+	return 0;
+}
+#if KERNEL_VERSION(4, 15, 0) > LINUX_VERSION_CODE
+static void ap_max_idle_period_expire(unsigned long data)
+{
+	struct nrc_sta *i_sta = (struct nrc_sta *) data;
+#else
+static void ap_max_idle_period_expire(struct timer_list *t)
+{
+	struct nrc_max_idle *idle = from_timer(idle,
+			t, timer);
+	struct nrc_sta *i_sta = container_of(idle,
+			struct nrc_sta, max_idle);
+#endif
+	struct ieee80211_sta *sta = to_ieee80211_sta(i_sta);
+	struct ieee80211_vif *vif = i_sta->vif;
+	u16 max_limit_cnt = BSS_MAX_ILDE_DEAUTH_LIMIT_COUNT;
+	unsigned long period_jiffies = 0;
+
+	++i_sta->max_idle.timeout_cnt;
+
+	if (i_sta->max_idle.timeout_cnt >= max_limit_cnt) {
+		/* Inactivity (BSS MAX IDLE) timeout =>  disconnect the station */
+		i_sta->max_idle.timeout_cnt = 0;
+		nrc_mac_dbg("[AP] keep-alive fail! Disconnecting inactive sta:%pM",sta->addr);
+		ieee80211_disconnect_sta(vif, sta);
+	} else {
+		/* Re-arm the timer
+			: apply backoff for avoiding frequent deauth */
+		period_jiffies = i_sta->max_idle.idle_period;
+		if (i_sta->max_idle.timeout_cnt) {
+			period_jiffies *= i_sta->max_idle.timeout_cnt ;
+		}
+		mod_timer(&i_sta->max_idle.timer, jiffies + period_jiffies);
+		nrc_mac_dbg("[AP] keep-alive timeout!(cnt:%d vs limit:%d) Rearm timer(%u) STA(%pM)",
+			i_sta->max_idle.timeout_cnt , max_limit_cnt, period_jiffies, sta->addr);
+	}
+}
+
+
+#define IEEE80211_STYPE_QOS_NULL       0x00C0
+struct ieee80211_hdr_3addr_qos {
+	u16 frame_control;
+	u16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 addr3[ETH_ALEN];
+	u16 seq_ctl;
+	u16 qc;
+};
+
+#if KERNEL_VERSION(4, 15, 0) > NRC_TARGET_KERNEL_VERSION
+static void sta_max_idle_period_expire(unsigned long data)
+{
+	struct nrc_sta *i_sta = (struct nrc_sta *) data;
+#else
+static void sta_max_idle_period_expire(struct timer_list *t)
+{
+	struct nrc_max_idle *idle = from_timer(idle, t, timer);
+	struct nrc_sta *i_sta = container_of(idle,
+			struct nrc_sta, max_idle);
+#endif
+	struct ieee80211_hw *hw = i_sta->nw->hw;
+#ifdef CONFIG_SUPPORT_TX_CONTROL
+	struct ieee80211_tx_control control = {
+		.sta = to_ieee80211_sta(i_sta),
+	};
+#endif
+#ifdef CONFIG_SUPPORT_CHANNEL_INFO
+	struct ieee80211_chanctx_conf *chanctx_conf;
+#else
+	struct ieee80211_conf *chanctx_conf;
+#endif
+	struct sk_buff *skb;
+	int band;
+	struct ieee80211_hdr_3addr_qos *qosnullfunc;
+
+	nrc_mac_dbg("%s: sending a keep-alive (QoS Null Frame)", __func__);
+	/* Send a Null frame as a keep alive frame */
+#if KERNEL_VERSION(4, 14, 17) <= NRC_TARGET_KERNEL_VERSION
+	skb = ieee80211_nullfunc_get(hw, i_sta->vif, false);
+#else
+	skb = ieee80211_nullfunc_get(hw, i_sta->vif);
+#endif
+	skb_put(skb, 2);
+	qosnullfunc = (struct ieee80211_hdr_3addr_qos *) skb->data;
+	qosnullfunc->frame_control |= cpu_to_le16(IEEE80211_STYPE_QOS_NULL);
+	qosnullfunc->qc = cpu_to_le16(0);
+	skb_set_queue_mapping(skb, IEEE80211_AC_VO);
+
+#ifdef CONFIG_SUPPORT_CHANNEL_INFO
+	chanctx_conf = rcu_dereference(i_sta->vif->chanctx_conf);
+	if (!chanctx_conf)
+		goto drop;
+
+	band = chanctx_conf->def.chan->band;
+	if (!ieee80211_tx_prepare_skb(hw, i_sta->vif, skb, band, NULL))
+		goto drop;
+#else
+	chanctx_conf = &hw->conf;
+	if (!chanctx_conf)
+		goto drop;
+
+	band = chanctx_conf->channel->band;
+#endif
+
+#ifdef CONFIG_SUPPORT_NEW_MAC_TX
+	nrc_mac_tx(hw, &control, skb);
+#else
+	nrc_mac_tx(hw, skb);
+#endif
+
+	/* Re-arm the timer */
+	mod_timer(&i_sta->max_idle.timer, jiffies + i_sta->max_idle.idle_period);
+
+	return;
+ drop:
+	dev_kfree_skb_any(skb);
+}
+
+
+/**
+ * sta_h_bss_max_idle_period() - enable/disable BSS idle period
+ *
+ * @sta: the station of which activity to monitor
+ * @enable: true to start, false to stop.
+ *
+ */
+static int sta_h_bss_max_idle_period(struct ieee80211_hw *hw,
+				     struct ieee80211_vif *vif,
+				     struct ieee80211_sta *sta,
+				     enum ieee80211_sta_state old_state,
+				     enum ieee80211_sta_state new_state)
+{
+	struct nrc_vif *i_vif = NULL;
+	struct nrc_sta *i_sta = NULL;
+	u32 timeout_ms, max_idle_period = 0;
+	int idle_offset = 0;
+#if KERNEL_VERSION(4, 15, 0) > LINUX_VERSION_CODE
+	void (*bss_max_idle_period_expire)(unsigned long);
+#else
+	void (*bss_max_idle_period_expire)(struct timer_list *t);
+#endif
+
+	if (sta == NULL) {
+		nrc_mac_dbg("%s sta is NULL",__func__);
+		return 0;
+	} else {
+		i_sta = to_i_sta(sta);
+	}
+
+	if (vif == NULL) {
+		nrc_mac_dbg("%s vif is NULL",__func__);
+		return 0;
+	} else {
+		i_vif = to_i_vif(vif);
+	}
+
+	if (vif->type != NL80211_IFTYPE_AP &&
+		vif->type != NL80211_IFTYPE_STATION) {
+		nrc_mac_dbg("%s STA_TYPE(%d) is not neither AP or STA",__func__, vif->type);
+		return 0;
+    }
+
+#define state_changed(old, new)	\
+(old_state == IEEE80211_STA_##old && new_state == IEEE80211_STA_##new)
+
+	if (state_changed(AUTHORIZED, ASSOC)) {
+		if (i_sta->max_idle.idle_period > 0 &&
+			timer_pending(&i_sta->max_idle.timer)) {
+			nrc_mac_dbg("STA(%pM) deauth. Delete bss_max_idle timer(%u)",
+				sta->addr,i_sta->max_idle.idle_period);
+			del_timer_sync(&i_sta->max_idle.timer);
+			i_sta->max_idle.idle_period = 0;
+		}
+		return 0;
+	} else if (!state_changed(ASSOC, AUTHORIZED)) {
+		return 0;
+	}
+
+	/* old_state == ASSOC && new_state == ATHORIZED */
+
+	if (vif->type == NL80211_IFTYPE_STATION)
+		bss_max_idle_period_expire = sta_max_idle_period_expire;
+	else
+		bss_max_idle_period_expire = ap_max_idle_period_expire;
+#if KERNEL_VERSION(4, 15, 0) > LINUX_VERSION_CODE
+	setup_timer(&i_sta->max_idle.timer, bss_max_idle_period_expire,
+		    (unsigned long) i_sta);
+#else
+	timer_setup(&i_sta->max_idle.timer, bss_max_idle_period_expire,
+			0);
+#endif
+
+	if (vif->type == NL80211_IFTYPE_AP) {
+		max_idle_period = i_vif->max_idle_period;
+	} else {
+		max_idle_period = i_sta->max_idle.period;
+	}
+
+	if (max_idle_period == 0) {
+		nrc_mac_dbg("[%s] max_idle_period is 0",__func__);
+		return 0;
+	}
+
+	/* Extended BSS Max Idle Period */
+	if (nrc_mac_is_s1g(hw->priv)) {
+		u8 usf = (max_idle_period >> 14) & 0x3;
+		max_idle_period &= ~0xc000;
+		max_idle_period *= ieee80211_usf_to_sf(usf);
+		nrc_mac_dbg("%s: origin(16bit):0x%x [unscaled interval(14bit):%u, usf(2bit):%d] => total(%u x 1024 ms)",
+				__func__, i_sta->max_idle.period, (i_sta->max_idle.period & ~0xc000), usf, max_idle_period);
+	} else {
+		nrc_mac_dbg("%s: max_idle_period=%d ms", __func__,
+				max_idle_period * 1024);
+	}
+
+	if (bss_max_idle_offset < 0 &&
+		max_idle_period * 1024 <= (-1*bss_max_idle_offset)) {
+		nrc_mac_dbg("%s: invalid max_idle_period_offset(%d ms)",
+			__func__, bss_max_idle_offset);
+		bss_max_idle_offset = 0;
+	}
+  
+	/* Start STA inactivity monitoring */
+	if (vif->type == NL80211_IFTYPE_STATION) {
+		/* STA should send keep-alive frame before bss max idle timer on AP expires */
+		if (bss_max_idle_offset == 0) {
+		    if (max_idle_period > 2)
+			idle_offset = -768; //768ms
+		    else
+			idle_offset = -100; //100ms (if max idle period <= 2)
+		} else {
+			idle_offset = bss_max_idle_offset;
+		}
+	} else {
+		/* AP: offset is only used for add margin (only plus) */
+		if (bss_max_idle_offset > 0)
+			idle_offset = bss_max_idle_offset;
+	}
+
+	timeout_ms = max_idle_period * 1024 + idle_offset;
+	if (timeout_ms < 924) {
+		/* min = bss_max_idle - margin (100ms) = 924ms for safty
+		(BSS_MAX_IDLE MIN = 1 * 1000TU =1024ms) */
+		nrc_mac_dbg("bss max idle is set as min (924ms)");
+		timeout_ms = 924;
+	}
+
+	/* Save jiffies (msecs_to_jiffies(max_idle_period * 1024ms(1000TU) + idle_offset) */
+	i_sta->max_idle.idle_period = msecs_to_jiffies(timeout_ms);
+	nrc_mac_dbg("%s: associated[%pM] . Start bss_max_idle timer (%lu jiffies)",
+		__func__, sta->addr, i_sta->max_idle.idle_period);
+
+	mod_timer(&i_sta->max_idle.timer, jiffies + i_sta->max_idle.idle_period);
+
+	return 0;
+}
+STAH(sta_h_bss_max_idle_period);
+
+
+static int tx_h_bss_max_idle_period(struct nrc_trx_data *tx)
+{
+	struct nrc_vif *i_vif = NULL;
+	struct nrc_sta *i_sta = NULL;
+	struct bss_max_idle_period_ie *ie;
+	struct ieee80211_hdr *mh = (void *) tx->skb->data;
+	__le16 fc = mh->frame_control;
+
+	if (tx->vif == NULL) {
+		nrc_mac_dbg("%s tx->vif is NULL",__func__);
+		return 0;
+	} else {
+		i_vif = to_i_vif(tx->vif);
+	}
+
+	if (i_vif->max_idle_period == 0)
+		return 0;
+
+	if (tx->sta) {
+		i_sta = to_i_sta(tx->sta);
+		if (!i_sta) {
+			nrc_mac_dbg("%s i_sta is NULL",__func__);
+			return 0;
+		}
+	}
+
+#if 0 //Remove not-reached codes (tx->sta is NULL). TBD: need to move codes in right place
+	/* (STA) Update bss_max_idle timer whenever sending data frame */
+	if (tx->vif->type == NL80211_IFTYPE_STATION && i_sta->state == IEEE80211_STA_AUTHORIZED &&
+		i_sta->max_idle.period > 0 && ieee80211_is_data(fc)) {
+		unsigned long timeout;
+		if (ieee80211_is_qos_nullfunc(fc)) {
+			/* skip QoS Null data sending for keep alive */
+			return 0;
+		}
+		timeout = jiffies + i_sta->max_idle.idle_period;
+		nrc_mac_dbg("%s: (STA) TX Data. Update bss_max_idle timer (%lu)", __func__,
+			i_sta->max_idle.idle_period);
+		if (timer_pending(&i_sta->max_idle.timer) &&
+		    time_after(timeout, i_sta->max_idle.timer.expires)) {
+			mod_timer(&i_sta->max_idle.timer, timeout);
+		}
+		return 0;
+	}
+#endif
+
+	/* Handle TX (Re)Assoc REQ (STA) and TX (Re)Assoc RESP (AP) */
+	if (!ieee80211_is_assoc_resp(fc) && !ieee80211_is_reassoc_resp(fc) &&
+	    !ieee80211_is_assoc_req(fc) && !ieee80211_is_reassoc_req(fc))
+		return 0;
+
+	ie = (void *) find_bss_max_idle_ie(tx->skb);
+
+	if (ie) {
+		/*
+		 * The hostapd added EID_BSS_MAX_IDLE_PERIOD in (re)assoc resp.
+		 * Conditions are:
+		 * - hostapd is built with CONFIG_WNM
+		 * - hostapd.conf includes non-zero ap_max_inactivity setting
+		 * - hw->wiphy.feature & NL80211_FEATURE_INACTIVITY_TIMER  = 0
+		 *
+		 * In this case, we disable inactivity monitoring, and let the
+		 * hostapd take care of everything.
+		 */
+		nrc_mac_dbg("%s: BSS_MAX_IDLE_PERIOD IE exists but hostapd will handle the value",
+			    __func__);
+		i_vif->max_idle_period = 0;
+		if (i_sta) i_sta->max_idle.period = 0;
+
+		goto out;
+	}
+
+	/* Add Extended BSS Max Idle Period IE */
+	ie = (void *) ieee80211_append_ie(tx->skb,
+					  WLAN_EID_BSS_MAX_IDLE_PERIOD,
+					  3);
+	if (!ie) {
+		nrc_mac_dbg("%s: failed to add BSS_MAX_IDLE_PERIOD IE",
+			    __func__);
+		if (i_sta) i_sta->max_idle.period = 0;
+		i_vif->max_idle_period = 0;
+		goto out;
+	}
+
+	ie->max_idle_period = i_vif->max_idle_period;
+	ie->idle_option = 0;
+
+	if (tx->vif->type == NL80211_IFTYPE_AP) {
+		if (i_sta) {
+			if (i_sta->max_idle.period == 0 ||
+				i_sta->max_idle.period > i_vif->max_idle_period)
+				/* If STA asks for too long idle period, truncate it */
+				i_sta->max_idle.period = i_vif->max_idle_period;
+		}
+	}
+
+ out:
+	nrc_mac_dbg("%s: %s, max_idle_period(16bit)=0x%x", __func__,
+		    ieee80211_is_assoc_req(fc) ? "AssocReq" :
+		    ieee80211_is_reassoc_req(fc) ? "ReAssocReq" :
+		    ieee80211_is_assoc_resp(fc) ? "AssocResp" : "ReAssocResp",
+		    i_vif->max_idle_period);
+
+	return 0;
+}
+TXH(tx_h_bss_max_idle_period, NL80211_IFTYPE_ALL);
+
+/**
+ * rx_h_bss_max_idle_period() - bss max idle period rx handler
+ *
+ * This function handles (Re)Assoc. Req. and (Re)Assoc. Resp
+ * frames depending on vif type.
+ *
+ */
+static int rx_h_bss_max_idle_period(struct nrc_trx_data *rx)
+{
+	struct ieee80211_hdr *mh = (void *) rx->skb->data;
+	__le16 fc = mh->frame_control;
+	struct nrc_sta *i_sta = NULL;
+	struct nrc_vif *i_vif = NULL;
+	struct bss_max_idle_period_ie *ie;
+
+	if (rx->sta == NULL) {
+		nrc_mac_dbg("%s rx->sta is NULL",__func__);
+		return 0;
+	} else {
+		i_sta = to_i_sta(rx->sta);
+	}
+
+	if (rx->vif == NULL) {
+		nrc_mac_dbg("%s tx->vif is NULL",__func__);
+		return 0;
+	} else {
+		i_vif = to_i_vif(rx->vif);
+	}
+
+	/* AP updates bss_max_idle timer whenever receiving qos null data from STA
+		Note: Update only by qos null data ? is it safe ?*/
+	if (rx->vif->type == NL80211_IFTYPE_AP &&
+		i_sta->max_idle.period > 0 && ieee80211_is_qos_nullfunc(fc)) {
+		//i_sta->max_idle.period > 0 && (ieee80211_is_qos_nullfunc(fc)||ieee80211_is_data_qos(fc))){
+		unsigned long timeout;
+		timeout = jiffies + i_sta->max_idle.idle_period;
+		if (timer_pending(&i_sta->max_idle.timer) &&
+			time_after(timeout, i_sta->max_idle.timer.expires)) {
+			// nrc_mac_dbg("%s (AP) Update keep-alive timer for [%pM]",  __func__, rx->sta->addr);
+			/* reset timeout count */
+			i_sta->max_idle.timeout_cnt = 0;
+			mod_timer(&i_sta->max_idle.timer, timeout);
+		}
+		return 0;
+	}
+
+	/* Handle RX (Re)Assoc RESP (STA) and RX (Re)Assoc REQ (AP) */
+	if (!ieee80211_is_assoc_resp(fc) && !ieee80211_is_reassoc_resp(fc) &&
+	    !ieee80211_is_assoc_req(fc) && !ieee80211_is_reassoc_req(fc))
+		return 0;
+
+	if (WARN_ON(!ether_addr_equal(ieee80211_get_DA(mh), rx->vif->addr)))
+		return 0; /* @rx->skb not destined to @rx->vif */
+
+	/* Find BSS Max Idle Element and Save fields in i_sta->max_idle.period and options */
+	ie = (struct bss_max_idle_period_ie *) find_bss_max_idle_ie(rx->skb);
+	if (ie) {
+		/*
+		 * For a NL80211_IFTYPE_STATION vif, we are recording
+		 * 'agreed' BSS Max Idle Period, whereas NL80211_IFTYPE_AP vif,
+		 * we are recoding STA's 'preferred' value.
+		 */
+		i_sta->max_idle.period = ie->max_idle_period;
+		i_sta->max_idle.options = ie->idle_option;
+
+	} else {
+		i_sta->max_idle.options = 0;
+		if (rx->vif->type == NL80211_IFTYPE_AP) {
+			i_sta->max_idle.period = i_vif->max_idle_period;
+		} else {
+			i_sta->max_idle.period = 0;
+		}
+	}
+
+	nrc_mac_dbg("%s: %s, bss_max_idle_period(16bit)=0x%x", __func__,
+		    ieee80211_is_assoc_req(fc) ? "AssocReq" :
+		    ieee80211_is_reassoc_req(fc) ? "ReAssocReq" :
+		    ieee80211_is_assoc_resp(fc) ? "AssocResp" : "ReAssocResp",
+		    i_sta->max_idle.period);
+
+	return 0;
+}
+RXH(rx_h_bss_max_idle_period, NL80211_IFTYPE_ALL);
diff --git a/drivers/staging/nrc/nrc-recovery.c b/drivers/staging/nrc/nrc-recovery.c
new file mode 100644
index 000000000000..95dee404bef7
--- /dev/null
+++ b/drivers/staging/nrc/nrc-recovery.c
@@ -0,0 +1,112 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include "nrc.h"
+#include "wim.h"
+#include "nrc-debug.h"
+#include "nrc-netlink.h"
+#include "nrc-recovery.h"
+
+
+static void trigger(struct work_struct *work)
+{
+	struct nrc_recovery_wdt *wdt;
+
+	wdt = container_of(work, struct nrc_recovery_wdt, work);
+	nrc_netlink_trigger_recovery(wdt->nw);
+}
+
+#if KERNEL_VERSION(4, 15, 0) > LINUX_VERSION_CODE
+static void bark(unsigned long data)
+{
+	struct nrc *nw = (struct nrc *) data;
+#else
+static void bark(struct timer_list *t)
+{
+	struct nrc_recovery_wdt *wdt = from_timer(wdt, t, wdt);
+	struct nrc *nw = wdt->nw;
+#endif
+	nrc_mac_dbg("%s\n", __func__);
+	queue_work(nw->workqueue, &nw->recovery_wdt->work);
+}
+
+#if KERNEL_VERSION(4, 15, 0) > LINUX_VERSION_CODE
+static void poll(unsigned long data)
+{
+	struct nrc *nw = (struct nrc *) data;
+#else
+static void poll(struct timer_list *t)
+{
+	struct nrc_recovery_wdt *wdt = from_timer(wdt, t, timer);
+	struct nrc *nw = wdt->nw;
+#endif
+	if (!nrc_wim_request_keep_alive(nw))
+		nrc_mac_dbg("failed to request keep-alive\n");
+}
+
+void nrc_recovery_wdt_init(struct nrc *nw, int period)
+{
+	if (nw->recovery_wdt)
+		return;
+
+	nw->recovery_wdt = kzalloc(sizeof(struct nrc_recovery_wdt), GFP_KERNEL);
+
+	if (!nw->recovery_wdt)
+		return;
+
+	nw->recovery_wdt->period = period;
+	nw->recovery_wdt->nw = nw;
+
+#if KERNEL_VERSION(4, 15, 0) > LINUX_VERSION_CODE
+	setup_timer(&nw->recovery_wdt->wdt, bark, (unsigned long) nw);
+	setup_timer(&nw->recovery_wdt->timer, poll, (unsigned long) nw);
+#else
+	timer_setup(&nw->recovery_wdt->wdt, bark, 0);
+	timer_setup(&nw->recovery_wdt->timer, poll, 0);
+#endif
+	INIT_WORK(&nw->recovery_wdt->work, trigger);
+}
+
+void nrc_recovery_wdt_kick(struct nrc *nw)
+{
+	int p;
+
+	if (!nw->recovery_wdt)
+		return;
+
+	p = nw->recovery_wdt->period;
+	mod_timer(&nw->recovery_wdt->wdt, jiffies + msecs_to_jiffies(p));
+	mod_timer(&nw->recovery_wdt->timer, jiffies + msecs_to_jiffies(p / 2));
+}
+
+void nrc_recovery_wdt_stop(struct nrc *nw)
+{
+	if (nw->recovery_wdt) {
+		del_timer_sync(&nw->recovery_wdt->wdt);
+		del_timer_sync(&nw->recovery_wdt->timer);
+	}
+}
+
+void nrc_recovery_wdt_clear(struct nrc *nw)
+{
+	if (!nw->recovery_wdt)
+		return;
+
+	del_timer_sync(&nw->recovery_wdt->wdt);
+	del_timer_sync(&nw->recovery_wdt->timer);
+	kfree(nw->recovery_wdt);
+	nw->recovery_wdt = NULL;
+}
diff --git a/drivers/staging/nrc/nrc-recovery.h b/drivers/staging/nrc/nrc-recovery.h
new file mode 100644
index 000000000000..fb53d4f9f7a9
--- /dev/null
+++ b/drivers/staging/nrc/nrc-recovery.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _NRC_RECOVERY_H_
+#define _NRC_RECOVERY_H_
+
+struct nrc_recovery_wdt {
+	int period;
+	struct nrc *nw;
+	struct timer_list wdt;
+	struct timer_list timer;
+	struct work_struct work;
+};
+
+void nrc_recovery_wdt_init(struct nrc *nw, int period);
+void nrc_recovery_wdt_kick(struct nrc *nw);
+void nrc_recovery_wdt_stop(struct nrc *nw);
+void nrc_recovery_wdt_clear(struct nrc *nw);
+
+#endif
diff --git a/drivers/staging/nrc/nrc-ssp-dev.h b/drivers/staging/nrc/nrc-ssp-dev.h
new file mode 100644
index 000000000000..a4acd4aabce7
--- /dev/null
+++ b/drivers/staging/nrc/nrc-ssp-dev.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _NRC_SSP_DEV_H_
+#define _NRC_SSP_DEV_H_
+
+#include <linux/debugfs.h>
+#include <linux/mutex.h>
+#include <linux/kthread.h>
+#include "nrc-hif.h"
+
+struct nrc_ssp;
+
+struct nrc_ssp_priv {
+	struct nrc_ssp *ssp;
+
+	struct workqueue_struct *rx_wq;
+	struct workqueue_struct *tx_wq;
+	struct work_struct rx_work;
+	struct work_struct tx_work;
+	struct mutex bus_lock_mutex;
+
+	struct sk_buff_head skb_head;
+	atomic_t hif_req;
+	int hif_isr_count;
+	bool loopback;
+	bool fw_ready;
+	bool gdma_ready;
+};
+
+struct nrc_ssp {
+	struct spi_device *spi;
+	struct nrc_hif_ssp *hif;
+	struct nrc_ssp_priv *priv;
+	unsigned long prev_xfer_time;
+};
+
+#endif
diff --git a/drivers/staging/nrc/nrc-ssp.c b/drivers/staging/nrc/nrc-ssp.c
new file mode 100644
index 000000000000..026198f0a021
--- /dev/null
+++ b/drivers/staging/nrc/nrc-ssp.c
@@ -0,0 +1,631 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/hardirq.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/firmware.h>
+#include <linux/jiffies.h>
+#include <linux/list.h>
+#include <linux/netdevice.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/gpio.h>
+#include <linux/errno.h>
+
+#include "nrc-hif-ssp.h"
+#include "nrc-ssp-dev.h"
+#include "nrc-ssp.h"
+#include "nrc-fw.h"
+#include "nrc-wim-types.h"
+
+static struct nrc_ssp g_ssp = {0,};
+
+static uint8_t cal_csum(struct ssp_header_t *header)
+{
+	uint8_t csum = 0;
+	uint8_t *buf = (uint8_t *)header;
+	uint8_t byte_len = sizeof(struct ssp_header_t) - sizeof(header->m_csum);
+	uint32_t i;
+
+	for (i = 0; i < byte_len; i++)
+		csum ^= buf[i];
+	return csum;
+}
+
+static void spu_transaction_init(struct nrc_ssp *ssp)
+{
+	if (!time_after(jiffies, ssp->prev_xfer_time + 1))
+		ndelay(40);
+}
+
+static void spu_transaction_finish(struct nrc_ssp *ssp)
+{
+	ssp->prev_xfer_time = jiffies;
+}
+
+static bool ssp_xfer(struct nrc_ssp *ssp, uint8_t *tx, uint8_t *rx, int count)
+{
+	int err = 0;
+	struct spi_message m;
+	struct spi_transfer data_trans;
+
+	spi_message_init(&m);
+	memset(&data_trans, 0, sizeof(data_trans));
+
+	spu_transaction_init(ssp);
+
+	if (tx)
+		data_trans.tx_buf = tx;
+	if (rx)
+		data_trans.rx_buf = rx;
+	data_trans.len = count;
+
+	spi_message_add_tail(&data_trans, &m);
+
+	err = spi_sync(ssp->spi, &m);
+	spu_transaction_finish(ssp);
+
+	return !!(err == 0);
+}
+
+void ssp_make_header(uint8_t *buffer, uint8_t type, uint8_t sub_type,
+		uint16_t length, uint8_t padding)
+{
+	struct ssp_header_t *header = (struct ssp_header_t *) buffer;
+
+	memset(buffer, 0, 8);
+
+	header->m_soh = NR_HOST_IF_HEADER_SOH;
+	header->m_ver = NR_HOST_IF_HEADER_VER;
+	header->m_type  = type;
+	header->m_sub_type = sub_type;
+	header->m_length = length;
+	header->m_padding = padding;
+	header->m_csum = cal_csum(header);
+}
+
+static uint8_t recover_buf[6*1024];
+
+static bool ssp_ping_pong(struct nrc_ssp *ssp)
+{
+	struct ssp_header_t header;
+
+	ssp_make_header((uint8_t *)&header, HIF_TYPE_SSP_PING, 0, 0, 0);
+
+	ssp_xfer(ssp, (uint8_t *)&header, NULL, sizeof(struct ssp_header_t));
+	mdelay(1);
+
+	memset((uint8_t *)&header, 0xFF, sizeof(struct ssp_header_t));
+
+	ssp_xfer(ssp, NULL, (uint8_t *)&header, sizeof(struct ssp_header_t));
+	mdelay(1);
+
+	if ((header.m_csum == cal_csum(&header)) &&
+		(header.m_type == HIF_TYPE_SSP_PONG)) {
+		return true;
+	} else {
+		return false;
+	}
+}
+
+static void ssp_recovery(struct nrc_ssp *ssp)
+{
+	int err = 0;
+	int max_count = 100;
+
+	nrc_dbg(NRC_DBG_HIF, "----------[%s]--------\n", __func__);
+
+	memset(recover_buf, 0xff, sizeof(recover_buf));
+
+	while (max_count--) {
+		if (ssp_ping_pong(ssp)) {
+			nrc_dbg(NRC_DBG_HIF, "<<< Pong\n");
+			break;
+		}
+		err = ssp_xfer(ssp, recover_buf, NULL, 1);
+		mdelay(10);
+	}
+}
+
+int ssp_vaild_check(struct nrc_ssp_priv *priv, struct ssp_header_t *header)
+{
+	if (header->m_csum != cal_csum(header)) {
+		nrc_dbg(NRC_DBG_HIF, "csum error\n");
+		return SSP_V_ERROR;
+	}
+
+	if (header->m_soh != 0x4e) {
+		nrc_dbg(NRC_DBG_HIF, "soh error(0x%02X)\n", header->m_soh);
+		return SSP_V_ERROR;
+	}
+
+	if (header->m_ver != 0) {
+		nrc_dbg(NRC_DBG_HIF, "version error(0x%02X)\n", header->m_ver);
+		return SSP_V_ERROR;
+	}
+
+	if (header->m_type == HIF_TYPE_SSP_SKIP) {
+		nrc_dbg(NRC_DBG_HIF, "Skip state report (received:%d, current:%d)\n",
+				header->m_length, priv->hif_isr_count);
+		priv->hif_isr_count = header->m_length;
+		return SSP_V_SKIP;
+	}
+
+	if (header->m_length == 0) {
+		nrc_dbg(NRC_DBG_HIF, "length is 0\n");
+		return SSP_V_ERROR;
+	}
+
+	return SSP_V_GOOD;
+}
+
+static bool ssp_wait_gdma_ready(void)
+{
+	uint32_t timeout = 0;
+	int val = 0;
+
+	udelay(50);
+
+	while (timeout < 100) {
+		val = gpio_get_value(spi_gdma_irq);
+		if (val)
+			break;
+
+		udelay(10);
+		timeout++;
+	}
+
+	return !!(val);
+}
+
+int ssp_read_buffer(struct nrc_ssp *ssp)
+{
+	bool ret;
+	int ssp_validity;
+	struct ssp_header_t header;
+	struct nrc_ssp_priv *priv;
+	struct nrc_hif_device *dev;
+	struct sk_buff *skb;
+
+	priv = ssp->priv;
+
+	ssp_make_header((uint8_t *)&header, HIF_TYPE_SSP_READYRX, 0, 0, 0);
+	ret = ssp_xfer(ssp, (uint8_t *)&header, NULL,
+			sizeof(struct ssp_header_t));
+
+	if (!ssp_wait_gdma_ready()) {
+		nrc_dbg(NRC_DBG_HIF, "fail to get gdma ready(Read)\n");
+		return -1;
+	}
+
+	if (!ret) {
+		nrc_dbg(NRC_DBG_HIF, "fail to send RxReady\n");
+		return -2;
+	}
+
+	memset((uint8_t *)&header, 0, sizeof(struct ssp_header_t));
+	ret = ssp_xfer(ssp, NULL, (uint8_t *)&header,
+			sizeof(struct ssp_header_t));
+	if (!ret) {
+		nrc_dbg(NRC_DBG_HIF, "fail to read header\n");
+		return -3;
+	}
+
+	ssp_validity = ssp_vaild_check(priv, &header);
+	if (ssp_validity != SSP_V_GOOD) {
+		if (ssp_validity == SSP_V_SKIP)
+			return -4;
+		nrc_dbg(NRC_DBG_HIF,
+		"soh:%02X, ver:%02X, type:%02X subtype:%02X, len:%d, pad:%02X, cs:%02X\n",
+				header.m_soh, header.m_ver, header.m_type,
+				header.m_sub_type, header.m_length,
+				header.m_padding, header.m_csum);
+
+		ssp_recovery(ssp);
+		return -5;
+	}
+
+	if (header.m_padding) {
+		skb = dev_alloc_skb(header.m_length);
+		ret = ssp_xfer(ssp, NULL, skb_put(skb, header.m_length),
+				header.m_length);
+
+		if (!ret) {
+			nrc_dbg(NRC_DBG_HIF, "fail to read payload\n");
+			dev_kfree_skb_any(skb);
+			return -6;
+		}
+
+		dev = ssp->hif->dev;
+		dev->hif_ops->receive(dev, skb);
+
+		if (!ssp_wait_gdma_ready()) {
+			nrc_dbg(NRC_DBG_HIF, "fail to get gdma ready(Read done)\n");
+			dev_kfree_skb_any(skb);
+			return -7;
+		}
+	}
+
+	return header.m_padding;
+}
+
+bool ssp_enqueue_buffer(struct nrc_ssp *ssp, struct sk_buff *skb)
+{
+	struct nrc_ssp_priv *priv = ssp->priv;
+
+	skb_queue_tail(&priv->skb_head, skb);
+	queue_work(priv->tx_wq, &priv->tx_work);
+
+	return true;
+}
+
+bool ssp_write_buffer(struct nrc_ssp *ssp, uint8_t *buffer,
+		int length, uint8_t type)
+{
+	bool ret;
+	struct ssp_header_t header;
+
+	ssp_make_header((uint8_t *)&header, type, 0, length, 0);
+	ret = ssp_xfer(ssp, (uint8_t *)&header, NULL,
+			sizeof(struct ssp_header_t));
+
+	if (!ssp_wait_gdma_ready()) {
+		nrc_dbg(NRC_DBG_HIF, "fail to get gdma ready(Write)\n");
+		return false;
+	}
+
+	if (!ret) {
+		nrc_dbg(NRC_DBG_HIF, "fail to send Tx Header\n");
+		return false;
+	}
+
+	ret = ssp_xfer(ssp, buffer, NULL, length);
+
+	if (!ret) {
+		nrc_dbg(NRC_DBG_HIF, "fail to send Tx payload\n");
+		return false;
+	}
+
+	if (!ssp_wait_gdma_ready()) {
+		nrc_dbg(NRC_DBG_HIF, "fail to get gdma ready(Write done)\n");
+		return false;
+	}
+
+	return true;
+}
+
+
+void ssp_show_header(struct ssp_header_t *header)
+{
+	nrc_dbg(NRC_DBG_HIF, "version: 0x%02X\n",
+			header->m_ver);
+	nrc_dbg(NRC_DBG_HIF, "type: 0x%02X\n",
+			header->m_type);
+	nrc_dbg(NRC_DBG_HIF, "sub_type: 0x%02X\n",
+			header->m_sub_type);
+	nrc_dbg(NRC_DBG_HIF, "length: 0x%04X(%d)\n",
+			header->m_length, header->m_length);
+	nrc_dbg(NRC_DBG_HIF, "padding: 0x%02X\n",
+			header->m_padding);
+	nrc_dbg(NRC_DBG_HIF, "csum: 0x%02X\n",
+			header->m_csum);
+}
+
+void ssp_show_hex(uint8_t *buf, int len)
+{
+	int i = 0;
+
+	for (i = 1; i <= len; i++) {
+		if ((i & 0xf) == 1) {
+			if (i != 1)
+				nrc_dbg(NRC_DBG_HIF, "\n");
+		}
+		nrc_dbg(NRC_DBG_HIF, "%02x ", (uint8_t) *buf);
+		buf++;
+	}
+	nrc_dbg(NRC_DBG_HIF, "\n");
+}
+
+static irqreturn_t ssp_hif_isr(int irq, void *dev)
+{
+	struct nrc_ssp *ssp = (struct nrc_ssp *) dev;
+	struct nrc_ssp_priv *priv = ssp->priv;
+
+	atomic_inc(&priv->hif_req);
+	priv->hif_isr_count++;
+
+	queue_work(priv->rx_wq, &priv->rx_work);
+
+	return IRQ_HANDLED;
+}
+
+#if KERNEL_VERSION(4, 15, 0) > LINUX_VERSION_CODE
+static void priodic_call(unsigned long data)
+{
+	struct nrc_ssp_priv *priv = (struct nrc_ssp_priv *)data;
+
+	queue_work(priv->tx_wq, &priv->tx_work);
+
+	set_timer(priv);
+}
+
+void set_timer(struct nrc_ssp_priv *priv)
+{
+	int delay = 1;
+	struct nrc_hif_ssp *hif = priv->ssp->hif;
+
+	init_timer_on_stack(&hif->exp_timer);
+	hif->exp_timer.expires = jiffies + delay * HZ / 100;
+	hif->exp_timer.data = (unsigned long) priv;
+	hif->exp_timer.function = priodic_call;
+	add_timer(&hif->exp_timer);
+}
+#else
+static void priodic_call(struct timer_list *t)
+{
+	struct nrc_hif_ssp *hif = from_timer(hif, t,
+			exp_timer);
+	struct nrc_ssp_priv *priv = hif->ssp->priv;
+
+	queue_work(priv->tx_wq, &priv->tx_work);
+	set_timer(priv);
+}
+
+void set_timer(struct nrc_ssp_priv *priv)
+{
+	struct nrc_hif_ssp *hif = priv->ssp->hif;
+	int delay = 1;
+
+	hif->exp_timer.expires = jiffies + delay * HZ / 100;
+	timer_setup(&hif->exp_timer, priodic_call, 0);
+}
+#endif
+
+static void rx_worker(struct work_struct *work)
+{
+	struct nrc_ssp *ssp;
+	struct nrc_ssp_priv *priv;
+	int q_cnt;
+
+	priv = container_of(work, struct nrc_ssp_priv, rx_work);
+	if (atomic_read(&priv->hif_req) == 0)
+		return;
+	ssp = priv->ssp;
+	do {
+		mutex_lock(&priv->bus_lock_mutex);
+		q_cnt = ssp_read_buffer(ssp);
+		mutex_unlock(&priv->bus_lock_mutex);
+		if (q_cnt <= 0) {
+			nrc_dbg(NRC_DBG_HIF, "[%s] read error %d req=%d\n",
+					__func__, q_cnt,
+					atomic_read(&priv->hif_req));
+		} else if (atomic_read(&priv->hif_req) > 0)
+			atomic_dec(&priv->hif_req);
+	} while (q_cnt > 1);
+}
+
+static void tx_worker(struct work_struct *work)
+{
+	struct nrc_ssp *ssp;
+	struct nrc_ssp_priv *priv;
+	int count;
+	struct nrc_hif_ssp *hif_ssp;
+	struct nrc *nw;
+
+	priv = container_of(work, struct nrc_ssp_priv, tx_work);
+	hif_ssp = priv->ssp->hif;
+	nw = hif_ssp->dev->nw;
+	ssp = priv->ssp;
+
+	count = skb_queue_len(&priv->skb_head);
+	if (count) {
+		struct sk_buff *skb;
+		struct hif *hif_hdr;
+
+		skb = skb_dequeue(&priv->skb_head);
+		hif_hdr = (struct hif *)skb->data;
+
+		mutex_lock(&priv->bus_lock_mutex);
+		ssp_write_buffer(ssp, skb->data, skb->len, hif_hdr->type);
+		mutex_unlock(&priv->bus_lock_mutex);
+		nrc_hif_free_skb(nw, skb);
+	}
+}
+
+static int ssp_probe(struct spi_device *spi)
+{
+	int ret = 0;
+	struct nrc *nw;
+	struct nrc_ssp *ssp;
+	struct nrc_hif_ssp *hif;
+	int err;
+	struct nrc_ssp_priv *priv;
+
+	nrc_dbg(NRC_DBG_HIF, "+%s", __func__);
+
+	ssp = &g_ssp;
+
+	priv = kzalloc(sizeof(struct nrc_ssp_priv), GFP_KERNEL);
+	if (!priv) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	spi_set_drvdata(spi, ssp);
+	ssp->spi = spi;
+	ssp->prev_xfer_time = jiffies;
+	hif = ssp->hif;
+	nw = hif->dev->nw;
+
+	skb_queue_head_init(&priv->skb_head);
+
+	priv->rx_wq = create_singlethread_workqueue("nrc72xx_hif_rx");
+	INIT_WORK(&priv->rx_work, rx_worker);
+
+	priv->tx_wq = create_singlethread_workqueue("nrc72xx_hif_tx");
+	INIT_WORK(&priv->tx_work, tx_worker);
+
+	mutex_init(&priv->bus_lock_mutex);
+
+	priv->hif_isr_count = 0;
+
+	/* TODO: check FW(target) ready to work */
+	priv->fw_ready = true;
+
+	priv->ssp = ssp;
+	ssp->priv = priv;
+
+	ret = gpio_request(spi->irq, "ssp_int");
+	if (ret < 0)
+		goto out;
+	gpio_direction_input(spi->irq);
+
+	err = request_irq(gpio_to_irq(spi->irq), ssp_hif_isr,
+			IRQF_TRIGGER_RISING | IRQF_ONESHOT, "ssp_hif", ssp);
+
+	nrc_dbg(NRC_DBG_HIF, "--spi_gpio_irq Set Done\n");
+	if (err) {
+		pr_err("can't get hif IRQ\n");
+		goto ssp_free;
+	}
+
+	/* Prepare GDMA_READY pin */
+	ret = gpio_request(spi_gdma_irq, "sysfs");
+	gpio_direction_input(spi_gdma_irq);
+	if (ret < 0) {
+		nrc_dbg(NRC_DBG_HIF,
+			"could not request ssp_gdma_ready gpio(%d)\n", ret);
+		goto ssp_free;
+	}
+
+	set_timer(ssp->priv);
+
+	goto out;
+
+
+ssp_free:
+	kfree(priv);
+out:
+
+	nrc_dbg(NRC_DBG_HIF, "-%s", __func__);
+	return ret;
+}
+
+static int ssp_remove(struct spi_device *spi)
+{
+	struct nrc_ssp *ssp = spi_get_drvdata(spi);
+	struct nrc_ssp_priv *priv;
+	struct nrc_hif_ssp *hif = ssp->hif;
+
+	priv = ssp->priv;
+
+	nrc_dbg(NRC_DBG_HIF, "+%s", __func__);
+
+	free_irq(gpio_to_irq(spi_gpio_irq), ssp);
+	gpio_free(spi_gpio_irq);
+	gpio_free(spi_gdma_irq);
+	flush_workqueue(priv->rx_wq);
+	flush_workqueue(priv->tx_wq);
+	destroy_workqueue(priv->rx_wq);
+	destroy_workqueue(priv->tx_wq);
+	spi_set_drvdata(spi, NULL);
+
+	del_timer(&hif->exp_timer);
+
+	kfree(priv);
+	nrc_dbg(NRC_DBG_HIF, "-%s", __func__);
+	return 0;
+
+}
+
+static struct spi_driver ssp_driver = {
+	.probe	= ssp_probe,
+	.remove = ssp_remove,
+	.driver = {
+		.name = "nrc-nspi",
+	},
+};
+
+static struct spi_board_info bi = {
+	.modalias = "nrc-nspi",
+	.chip_select = 0,
+	.mode = SPI_MODE_1,
+};
+
+int nrc_ssp_register(struct nrc_hif_ssp *hif)
+{
+	int ret = 0;
+	struct spi_device *spi;
+	struct spi_master *master;
+
+	nrc_dbg(NRC_DBG_HIF, "%s()", __func__);
+
+	g_ssp.hif = hif;
+	hif->ssp = &g_ssp;
+
+	/* Apply module parameters */
+	bi.bus_num = spi_bus_num;
+	bi.irq = spi_gpio_irq;
+	bi.platform_data = hif->dev;
+	bi.max_speed_hz = hifspeed;
+
+	/* Find the spi master that our device is attached to */
+	master = spi_busnum_to_master(spi_bus_num);
+	if (!master) {
+		nrc_dbg(NRC_DBG_HIF,
+			"could not find spi master with busnum=%d\n",
+			spi_bus_num);
+		goto fail;
+	}
+
+	/* Instantiate and add a spi device */
+	spi = spi_new_device(master, &bi);
+	if (!spi) {
+		nrc_dbg(NRC_DBG_HIF, "failed to add spi device\n");
+		goto fail;
+	}
+
+	hif->ssp->spi = spi;
+
+	/* Register spi driver */
+	ret = spi_register_driver(&ssp_driver);
+	if (ret < 0) {
+		nrc_dbg(NRC_DBG_HIF, "failed to register driver %s\n",
+			ssp_driver.driver.name);
+		goto unregister_device;
+	}
+
+	return ret;
+
+unregister_device:
+	spi_unregister_device(spi);
+fail:
+
+	return -1;
+}
+
+void nrc_ssp_unregister(struct nrc_hif_ssp *hif)
+{
+	nrc_dbg(NRC_DBG_HIF, "%s()", __func__);
+	spi_unregister_device(hif->ssp->spi);
+	spi_unregister_driver(&ssp_driver);
+}
diff --git a/drivers/staging/nrc/nrc-ssp.h b/drivers/staging/nrc/nrc-ssp.h
new file mode 100644
index 000000000000..b78508284f7a
--- /dev/null
+++ b/drivers/staging/nrc/nrc-ssp.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _NRC_SSP_H_
+#define _NRC_SSP_H_
+
+#include "nrc-ssp-dev.h"
+
+#define NR_HOST_IF_HEADER_SOH  0x4E
+#define NR_HOST_IF_HEADER_VER  0x00
+
+enum {
+	SSP_V_SKIP  = -1,
+	SSP_V_ERROR =  0,
+	SSP_V_GOOD  =  1,
+};
+
+struct ssp_header_t {
+	uint8_t m_soh;
+	uint8_t m_ver;
+	uint8_t m_type;
+	uint8_t m_sub_type;
+	uint16_t m_length;
+	uint8_t m_padding;
+	uint8_t m_csum;
+};
+
+int ssp_read_buffer(struct nrc_ssp *ssp);
+bool ssp_write_buffer(struct nrc_ssp *ssp, uint8_t *buffer, int length,
+		uint8_t type);
+void ssp_make_header(uint8_t *buffer, uint8_t type, uint8_t sub_type,
+		uint16_t length, uint8_t padding);
+int nrc_ssp_register(struct nrc_hif_ssp *hif);
+void nrc_ssp_unregister(struct nrc_hif_ssp *hif);
+void ssp_show_header(struct ssp_header_t *header);
+void ssp_show_hex(uint8_t *buf, int len);
+bool ssp_enqueue_buffer(struct nrc_ssp *ssp, struct sk_buff *skb);
+void set_timer(struct nrc_ssp_priv *priv);
+
+#endif
diff --git a/drivers/staging/nrc/nrc-stats.c b/drivers/staging/nrc/nrc-stats.c
new file mode 100644
index 000000000000..824e93174ce8
--- /dev/null
+++ b/drivers/staging/nrc/nrc-stats.c
@@ -0,0 +1,479 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include "nrc.h"
+#include "nrc-hif.h"
+#include "nrc-debug.h"
+#include "nrc-stats.h"
+
+//#define TRACE printk("%s %d\n", __func__, __LINE__)
+
+struct moving_average {
+	int size;
+	int count;
+	int min;
+	int max;
+	int index;
+	int (*compute)(void *arr_t, int index, int count);
+	uint8_t arr[];
+};
+
+static spinlock_t state_lock;
+static struct list_head state_head;
+
+static struct moving_average *
+moving_average_init(int size, int count,
+			   int (*compute)(void *arr, int index, int count))
+{
+	struct moving_average *ma;
+
+	ma = kmalloc(sizeof(*ma) + size*count, GFP_KERNEL);
+	if (!ma)
+		return NULL;
+
+	memset(ma, 0, sizeof(*ma) + size*count);
+
+	ma->size = size;
+	ma->count = count;
+	ma->compute = compute;
+
+	return ma;
+}
+
+static void moving_average_deinit(struct moving_average *handle)
+{
+	BUG_ON(!handle);
+	kfree(handle);
+}
+
+static void moving_average_update(struct moving_average *ma, void *arg)
+{
+	int index, size;
+	uint8_t *p;
+
+	BUG_ON(!ma);
+
+	index = ma->index;
+	size = ma->size;
+	p = ma->arr;
+
+	BUG_ON(!p);
+
+	p += index*size;
+	memcpy(p, arg, size);
+
+	index++;
+	ma->index = index % ma->count;
+}
+
+static int moving_average_compute(struct moving_average *ma)
+{
+	BUG_ON(!ma);
+	BUG_ON(!ma->compute);
+	return ma->compute(ma->arr, ma->index, ma->count);
+}
+
+static struct moving_average *snr_h;
+static struct moving_average *nrc_stats_snr_get(void)
+{
+	return snr_h;
+}
+
+static int snr_compute(void *arr_t, int index, int count)
+{
+	int i;
+	uint8_t min = U8_MAX;
+	uint8_t max = 0;
+	int sum = 0;
+	uint8_t *arr = arr_t;
+
+	BUG_ON(!arr);
+
+	for (i = 0; i < count; i++) {
+		uint8_t snr = arr[i];
+
+		min = min(snr, min);
+		max = max(snr, max);
+		sum += snr;
+	}
+
+	sum -= min;
+	sum -= max;
+
+	BUG_ON(count == 2);
+	return sum/(count-2);
+}
+
+int nrc_stats_snr_init(int count)
+{
+	struct moving_average *h;
+
+	h = moving_average_init(sizeof(uint8_t),
+			count, snr_compute);
+	if (!h)
+		return -1;
+	snr_h = h;
+
+	return 0;
+}
+
+void nrc_stats_snr_deinit(void)
+{
+	struct moving_average *h = nrc_stats_snr_get();
+
+	moving_average_deinit(h);
+}
+
+void nrc_stats_snr_update(uint8_t snr)
+{
+	struct moving_average *h = nrc_stats_snr_get();
+
+	moving_average_update(h, &snr);
+}
+
+int nrc_stats_snr(void)
+{
+	struct moving_average *h = nrc_stats_snr_get();
+	int snr = 1234567890;
+
+	if (h)
+		snr = moving_average_compute(h);
+
+	return snr;
+}
+
+static struct moving_average *rssi_h;
+static struct moving_average *nrc_stats_rssi_get(void)
+{
+	return rssi_h;
+}
+
+static int rssi_compute(void *arr_t, int index, int count)
+{
+	int i;
+	int8_t min = S8_MAX;
+	int8_t max = S8_MIN;
+	int sum = 0;
+	int8_t *arr = arr_t;
+
+	BUG_ON(!arr);
+
+	for (i = 0; i < count; i++) {
+		int8_t rssi = (int8_t) arr[i];
+
+		min = min(rssi, min);
+		max = max(rssi, max);
+		sum += rssi;
+	}
+
+	sum -= min;
+	sum -= max;
+
+	BUG_ON(count == 2);
+	return sum/(count-2);
+}
+
+int nrc_stats_rssi_init(int count)
+{
+	struct moving_average *h;
+
+	h = moving_average_init(sizeof(int8_t), count, rssi_compute);
+	if (!h)
+		return -1;
+	rssi_h = h;
+
+	return 0;
+}
+
+void nrc_stats_rssi_deinit(void)
+{
+	struct moving_average *h = nrc_stats_rssi_get();
+
+	moving_average_deinit(h);
+}
+
+void nrc_stats_rssi_update(int8_t rssi)
+{
+	struct moving_average *h = nrc_stats_rssi_get();
+
+	moving_average_update(h, &rssi);
+}
+
+int nrc_stats_rssi(void)
+{
+	struct moving_average *h = nrc_stats_rssi_get();
+	int rssi = 1234567890;
+
+	if (h)
+		rssi = moving_average_compute(h);
+
+	return rssi;
+}
+
+static int metric_compute(void *arr_t, int index, int count)
+{
+	int i;
+	uint16_t min = U16_MAX;
+	uint16_t max = 0;
+	int sum = 0;
+	uint16_t *arr = arr_t;
+
+	BUG_ON(!arr);
+
+	for (i = 0; i < count; i++) {
+		uint16_t metric = arr[i];
+
+		min = min(metric, min);
+		max = max(metric, max);
+		sum += metric;
+	}
+
+	sum -= min;
+	sum -= max;
+
+	BUG_ON(count == 2);
+	return sum/(count-2);
+}
+
+int nrc_stats_metric(uint8_t *macaddr)
+{
+	struct stats_sta *cur, *next;
+	uint16_t metric = 0;
+
+	spin_lock(&state_lock);
+	list_for_each_entry_safe(cur, next, &state_head, list) {
+		if (memcmp(cur->macaddr, macaddr, 6) == 0) {
+			metric = moving_average_compute(cur->metric);
+			break;
+		}
+	}
+	spin_unlock(&state_lock);
+
+	return metric;
+}
+
+static struct moving_average *nrc_stats_rssi_init2(void)
+{
+	const int count = 16;
+
+	return moving_average_init(sizeof(int8_t), count, rssi_compute);
+}
+
+static struct moving_average *nrc_stats_snr_init2(void)
+{
+	const int count = 16;
+
+	return moving_average_init(sizeof(uint8_t), count, snr_compute);
+}
+
+static struct moving_average *nrc_stats_metric_init(void)
+{
+	const int count = 4;
+
+	return moving_average_init(sizeof(uint16_t), count, metric_compute);
+}
+
+static void nrc_stats_rssi_update2(struct moving_average *h, int8_t rssi)
+{
+	moving_average_update(h, &rssi);
+}
+
+static void nrc_stats_snr_update2(struct moving_average *h, uint8_t snr)
+{
+	moving_average_update(h, &snr);
+}
+
+#define TX_OFFSET (100)
+#define PATH_LOSS_CONSTANT (1)
+static void nrc_stats_metric_update(struct moving_average *h, int8_t rssi)
+{
+	uint16_t metric;
+
+	/* simplified rssi conversion formula */
+	metric = (TX_OFFSET + rssi) * 100 / PATH_LOSS_CONSTANT;
+	moving_average_update(h, &metric);
+}
+
+int nrc_stats_init(void)
+{
+	spin_lock_init(&state_lock);
+	INIT_LIST_HEAD(&state_head);
+
+	return 0;
+}
+
+void nrc_stats_deinit(void)
+{
+	struct stats_sta *cur, *next;
+
+	spin_lock(&state_lock);
+	list_for_each_entry_safe(cur, next, &state_head, list) {
+		nrc_stats_dbg("[deinit] %pM\n", cur->macaddr);
+		list_del(&cur->list);
+		kfree(cur->rssi);
+		kfree(cur->snr);
+		kfree(cur->metric);
+		kfree(cur);
+	}
+	spin_unlock(&state_lock);
+}
+
+int nrc_stats_update(uint8_t *macaddr, int8_t snr, int8_t rssi)
+{
+	struct stats_sta *cur, *next;
+
+	spin_lock(&state_lock);
+	list_for_each_entry_safe(cur, next, &state_head, list) {
+		if (memcmp(cur->macaddr, macaddr, 6) == 0) {
+			nrc_stats_rssi_update2(cur->rssi, rssi);
+			nrc_stats_snr_update2(cur->snr, snr);
+			nrc_stats_metric_update(cur->metric, rssi);
+			spin_unlock(&state_lock);
+			return 0;
+		}
+	}
+	spin_unlock(&state_lock);
+
+	return 0;
+}
+
+int nrc_stats_add(uint8_t *macaddr, int count)
+{
+	struct stats_sta *sta;
+	struct stats_sta *cur, *next;
+
+	spin_lock(&state_lock);
+	list_for_each_entry_safe(cur, next, &state_head, list) {
+		if (memcmp(cur->macaddr, macaddr, 6) == 0) {
+			nrc_stats_dbg("[exist] %pM\n", cur->macaddr);
+			spin_unlock(&state_lock);
+			return 0;
+		}
+	}
+	spin_unlock(&state_lock);
+
+	sta = kmalloc(sizeof(*sta), GFP_KERNEL);
+	if (!sta)
+		return -1;
+
+	INIT_LIST_HEAD(&sta->list);
+
+	spin_lock(&state_lock);
+	list_add_tail(&sta->list, &state_head);
+
+	ether_addr_copy(sta->macaddr, macaddr);
+
+	sta->rssi = nrc_stats_rssi_init2();
+	sta->snr = nrc_stats_snr_init2();
+	sta->metric = nrc_stats_metric_init();
+
+	nrc_stats_dbg("[add] %pM\n", macaddr);
+	spin_unlock(&state_lock);
+
+	return 0;
+}
+
+int nrc_stats_del(uint8_t *macaddr)
+{
+	struct stats_sta *cur, *next;
+
+	spin_lock(&state_lock);
+	list_for_each_entry_safe(cur, next, &state_head, list) {
+		if (memcmp(cur->macaddr, macaddr, 6) == 0) {
+			nrc_mac_dbg("[remove] %pM\n", cur->macaddr);
+			list_del(&cur->list);
+			kfree(cur->rssi);
+			kfree(cur->snr);
+			kfree(cur->metric);
+			kfree(cur);
+		}
+	}
+	spin_unlock(&state_lock);
+
+	return 0;
+}
+
+void nrc_stats_print(void)
+{
+	struct stats_sta *cur, *next;
+	int i = 0;
+
+	spin_lock(&state_lock);
+	list_for_each_entry_safe(cur, next, &state_head, list) {
+		nrc_stats_dbg("[%d] %pM snr:%d, rssi:%d\n",
+			i++,
+			cur->macaddr,
+			moving_average_compute(cur->snr),
+			moving_average_compute(cur->rssi));
+	}
+	spin_unlock(&state_lock);
+}
+
+int nrc_stats_report(uint8_t *output, int index, int number)
+{
+	struct stats_sta *cur, *next;
+	int i = 0;
+	int start = index;
+	int count = 0;
+
+	if (!output)
+		return -1;
+
+	if (!signal_monitor) {
+		nrc_dbg(NRC_DBG_CAPI, "%s Failure. Signal Monitor is disabled.", __func__);
+		return -1;
+	}
+
+	spin_lock(&state_lock);
+	list_for_each_entry_safe(cur, next, &state_head, list) {
+		if (i >= start) {
+			if (count > 0)
+				sprintf((output+strlen(output)), ",");
+			sprintf((output+strlen(output)), "%pM,%d,%d",
+				cur->macaddr,
+				moving_average_compute(cur->rssi),
+				moving_average_compute(cur->snr));
+			count++;
+			if (count == number)
+				break;
+		}
+		i++;
+	}
+
+	if (count > 0)
+		sprintf((output+strlen(output)), "\n");
+
+	spin_unlock(&state_lock);
+	return 0;
+}
+
+int nrc_stats_report_count(void)
+{
+	struct stats_sta *cur, *next;
+	int i = 0;
+
+	spin_lock(&state_lock);
+	list_for_each_entry_safe(cur, next, &state_head, list) {
+		i++;
+	}
+	spin_unlock(&state_lock);
+	return i;
+}
diff --git a/drivers/staging/nrc/nrc-stats.h b/drivers/staging/nrc/nrc-stats.h
new file mode 100644
index 000000000000..8b50393a5ede
--- /dev/null
+++ b/drivers/staging/nrc/nrc-stats.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef _NRC_STATS_H_
+#define _NRC_STATS_H_
+
+struct stats_sta {
+	uint8_t macaddr[6];
+	struct moving_average *snr;
+	struct moving_average *rssi;
+	struct moving_average *metric;
+
+	struct list_head list;
+};
+
+int nrc_stats_snr_init(int count);
+void nrc_stats_snr_deinit(void);
+void nrc_stats_snr_update(uint8_t snr);
+int nrc_stats_snr(void);
+
+int nrc_stats_rssi_init(int count);
+void nrc_stats_rssi_deinit(void);
+void nrc_stats_rssi_update(int8_t rssi);
+int nrc_stats_rssi(void);
+
+int nrc_stats_metric(uint8_t *macaddr);
+
+int nrc_stats_init(void);
+void nrc_stats_deinit(void);
+int nrc_stats_update(uint8_t *macaddr, int8_t snr, int8_t rssi);
+int nrc_stats_add(uint8_t *macaddr, int count);
+int nrc_stats_del(uint8_t *macaddr);
+void nrc_stats_print(void);
+int nrc_stats_report(uint8_t *output, int index, int number);
+int nrc_stats_report_count(void);
+#endif
diff --git a/drivers/staging/nrc/nrc-trx.c b/drivers/staging/nrc/nrc-trx.c
new file mode 100644
index 000000000000..56679f58c43c
--- /dev/null
+++ b/drivers/staging/nrc/nrc-trx.c
@@ -0,0 +1,1199 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * TX/RX routines
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/list.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <net/dst.h>
+#include <net/xfrm.h>
+#include <net/mac80211.h>
+#include <net/ieee80211_radiotap.h>
+#include <linux/if_arp.h>
+#include <linux/rtnetlink.h>
+#include <linux/etherdevice.h>
+#include <linux/platform_device.h>
+#include <linux/debugfs.h>
+#include <linux/module.h>
+#include <linux/ktime.h>
+#include <net/genetlink.h>
+#include <linux/spi/spi.h>
+#include <linux/gpio.h>
+#include "nrc-mac80211.h"
+#include "nrc-hif.h"
+#include "wim.h"
+#include "nrc-debug.h"
+#include "nrc-stats.h"
+#include "compat.h"
+#include "nrc-vendor.h"
+
+#define WLAN_FC_GET_TYPE(fc)	(((fc) & 0x000c) >> 2)
+#define WLAN_FC_GET_STYPE(fc)	(((fc) & 0x00f0) >> 4)
+
+static bool is_eapol(struct sk_buff *skb);
+static void setup_ba_session(struct nrc *nw, struct ieee80211_vif *vif, struct sk_buff *skb);
+
+/* TX */
+
+/**
+ * nrc_mac_tx() - main tx routine
+ *
+ * @hw: the hardware
+ * @control: tx control data
+ * @skb: the skb
+ */
+
+#ifdef CONFIG_SUPPORT_NEW_MAC_TX
+void nrc_mac_tx(struct ieee80211_hw *hw, struct ieee80211_tx_control *control,
+		struct sk_buff *skb)
+#else
+void nrc_mac_tx(struct ieee80211_hw *hw,
+		struct sk_buff *skb)
+#endif
+{
+	struct ieee80211_tx_info *txi = IEEE80211_SKB_CB(skb);
+	struct nrc_trx_handler *h;
+	int res = 0;
+	struct nrc_trx_data tx = {
+		.nw = hw->priv,
+		.vif = txi->control.vif,
+#ifdef CONFIG_SUPPORT_TX_CONTROL
+		.sta = control->sta,
+#else
+		.sta = txi->control.sta,
+#endif
+		.skb = skb,
+		.result = 0,
+	};
+
+	struct ieee80211_hdr *mh = (void*)skb->data;
+	s8 vif_id = hw_vifindex(tx.vif);
+
+	/* Set BA Session */
+	if (auto_ba) {
+		if (ieee80211_is_data_qos(mh->frame_control) &&
+			!is_multicast_ether_addr(mh->addr1) && !is_eapol(tx.skb)) {
+			setup_ba_session(tx.nw, tx.vif, tx.skb);
+		}
+	}
+
+	/* Only for PS STA */
+	if (tx.nw->vif[vif_id]->type == NL80211_IFTYPE_STATION) {
+		if (power_save == NRC_PS_MODEMSLEEP &&
+			tx.nw->ps_enabled && tx.nw->ps_drv_state) {
+			struct sk_buff *skb1;
+			struct wim_pm_param *p;
+
+			//nrc_hif_wakeup_device(nw->hif);
+			ieee80211_stop_queues(hw);
+			tx.nw->ps_drv_state = 0;
+			nrc_ps_dbg("[%s] Wakeup MODEMSLEEP...\n", __func__);
+			skb1 = nrc_wim_alloc_skb(tx.nw, WIM_CMD_SET, WIM_MAX_SIZE);
+			p = nrc_wim_skb_add_tlv(skb1, WIM_TLV_PS_ENABLE,
+							sizeof(struct wim_pm_param), NULL);
+			memset(p, 0, sizeof(struct wim_pm_param));
+			p->ps_mode = power_save;
+			p->ps_enable = tx.nw->ps_drv_state;
+			nrc_xmit_wim_request(tx.nw, skb1);
+		}
+
+		if (power_save >= NRC_PS_DEEPSLEEP_TIM) {
+			if (tx.nw->drv_state == NRC_DRV_PS) {
+				memset(&tx.nw->d_deauth, 0, sizeof(struct nrc_delayed_deauth));
+				if (ieee80211_is_deauth(mh->frame_control)) {
+					nrc_ps_dbg("[%s,L%d][deauth] drv_state:%d\n", __func__, __LINE__, tx.nw->drv_state);
+					memcpy(&tx.nw->d_deauth.v, tx.vif, sizeof(struct ieee80211_vif));
+					memcpy(&tx.nw->d_deauth.s, tx.sta, sizeof(struct ieee80211_sta));
+					gpio_set_value(RPI_GPIO_FOR_PS, 1);
+					nrc_hif_cleanup(tx.nw->hif);
+					tx.nw->d_deauth.deauth_frm = skb_copy(skb, GFP_ATOMIC);
+					atomic_set(&tx.nw->d_deauth.delayed_deauth, 1);
+					tx.nw->d_deauth.vif_index = hw_vifindex(tx.vif);
+					tx.nw->d_deauth.aid = tx.sta->aid;
+				}
+				if (ieee80211_is_qos_nullfunc(mh->frame_control)) {
+					nrc_ps_dbg("[%s,L%d][qos_null] make target wake for keep-alive\n", __func__, __LINE__);
+					gpio_set_value(RPI_GPIO_FOR_PS, 1);
+				}
+				goto txh_out;
+			} else if (tx.nw->drv_state != NRC_DRV_RUNNING) {
+				/*
+				 * Sometimes a deauth frame is transferred while nrc_unregister_hw() is 
+				 * in processing(NRC_DRV_CLOSING) at the result of 'ifconfig down'.
+				 * We don't need to handle this.
+				 */
+				if (ieee80211_is_deauth(mh->frame_control)) {
+					nrc_ps_dbg("[%s,L%d][deauth] drv_state:%d ===> discard!!!\n", __func__, __LINE__, tx.nw->drv_state);
+				}
+				goto txh_out;
+			}
+		}
+
+		if (ieee80211_hw_check(hw, SUPPORTS_DYNAMIC_PS) &&
+			hw->conf.dynamic_ps_timeout > 0) {
+			mod_timer(&tx.nw->dynamic_ps_timer,
+				jiffies + msecs_to_jiffies(hw->conf.dynamic_ps_timeout));
+		}
+	 }//if (tx.nw->vif[vif_id]->type == NL80211_IFTYPE_STATION)
+
+	/* Iterate over tx handlers */
+	for (h = &__tx_h_start; h < &__tx_h_end; h++) {
+
+		if (!(h->vif_types & BIT(tx.vif->type)))
+			continue;
+
+		res = h->handler(&tx);
+		if (res < 0)
+			goto txh_out;
+	}
+
+	if (!atomic_read(&tx.nw->d_deauth.delayed_deauth))
+		nrc_xmit_frame(tx.nw, vif_id, (!!tx.sta ? tx.sta->aid : 0), tx.skb);
+
+	return;
+
+txh_out:
+	dev_kfree_skb(tx.skb);
+}
+
+static bool is_eapol(struct sk_buff *skb)
+{
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+	u16 hdrlen = ieee80211_hdrlen(hdr->frame_control);
+
+	struct {
+		u8 hdr[6] __aligned(2);
+		__be16 proto;
+	} payload;
+
+	skb_copy_bits(skb, hdrlen, &payload, sizeof(payload));
+
+	return (payload.proto == htons(ETH_P_PAE));
+}
+
+static void setup_ba_session(struct nrc *nw, struct ieee80211_vif *vif, struct sk_buff *skb)
+{
+	struct ieee80211_sta *peer_sta= NULL;
+	struct nrc_sta *i_sta = NULL;
+	struct ieee80211_qos_hdr *qmh = (struct ieee80211_qos_hdr *) skb->data;
+	int tid = qmh->qos_ctrl & 0x7;
+
+	/* Set up BA session if not created */
+	/* tid range : 0 ~ 7 */
+	 if (tid >= 0 && tid < NRC_MAX_TID) {
+		/* Find Peer STA with ADDR1  to set up BA Session */
+		peer_sta = ieee80211_find_sta(vif, qmh->addr1);
+		if (peer_sta) {
+			i_sta = to_i_sta(peer_sta);
+			if (i_sta) {
+				if (i_sta->tx_ba_session[tid] == IEEE80211_BA_NONE ||
+					i_sta->tx_ba_session[tid] == IEEE80211_BA_CLOSE) {
+					nrc_dbg(NRC_DBG_STATE, "%s: Setting up BA session for Tx TID %d with peer (%pM)",
+						__func__, tid, peer_sta->addr);
+					nw->ampdu_supported = true;
+					nw->ampdu_reject = false;
+					if(ieee80211_start_tx_ba_session(peer_sta, tid, 0) == -EBUSY) {
+						nrc_dbg(NRC_DBG_STATE, "%s: receiver does not want A-MPDU so disable BA session (TID:%d)", __func__, tid);
+						i_sta->tx_ba_session[tid] = IEEE80211_BA_DISABLE;
+					}
+				} else if( i_sta->tx_ba_session[tid] == IEEE80211_BA_REJECT ) {
+					if(jiffies_to_msecs(jiffies - i_sta->ba_req_last_jiffies[tid]) > 5000) {
+						i_sta->tx_ba_session[tid] = IEEE80211_BA_NONE;
+						i_sta->ba_req_last_jiffies[tid] = 0;
+						nrc_dbg(NRC_DBG_STATE, "%s: reset ba status(TID:%d)", __func__, tid);
+					} 
+				}
+			}
+		} else {
+			nrc_mac_dbg("Fail to set up BA. Fail to find nrc_sta (%pM)", qmh->addr1);
+		}
+	} else {
+		nrc_mac_dbg("Invalid TID(%d) with peer %pM", tid, qmh->addr1);
+	}
+}
+
+static const char *
+to_state(enum ieee80211_sta_state state)
+{
+	switch (state) {
+	case IEEE80211_STA_NOTEXIST:
+		return "NOTEXIST";
+	case IEEE80211_STA_NONE:
+		return "NONE";
+	case IEEE80211_STA_AUTH:
+		return "AUTH";
+	case IEEE80211_STA_ASSOC:
+		return "ASSOC";
+	case IEEE80211_STA_AUTHORIZED:
+		return "AUTHORIZED";
+	default:
+		return "unknown";
+	};
+
+}
+
+
+#if NRC_DBG_PRINT_FRAME
+static int tx_h_debug_print(struct nrc_trx_data *tx)
+{
+	struct ieee80211_sta *sta;
+    struct nrc_vif *i_vif;
+	struct nrc_sta *i_sta;
+	const struct ieee80211_hdr *hdr;
+	__le16 fc;
+
+	if (!tx) {
+		nrc_mac_dbg("[%s] tx is NULL", __func__);
+		return 0;
+	}
+
+    i_vif = to_i_vif(tx->vif);
+	if (!i_vif) {
+		nrc_mac_dbg("[%s] vif is NULL", __func__);
+		return 0;
+	}
+
+	hdr = (const struct ieee80211_hdr *) tx->skb->data;
+	fc = hdr->frame_control;
+
+	nrc_mac_dbg("[%s] %s vif:%d type:%d sype:%d, protected:%d\n",
+		__func__, (tx->vif->type == NL80211_IFTYPE_STATION)?"STA":
+		(tx->vif->type == NL80211_IFTYPE_AP)?"AP":"MONITORP",
+		i_vif->index, WLAN_FC_GET_TYPE(fc), WLAN_FC_GET_STYPE(fc),
+		ieee80211_has_protected(fc));
+
+	if (is_unicast_ether_addr(hdr->addr1)) {
+		sta = ieee80211_find_sta(tx->vif, hdr->addr1);
+		if (!sta) {
+			nrc_mac_dbg("[%s] Unable to find %pM in mac80211",__func__, hdr->addr1);
+		return 0;
+		}
+	}
+
+	i_sta = to_i_sta(sta);
+	if (!i_sta) {
+		nrc_mac_dbg("[%s] Unable to find %pM in nrc drv",
+			__func__, hdr->addr1);
+		return 0;
+	}
+
+	// set filter here : add filter as you wish
+	//eg. ieee80211_is_data(fc) ieee80211_is_mgmt(fc)
+	//eg. ieee80211_is_assoc_req
+	if (ieee80211_is_deauth(fc)) {
+		print_hex_dump(KERN_DEBUG, "tx deauth frame: ", DUMP_PREFIX_NONE, 16, 1,
+			tx->skb->data, tx->skb->len, false);
+	}
+	return 0;
+}
+TXH(tx_h_debug_print, NL80211_IFTYPE_ALL);
+#endif //#if NRC_DBG_PRINT_FRAME
+
+static int tx_h_debug_state(struct nrc_trx_data *tx)
+{
+	struct ieee80211_sta *sta;
+	struct nrc_sta *i_sta;
+	const struct ieee80211_hdr *hdr =
+		(const struct ieee80211_hdr *) tx->skb->data;
+
+	if (!tx || !tx->sta ||
+	      (!ieee80211_is_data(hdr->frame_control) ||
+	       is_eapol(tx->skb)))
+		return 0;
+
+	sta = ieee80211_find_sta(tx->vif, hdr->addr1);
+
+	if (!sta) {
+		nrc_mac_dbg("Unable to find %pM", hdr->addr1);
+		return 0;
+	}
+
+	i_sta = to_i_sta(sta);
+
+	if (!i_sta)
+		return 0;
+
+	if (i_sta->state != IEEE80211_STA_AUTHORIZED)
+		nrc_mac_dbg("%s: Wrong state (%s)/%pM",
+		     __func__, to_state(i_sta->state), hdr->addr1);
+
+	return 0;
+}
+TXH(tx_h_debug_state, NL80211_IFTYPE_ALL);
+
+
+static int tx_h_wfa_halow_filter(struct nrc_trx_data *tx)
+{
+	struct nrc *nw = tx->nw;
+
+	if (nw->block_frame) {
+		nrc_mac_dbg("%s: TX is blocked (Halow)",
+				__func__);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+TXH(tx_h_wfa_halow_filter, NL80211_IFTYPE_ALL);
+
+static int tx_h_frame_filter(struct nrc_trx_data *tx)
+{
+	const struct ieee80211_hdr *hdr;
+	__le16 fc;
+
+	if (!tx) {
+		nrc_mac_dbg("[%s] tx is NULL", __func__);
+		return 0;
+	}
+
+	if (discard_deauth && tx->vif->type == NL80211_IFTYPE_STATION) {
+		hdr = (const struct ieee80211_hdr *) tx->skb->data;
+		fc = hdr->frame_control;
+		if (ieee80211_is_deauth(fc)) {
+			nrc_mac_dbg("[%s] discard TX deauth frame\n", __func__);
+			return -1;
+		}
+	}
+	return 0;
+}
+TXH(tx_h_frame_filter, NL80211_IFTYPE_ALL);
+
+#ifdef CONFIG_SUPPORT_P2P
+static int tx_h_managed_p2p_intf_addr(struct nrc_trx_data *tx)
+{
+	struct ieee80211_mgmt *mgmt = NULL;
+	const u8 *p2p_ie = NULL;
+	u8 *pos = NULL, *p2p_len = NULL, *cnt = NULL;
+	u16 *attr_len = NULL, len = 0;
+	const int P2P_ATTR_INTERFACE = 0x10;
+	u8 target[ETH_ALEN];
+	u8 i;
+
+	if (tx->vif->p2p)
+		return 0;
+
+	mgmt = (void *) tx->skb->data;
+
+	if (!(ieee80211_is_assoc_req(mgmt->frame_control) &&
+		!ieee80211_is_reassoc_req(mgmt->frame_control)))
+		return 0;
+
+	p2p_ie = cfg80211_find_vendor_ie(WLAN_OUI_WFA,
+			WLAN_OUI_TYPE_WFA_P2P,
+			mgmt->u.assoc_req.variable,
+			tx->skb->len - (mgmt->u.assoc_req.variable
+			- tx->skb->data));
+
+	if (!p2p_ie)
+		return 0;
+
+	ether_addr_copy(target, tx->vif->addr);
+	target[0] = 0x6;
+	target[1] = 0x1;
+
+	pos = (u8 *)p2p_ie;
+	p2p_len = (pos+1);
+	pos += 6; /* Skip OUI + OUI Type */
+
+	while (pos - p2p_ie < *p2p_len) {
+		attr_len = (u16 *)(pos+1);
+		len = le16_to_cpu(*attr_len);
+
+		if (len == 0)
+			return 0;
+
+		if (*pos != P2P_ATTR_INTERFACE) {
+			pos += (3 /*ID+Len*/ + len);
+			continue;
+		}
+		pos += 3; /* Skip id + len */
+		pos += 6; /* Skip Device Address */
+
+		cnt = pos++;
+		for (i = 0; i < *cnt; i++, pos += 6) {
+			if (ether_addr_equal(target, pos))
+				return 0;
+		}
+		*cnt += 1;
+		*p2p_len += 6;
+		*attr_len = cpu_to_le16(len + 6);
+		skb_put(tx->skb, 6);
+		memmove(pos + 6, pos, tx->skb->len - (pos - tx->skb->data));
+		ether_addr_copy(pos, target);
+
+		return 0;
+	}
+
+	return 0;
+}
+TXH(tx_h_managed_p2p_intf_addr, NL80211_IFTYPE_ALL);
+#endif
+
+/**
+ * tx_h_put_iv() - Put a space for IV header.
+ *
+ * @tx: points to the tx context.
+ *
+ * If IEEE80211_SKB_CB(@tx->skb)
+ */
+static int tx_h_put_iv(struct nrc_trx_data *tx)
+{
+	struct sk_buff *skb = tx->skb;
+	struct ieee80211_tx_info *txi = IEEE80211_SKB_CB(skb);
+	struct ieee80211_key_conf *key = txi->control.hw_key;
+	struct ieee80211_hdr *mh = (void *) skb->data;
+	__le16 fc = mh->frame_control;
+	int hdrlen = ieee80211_hdrlen(fc);
+
+	if (ieee80211_has_protected(fc) && key &&
+			!(key->flags & IEEE80211_KEY_FLAG_GENERATE_IV))
+		memcpy(skb_push(skb, key->iv_len), mh, hdrlen);
+
+	return 0;
+}
+TXH(tx_h_put_iv, NL80211_IFTYPE_ALL);
+
+
+/* RX */
+
+static void nrc_mac_rx_h_status(struct nrc *nw, struct sk_buff *skb)
+{
+	struct frame_hdr *fh;
+	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);
+	struct ieee80211_hdr *mh;
+
+
+	fh = (void *)skb->data; /* frame header */
+	mh = (void *)(skb->data+nw->fwinfo.rx_head_size - sizeof(struct hif));
+
+	memset(status, 0, sizeof(*status));
+
+	status->signal = fh->flags.rx.rssi;
+	status->freq = fh->info.rx.frequency;
+	status->band = nw->band; /* I hate this */
+	status->rate_idx = 0;
+
+	if (fh->flags.rx.error_mic)
+		status->flag |= RX_FLAG_MMIC_ERROR;
+	if (fh->flags.rx.iv_stripped)
+		status->flag |= RX_FLAG_IV_STRIPPED;
+
+#if ((KERNEL_VERSION(4, 4, 132) <= NRC_TARGET_KERNEL_VERSION) && (KERNEL_VERSION(4, 5, 0) > NRC_TARGET_KERNEL_VERSION)) ||\
+	(KERNEL_VERSION(4, 7, 0) <= NRC_TARGET_KERNEL_VERSION)
+	if(mh->frame_control & 0x0400)
+	{
+		status->flag |= RX_FLAG_ALLOW_SAME_PN;
+	}
+#endif
+	if (signal_monitor) {
+		//update snr and rssi only if signal monitor is enabled
+		nrc_stats_update(mh->addr2, fh->flags.rx.snr, fh->flags.rx.rssi);
+		//nrc_stats_print();
+	}
+
+}
+
+static void nrc_rx_handler(void *data, u8 *mac, struct ieee80211_vif *vif)
+{
+	struct nrc_trx_data *rx	= data;
+	struct ieee80211_hdr *mh = (struct ieee80211_hdr *)rx->skb->data;
+	struct ieee80211_sta *sta;
+	struct nrc_trx_handler *h;
+	int res = 0;
+
+	rcu_read_lock();
+	sta = ieee80211_find_all_sta(vif, mh->addr2);
+	if (!sta)
+		goto rxh_out;
+
+	/* The received frame is from @sta to @vif */
+	rx->vif = vif;
+	rx->sta = sta;
+
+	/* Call rx handlers */
+	for (h = &__rx_h_start; h < &__rx_h_end; h++) {
+
+		if (!(h->vif_types & BIT(vif->type)))
+			continue;
+
+		res = h->handler(rx);
+		if (res < 0)
+			goto rxh_out;
+	}
+
+rxh_out:
+	rcu_read_unlock();
+	rx->result = res;
+}
+
+static int nrc_mac_s1g_monitor_rx(struct nrc *nw, struct sk_buff *skb);
+
+/**
+ * nrc_mac_rx() - main rx routine
+ *
+ * @nw: points to NRC controller data
+ * @skb: a received frame with the leading HIF header peeled off.
+ */
+int nrc_mac_rx(struct nrc *nw, struct sk_buff *skb)
+{
+	struct nrc_trx_data rx = { .nw = nw, .skb = skb, };
+	int ret = 0;
+	u64 now = 0, diff = 0;
+
+	if (!((nw->drv_state == NRC_DRV_RUNNING) ||
+		(nw->drv_state == NRC_DRV_PS)) ||
+		atomic_read(&nw->d_deauth.delayed_deauth)) {
+		nrc_mac_dbg("Target not ready, discarding frame)");
+		dev_kfree_skb(skb);
+		return 0;
+	}
+
+	nrc_mac_rx_h_status(nw, skb);
+
+	if (nw->promisc) {
+		ret = nrc_mac_s1g_monitor_rx(nw, skb);
+		return ret;
+	}
+
+	/* Peel off frame header */
+	skb_pull(skb, nw->fwinfo.rx_head_size - sizeof(struct hif));
+
+	now = ktime_to_us(ktime_get_real());
+
+#ifdef CONFIG_SUPPORT_ITERATE_INTERFACE
+	/* Iterate over active interfaces */
+	ieee80211_iterate_interfaces(nw->hw, IEEE80211_IFACE_ITER_ACTIVE,
+				     nrc_rx_handler, &rx);
+#else
+	/* Iterate over active interfaces */
+	ieee80211_iterate_active_interfaces(nw->hw,
+				     nrc_rx_handler, &rx);
+#endif
+
+	diff = ktime_to_us(ktime_get_real()) - now;
+	//if ((!diff) || (diff > NRC_MAC80211_RCU_LOCK_THRESHOLD))
+	if (diff > NRC_MAC80211_RCU_LOCK_THRESHOLD)
+		nrc_mac_dbg("%s, diff=%lu", __func__, (unsigned long)diff);
+
+	if (!rx.result) {
+		struct ieee80211_hdr *mh = (void*)skb->data;
+		__le16 fc = mh->frame_control;
+
+		if (!disable_cqm) {
+			if (nw->associated && ieee80211_is_probe_resp(fc)) {
+				mod_timer(&nw->bcn_mon_timer,
+					jiffies + msecs_to_jiffies(nw->beacon_timeout));
+			}
+		}
+
+		ieee80211_rx_irqsafe(nw->hw, rx.skb);
+		if (ieee80211_hw_check(nw->hw, SUPPORTS_DYNAMIC_PS)) {
+			if (ieee80211_is_data(fc) && nw->ps_enabled &&
+				(nw->hw->conf.dynamic_ps_timeout > 0)) {
+				mod_timer(&nw->dynamic_ps_timer,
+					jiffies + msecs_to_jiffies(nw->hw->conf.dynamic_ps_timeout));
+			}
+		} else {
+			if (nw->invoke_beacon_loss) {
+				nw->invoke_beacon_loss = false;
+				ieee80211_beacon_loss(nw->vif[0]);
+			}
+		}
+	}
+
+	return 0;
+}
+
+/**
+ * rx_h_decrypt() - increase the length of a frame by icv length
+ *
+ * TODO:
+ * - Verify if using key information stored in i_sta is valid.
+ * - Consider using ieee80211_iter_key to find the key.
+ * - What if multiple keys for a station?
+ */
+static int rx_h_decrypt(struct nrc_trx_data *rx)
+{
+	struct ieee80211_hdr *mh = (void *) rx->skb->data;
+	struct nrc *nw = rx->nw;
+	struct ieee80211_rx_status *status;
+	struct ieee80211_key_conf *key;
+	struct nrc_sta *i_sta = to_i_sta(rx->sta);
+	struct nrc_vif *i_vif = to_i_vif(rx->vif);
+	int vif_id = i_vif->index;
+	__le16 fc = mh->frame_control;
+
+	if (!(nw->cap.vif_caps[vif_id].cap_mask & WIM_SYSTEM_CAP_HWSEC))
+		return 0;
+
+	if (!ieee80211_has_protected(fc))
+		return 0;
+
+	/*
+	 * @skb->len from the target does not account for ICV/MIC.
+	 * Since mac80211 trims it if RX_FLAG_IV_STRIPPED, we need to
+	 * increment @skb->len by that amount.
+	 */
+	key = is_multicast_ether_addr(mh->addr1) ? i_sta->gtk : i_sta->ptk;
+
+	if (!key)
+		return 0;
+
+	switch (key->cipher) {
+	case WLAN_CIPHER_SUITE_WEP40:
+	case WLAN_CIPHER_SUITE_WEP104:
+	case WLAN_CIPHER_SUITE_TKIP:
+	case WLAN_CIPHER_SUITE_CCMP:
+#ifdef CONFIG_SUPPORT_CCMP_256
+	case WLAN_CIPHER_SUITE_CCMP_256:
+#endif
+		rx->skb->len += key->icv_len;
+		break;
+	default:
+		nrc_dbg(NRC_DBG_MAC, "%s: unknown cipher (%d)",
+			__func__, key->cipher);
+		return 0;
+	}
+
+	/*
+	 * Target stripped ICV/MIC, but not IV.
+	 * We do not set RX_FLAG_IV_STRPPED.
+	 */
+	status = IEEE80211_SKB_RXCB(rx->skb);
+	status->flag |= RX_FLAG_DECRYPTED;
+	status->flag |= RX_FLAG_MMIC_STRIPPED;
+
+	return 0;
+}
+RXH(rx_h_decrypt, NL80211_IFTYPE_ALL);
+
+static int nrc_vendor_ann_event(struct nrc *nw,
+			const u8 *data, u16 len, enum nrc_vendor_event eid)
+{
+	struct ieee80211_hw *hw = nw->hw;
+	struct sk_buff *skb;
+
+	print_hex_dump(KERN_DEBUG, "event: ", DUMP_PREFIX_NONE,
+			16, 1, data, len, false);
+
+	skb = cfg80211_vendor_event_alloc(hw->wiphy,
+			NULL, 255, eid,
+			GFP_KERNEL);
+
+	if (!skb)
+		return -ENOMEM;
+
+	if (nla_put(skb, NRC_VENDOR_ATTR_DATA,
+		len, data)) {
+		kfree_skb(skb);
+		return -EMSGSIZE;
+	}
+
+	cfg80211_vendor_event(skb, GFP_KERNEL);
+
+	return 0;
+}
+
+static int rx_h_vendor(struct nrc_trx_data *rx)
+{
+	struct ieee80211_hdr *mh = (void *) rx->skb->data;
+	__le16 fc = mh->frame_control;
+	u16 ies_offset, len;
+	const u8 *pos, *data, ann_subs[] = {
+		NRC_SUBCMD_WOWLAN_PATTERN, NRC_SUBCMD_ANNOUNCE1,
+		NRC_SUBCMD_ANNOUNCE2, NRC_SUBCMD_ANNOUNCE3,
+		NRC_SUBCMD_ANNOUNCE4, NRC_SUBCMD_ANNOUNCE5
+	};
+	const int OUIT_LEN = 4;
+	u8 i;
+
+	if (!ieee80211_is_beacon(fc))
+		return 0;
+	else {
+		if (!disable_cqm && rx->nw->associated) {
+			mod_timer(&rx->nw->bcn_mon_timer,
+				jiffies + msecs_to_jiffies(rx->nw->beacon_timeout));
+		}
+	}
+
+	ies_offset = offsetof(struct ieee80211_mgmt,
+			u.beacon.variable);
+
+	for (i = 0; i < ARRAY_SIZE(ann_subs); i++) {
+		pos = cfg80211_find_vendor_ie(
+			OUI_IEEE_REGISTRATION_AUTHORITY, ann_subs[i],
+			rx->skb->data + ies_offset,
+			rx->skb->len - ies_offset);
+
+		if (pos) {
+			len = *(pos + 1);
+			data = pos + 2 /*ID(1)+LEN(1)*/ + OUIT_LEN;
+			len -= OUIT_LEN;
+			nrc_vendor_ann_event(rx->nw, data, len, ann_subs[i]);
+		}
+	}
+	return 0;
+}
+
+RXH(rx_h_vendor, NL80211_IFTYPE_ALL);
+
+#if NRC_DBG_PRINT_FRAME
+static int rx_h_debug_print(struct nrc_trx_data *rx)
+{
+	struct ieee80211_sta *sta;
+	struct ieee80211_hdr *hdr;
+	//struct ieee80211_rx_status *status;
+	struct nrc_sta *i_sta;
+	struct nrc_vif *i_vif;
+	__le16 fc;
+
+	if (!rx) {
+		nrc_mac_dbg("[%s] rx is NULL", __func__);
+		return 0;
+	}
+
+	i_sta = to_i_sta(rx->sta);
+	i_vif = to_i_vif(rx->vif);
+	hdr = (struct ieee80211_hdr *) rx->skb->data;
+	fc = hdr->frame_control;
+
+	nrc_mac_dbg("[%s] %s vif:%d type:%d sype:%d, protected:%d\n",
+		__func__, (rx->vif->type == NL80211_IFTYPE_STATION)?"STA":
+        (rx->vif->type == NL80211_IFTYPE_AP)?"AP":"MONITORP",
+        i_vif->index, WLAN_FC_GET_TYPE(fc), WLAN_FC_GET_STYPE(fc),
+        ieee80211_has_protected(fc));
+
+
+    if (is_unicast_ether_addr(hdr->addr2)) {
+        sta = ieee80211_find_sta(rx->vif, hdr->addr2);
+        if (!sta) {
+            nrc_mac_dbg("[%s] Unable to find %pM in mac80211",
+                    __func__, hdr->addr2);
+            return 0;
+        }
+    }
+
+	i_sta = to_i_sta(sta);
+	if (!i_sta) {
+		nrc_mac_dbg("[%s] Unable to find %pM in nrc drv",
+			__func__, hdr->addr2);
+		return 0;
+	}
+
+	// set filter here : add filter as you wish
+	//eg. ieee80211_is_data(fc) ieee80211_is_mgmt(fc)
+	//eg. ieee80211_is_assoc_req
+	if (ieee80211_is_deauth(fc)) {
+		print_hex_dump(KERN_DEBUG, "rx deauth frame: ", DUMP_PREFIX_NONE, 16, 1,
+			rx->skb->data, rx->skb->len, false);
+	}
+
+	return 0;
+}
+RXH(rx_h_debug_print, NL80211_IFTYPE_ALL);
+#endif //#if NRC_DBG_PRINT_FRAME
+
+
+/**
+ * nrc_mac_trx_init() - Initialize TRX data path
+ *
+ *
+ * TODO:
+ * Handlers are registered during compile time, not
+ * via nrc_mac_{tx,rx}_h_register().
+ */
+void nrc_mac_trx_init(struct nrc *nw)
+{
+	int i;
+
+	spin_lock_init(&nw->txq_lock);
+	INIT_LIST_HEAD(&nw->txq);
+	for (i = 0; i < ARRAY_SIZE(nw->tx_credit); i++) {
+		atomic_set(&nw->tx_credit[i], 0);
+		atomic_set(&nw->tx_pend[i], 0);
+	}
+
+	if (power_save >= NRC_PS_DEEPSLEEP_TIM) {
+		if (gpio_request(RPI_GPIO_FOR_PS, "nrc-wakeup") < 0) {
+			nrc_ps_dbg("gpio_reqeust(nrc-wakeup) is failed\n");
+			gpio_free(RPI_GPIO_FOR_PS);
+			return;
+		}
+		gpio_direction_output(RPI_GPIO_FOR_PS, 0);
+	}
+}
+
+static int sta_h_trx_cleanup_sta(struct ieee80211_hw *hw,
+				     struct ieee80211_vif *vif,
+				     struct ieee80211_sta *sta,
+				     enum ieee80211_sta_state old_state,
+				     enum ieee80211_sta_state new_state)
+{
+	struct nrc_sta *i_sta = to_i_sta(sta);
+	struct nrc *nw = i_sta->nw;
+	int qid, cnt = 0;
+	struct sk_buff *skb, *next;
+	struct ieee80211_hdr *hdr;
+	struct sk_buff_head skbs;
+
+	if (!i_sta || !(old_state == IEEE80211_STA_ASSOC &&
+		   new_state == IEEE80211_STA_AUTH))
+		return 0;
+
+	nw = i_sta->nw;
+	skb_queue_head_init(&skbs);
+
+	spin_lock_bh(&nw->txq_lock);
+	for (qid = 0; qid < NRC_QUEUE_MAX; qid++) {
+		skb_queue_walk_safe(&nw->ntxq[qid].queue, skb, next) {
+			hdr = (struct ieee80211_hdr *) skb->data;
+			if (unlikely(!ieee80211_is_data(hdr->frame_control)))
+				continue;
+
+			if (vif->type != NL80211_IFTYPE_STATION &&
+				!ether_addr_equal(sta->addr, hdr->addr1))
+				continue;
+
+			skb_unlink(skb, &nw->ntxq[qid].queue);
+#ifdef CONFIG_CHECK_DATA_SIZE
+			nw->ntxq[qid].data_size -= skb->len;
+#endif
+			skb_queue_tail(&skbs, skb);
+		}
+	}
+	spin_unlock_bh(&nw->txq_lock);
+
+	skb_queue_walk_safe(&skbs, skb, next) {
+		ieee80211_free_txskb(hw, skb);
+		cnt++;
+	}
+
+	if (cnt)
+		nrc_dbg(NRC_DBG_STATE,
+		   "Remove pending %d packets to removed sta:%pM",
+		   cnt, sta->addr);
+
+	return 0;
+}
+STAH(sta_h_trx_cleanup_sta);
+
+#ifdef CONFIG_NRC_HIF_DUMP_S1G_RXINFO
+
+/* S1G monitor mode */
+#define RXIF \
+"-- RX Info (v:%d ok:%d crc:%d agg:%d ndp:%d mpdu_len:%d " \
+"timestamp:%d fcs:%#x bw:%d ptype:%d format:%d rcpi:%d)"
+
+#define SIG1MF \
+"-- S1G1M (len:%d agg:%d ndp:%d rsp:%d mcs:%d " \
+"coding:%d stbc:%d short_gi:%d)"
+
+#define SIGSHORTF \
+"-- S1GShort (len:%d id:%d agg:%d ndp:%d rsp:%d " \
+"mcs:%d coding:%d stbc:%d short_gi:%d bw:%d ul_ind:%d)"
+
+static void nrc_dump_s1g_sig_rxinfo(struct sk_buff *skb)
+{
+	struct sigS1g *sig_s1g;
+	struct rxInfo *rxi;
+	bool s1g_1m_ppdu;
+
+	sig_s1g  = (void *)(skb->data + sizeof(struct frame_hdr));
+	rxi = (void *)(sig_s1g + 1);
+
+	s1g_1m_ppdu = rxi->bandwidth == WIM_BW_1M ||
+		(rxi->bandwidth == WIM_BW_2M && rxi->format == WIM_S1G_DUP_1M);
+
+	nrc_mac_dbg(RXIF, rxi->valid, rxi->okay, rxi->error_crc,
+		    rxi->aggregation, rxi->ndp_ind,
+		    rxi->mpdu_length, rxi->timestamp,
+		    rxi->fcs, rxi->bandwidth, rxi->preamble_type,
+		    rxi->format, rxi->rcpi);
+
+	if (rxi->bandwidth == WIM_BW_1M ||
+	    (rxi->bandwidth == WIM_BW_2M && rxi->format == WIM_S1G_DUP_1M)) {
+		/* 1M or 1M dup (or workaround : 2M & 1M_DUP) */
+		nrc_mac_dbg(SIG1MF, sig_s1g->flags.s1g1M.length,
+			    sig_s1g->flags.s1g1M.aggregation,
+			    sig_s1g->flags.s1g1M.ndp_ind,
+			    sig_s1g->flags.s1g1M.response_ind,
+			    sig_s1g->flags.s1g1M.mcs,
+			    sig_s1g->flags.s1g1M.coding,
+			    sig_s1g->flags.s1g1M.stbc,
+			    sig_s1g->flags.s1g1M.short_gi);
+	} else {
+		/* 2/4/8/16M */
+		nrc_mac_dbg(SIGSHORTF, sig_s1g->flags.s1gShort.length,
+			    sig_s1g->flags.s1gShort.id,
+			    sig_s1g->flags.s1gShort.aggregation,
+			    sig_s1g->flags.s1gShort.ndp_ind,
+			    sig_s1g->flags.s1gShort.response_ind,
+			    sig_s1g->flags.s1gShort.mcs,
+			    sig_s1g->flags.s1gShort.coding,
+			    sig_s1g->flags.s1gShort.stbc,
+			    sig_s1g->flags.s1gShort.short_gi,
+			    sig_s1g->flags.s1gShort.bandwidth,
+			    sig_s1g->flags.s1gShort.uplink_ind);
+	}
+}
+#endif
+
+#define NRC_CHAN_700MHZ		0x0001
+#define NRC_CHAN_800MHZ		0x0002
+#define NRC_CHAN_900MHZ		0x0004
+
+static void
+nrc_add_rx_s1g_radiotap_header(struct nrc *nw, struct sk_buff *skb)
+{
+	struct nrc_radiotap_hdr rt_hdr, *prt_hdr;
+	struct sigS1g *sig_s1g;
+	struct rxInfo *rxi;
+	u32 mcs = 0, response_ind = 0;
+	bool short_gi = false, s1g_1m_ppdu;
+	bool ndp_ind, agg = false;
+	uint32_t fcs;
+	uint8_t *p;
+	struct nrc_radiotap_hdr_agg rt_hdr_agg, *prt_hdr_agg;
+	struct nrc_radiotap_hdr_ndp rt_hdr_ndp, *prt_hdr_ndp;
+	uint8_t color = 0;
+	uint8_t uplink_ind = 0;
+
+#ifdef CONFIG_NRC_HIF_DUMP_S1G_RXINFO
+	nrc_dump_s1g_sig_rxinfo(skb);
+#endif
+
+	sig_s1g  = (void *) (skb->data + sizeof(struct frame_hdr));
+	rxi = (void *) (sig_s1g + 1);
+	ndp_ind = (bool) rxi->ndp_ind;
+	fcs = rxi->fcs;
+
+	s1g_1m_ppdu = rxi->bandwidth == WIM_BW_1M ||
+		(rxi->bandwidth == WIM_BW_2M &&
+		rxi->format == WIM_S1G_DUP_1M);
+
+	if (!ndp_ind) {
+		if (s1g_1m_ppdu) {
+			/* 1M or 1M dup (or workaround : 2M & 1M_DUP) */
+			mcs = sig_s1g->flags.s1g1M.mcs;
+			short_gi = sig_s1g->flags.s1g1M.short_gi & 0x1;
+			response_ind =
+				sig_s1g->flags.s1g1M.response_ind & 0x3;
+			agg = sig_s1g->flags.s1g1M.aggregation;
+		} else {
+			/* 2/4/8/16M */
+			mcs = sig_s1g->flags.s1gShort.mcs;
+			short_gi = sig_s1g->flags.s1gShort.short_gi & 0x1;
+			response_ind =
+				sig_s1g->flags.s1gShort.response_ind & 0x3;
+			agg = sig_s1g->flags.s1gShort.aggregation;
+			color = sig_s1g->flags.s1gShort.id & 0x7;
+			uplink_ind = sig_s1g->flags.s1gShort.uplink_ind;
+		}
+	} else {
+		/* NDP frame */
+		skb_put(skb, 6);
+		p = (uint8_t *)(rxi + 1);
+		*p = ((*(char *)sig_s1g & 0x07) == 0x07) ? 0xF0 : 0x04;
+		/*
+		 * README: Remove reserved field of 2MHz NDP frame
+		 *			  Aaron - 2019-0412 - Gerrit#1973
+		 */
+		if (!s1g_1m_ppdu) {
+			memcpy((char *)(p + 1), (char *)&sig_s1g->flags, 3);
+			memcpy((char *)(p + 4), (char *)&sig_s1g->flags + 4, 2);
+		} else
+			memcpy((void *)(p + 1), (void *)&sig_s1g->flags, 5);
+
+		*(p + 5) = (*(p + 5) & 0x3F) | ((s1g_1m_ppdu) ? 0 : (0x2 << 6));
+	}
+
+	/**
+	 * README: Change RSSI value refernce - Aaron - 2019-0531
+	 *   original: RCPI based calculation - RSSI = (RCPI/2)-122
+	 *   new: replace RCPI with RSSI value of Rx Vector
+	 **/
+	/* prt_hdr->rt_rssi = rxi->rcpi; */
+
+	if (ndp_ind) {
+		rt_hdr_ndp.hdr.it_version = PKTHDR_RADIOTAP_VERSION;
+		rt_hdr_ndp.hdr.it_pad = 0;
+
+		rt_hdr_ndp.rt_tsft = cpu_to_le64(rxi->timestamp);
+		 /* frame include FCS */
+		rt_hdr_ndp.rt_flags = ((ndp_ind) ? 0x00:0x10);
+		rt_hdr_ndp.rt_ch_frequency = cpu_to_le16(rxi->center_freq);
+		rt_hdr_ndp.rt_ch_flags =
+			cpu_to_le16(IEEE80211_CHAN_OFDM|NRC_CHAN_900MHZ);
+
+		rt_hdr_ndp.hdr.it_len = cpu_to_le64(sizeof(rt_hdr_ndp));
+		rt_hdr_ndp.hdr.it_present =
+			cpu_to_le32(BIT(IEEE80211_RADIOTAP_TSFT) |
+				BIT(IEEE80211_RADIOTAP_FLAGS) |
+				BIT(IEEE80211_RADIOTAP_CHANNEL) |
+				/* BIT(IEEE80211_RADIOTAP_0_LENGTH_PSDU)); */
+				BIT(26));
+		/* S1G NDP CMAC frame */
+		rt_hdr_ndp.rt_zero_length_psdu = 0x02;
+		rt_hdr_ndp.rt_pad = 0;
+	} else if (agg) {
+		rt_hdr_agg.hdr.it_version = PKTHDR_RADIOTAP_VERSION;
+		rt_hdr_agg.hdr.it_pad = 0;
+
+		rt_hdr_agg.rt_tsft = cpu_to_le64(rxi->timestamp);
+		 /* frame include FCS */
+		rt_hdr_agg.rt_flags = ((ndp_ind) ? 0x00:0x10);
+		rt_hdr_agg.rt_ch_frequency = cpu_to_le16(rxi->center_freq);
+		rt_hdr_agg.rt_ch_flags =
+			cpu_to_le16(IEEE80211_CHAN_OFDM|NRC_CHAN_900MHZ);
+
+		rt_hdr_agg.hdr.it_len = cpu_to_le64(sizeof(rt_hdr_agg));
+		rt_hdr_agg.hdr.it_present =
+			cpu_to_le32(BIT(IEEE80211_RADIOTAP_TSFT) |
+				BIT(IEEE80211_RADIOTAP_FLAGS) |
+				BIT(IEEE80211_RADIOTAP_CHANNEL) |
+				BIT(IEEE80211_RADIOTAP_AMPDU_STATUS) |
+				BIT(28)); //BIT(IEEE80211_RADIOTAP_TLV));
+		rt_hdr_agg.rt_ampdu_ref = 1;
+		rt_hdr_agg.rt_ampdu_flags = 2;
+		rt_hdr_agg.rt_ampdu_crc = 3;
+		rt_hdr_agg.rt_ampdu_reserved = 0;
+		rt_hdr_agg.rt_pad = 0;
+		rt_hdr_agg.rt_pad2 = 0;
+		rt_hdr_agg.rt_tlv_type   = cpu_to_le16(32); /* S1G */
+		rt_hdr_agg.rt_tlv_length = cpu_to_le16(6);
+		rt_hdr_agg.rt_s1g_known  = 0x007F;
+		rt_hdr_agg.rt_s1g_data1  =
+			((rxi->bandwidth == 0) ? 0x0 :
+			((rxi->preamble_type) ? 0x2 : 0x1)) |
+			((response_ind & 0x03) << 2) | /* RI */
+			((short_gi & 0x01) << 5) |	   /* GI */
+			0x0 << 6 |		/* NSS */
+			((rxi->bandwidth & 0x0f) << 8) | /* BW */
+			((mcs & 0x0f) << 12);		/* MCS */
+		rt_hdr_agg.rt_s1g_data2 = cpu_to_le16((color & 0x07) |
+			   ((uplink_ind & 0x01) << 3) |
+			   (rxi->rcpi << 8));
+	} else {
+		rt_hdr.hdr.it_version = PKTHDR_RADIOTAP_VERSION;
+		rt_hdr.hdr.it_pad = 0;
+
+		rt_hdr.rt_tsft = cpu_to_le64(rxi->timestamp);
+		 /* frame include FCS */
+		rt_hdr.rt_flags = ((ndp_ind) ? 0x00 : 0x10);
+		rt_hdr.rt_ch_frequency = cpu_to_le16(rxi->center_freq);
+		rt_hdr.rt_ch_flags =
+			cpu_to_le16(IEEE80211_CHAN_OFDM|NRC_CHAN_900MHZ);
+
+		rt_hdr.hdr.it_len = cpu_to_le64(sizeof(rt_hdr));
+		rt_hdr.hdr.it_present =
+			cpu_to_le32(BIT(IEEE80211_RADIOTAP_TSFT) |
+				BIT(IEEE80211_RADIOTAP_FLAGS) |
+				BIT(IEEE80211_RADIOTAP_CHANNEL) |
+				BIT(28)); //BIT(IEEE80211_RADIOTAP_TLV));
+		rt_hdr.rt_pad = 0;
+		rt_hdr.rt_pad2 = 0;
+		rt_hdr.rt_tlv_type		= cpu_to_le16(32); // S1G
+		rt_hdr.rt_tlv_length	= cpu_to_le16(6);
+		rt_hdr.rt_s1g_known		= 0x007F;
+		rt_hdr.rt_s1g_data1		=
+			((rxi->bandwidth == 0) ? 0x0 :
+				((rxi->preamble_type) ? 0x2 : 0x1)) |
+			((response_ind & 0x03) << 2) |	 /* RI */
+			((short_gi & 0x01) << 5) |		 /* GI */
+			0x0 << 6 |	/* NSS */
+			((rxi->bandwidth & 0x0f) << 8) | /* BW */
+			((mcs & 0x0f) << 12);			 /* MCS */
+		rt_hdr.rt_s1g_data2 =
+				 cpu_to_le16((color & 0x07) |
+				 ((uplink_ind & 0x01) << 3) |
+				 (rxi->rcpi << 8));
+	}
+
+	skb_pull(skb, nw->fwinfo.rx_head_size - sizeof(struct hif));
+
+	if (ndp_ind) {
+		prt_hdr_ndp =
+			(struct nrc_radiotap_hdr_ndp *)
+			skb_push(skb, sizeof(rt_hdr_ndp));
+		memcpy(prt_hdr_ndp, &rt_hdr_ndp, sizeof(rt_hdr_ndp));
+	} else if (agg) {
+		prt_hdr_agg =
+			(struct nrc_radiotap_hdr_agg *)
+			skb_push(skb, sizeof(rt_hdr_agg));
+		memcpy(prt_hdr_agg, &rt_hdr_agg, sizeof(rt_hdr_agg));
+
+		// add FCS
+	    memcpy((void *)skb_put(skb, 4), (void *)&fcs, 4);
+	} else {
+		prt_hdr =
+			(struct nrc_radiotap_hdr *)
+			skb_push(skb, sizeof(rt_hdr));
+		memcpy(prt_hdr, &rt_hdr, sizeof(rt_hdr));
+
+		// add FCS
+	    memcpy((void *)skb_put(skb, 4), (void *)&fcs, 4);
+	}
+
+	skb_set_mac_header(skb, 0);
+	skb->ip_summed = CHECKSUM_UNNECESSARY;
+	skb->pkt_type = PACKET_OTHERHOST;
+	skb->protocol = htons(ETH_P_802_2);
+	memset(skb->cb, 0, sizeof(skb->cb));
+}
+
+static void s1g_monitor_rx(void *data, struct net_device *dev)
+{
+	struct sk_buff *skb, *origskb = data;
+	struct wireless_dev *wdev = dev->ieee80211_ptr;
+
+	if (wdev->iftype != NL80211_IFTYPE_MONITOR)
+		return;
+
+	skb = skb_clone(origskb, GFP_ATOMIC);
+	if (!skb)
+		return;
+
+	skb->dev = dev;
+	netif_rx(skb);
+}
+
+
+static int nrc_mac_s1g_monitor_rx(struct nrc *nw, struct sk_buff *skb)
+{
+	struct ieee80211_hw *hw = nw->hw;
+
+#if defined(NRC7291)
+	struct RxInfo *rx;
+
+	rx = RXINFO(skb->data() + RXVECTOR_SIG_SIZE);
+
+	if (rx->error_crc && !rx->ndp_ind) {
+		nrc_mac_dbg("discard this frame because of error_crc");
+		dev_kfree_skb(skb);
+		return 0;
+	}
+#endif
+
+	if (nrc_mac_is_s1g(nw)) {
+		nrc_add_rx_s1g_radiotap_header(nw, skb);
+		ieee80211_iterate_active_netdev(hw, s1g_monitor_rx, skb);
+	}
+
+	dev_kfree_skb(skb);
+
+	return 0;
+}
diff --git a/drivers/staging/nrc/nrc-vendor.h b/drivers/staging/nrc/nrc-vendor.h
new file mode 100644
index 000000000000..2dbec7aa03d9
--- /dev/null
+++ b/drivers/staging/nrc/nrc-vendor.h
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _NRC_VENDOR_H_
+#define _NRC_VENDOR_H_
+
+#define OUI_IEEE_REGISTRATION_AUTHORITY		0xFCFFAA
+
+/**
+ * A subcmd to remove the vendor specific IE which was injected before.
+ * ex>$sudo iw dev wlan0 vendor send 0xfcffaa 0xde 0x2
+ *   => this cmd will remove the injected vendor specific IE
+ *      of which the subcmd was 0x2.
+ */
+#define NRC_SUBCMD_RM_VENDOR_IE				0xDE
+
+/*
+ * GPIO pin number on Raspberry Pi.
+ * This is used to wake up the target in deep-sleep.
+ * [direction]: OUTPUT
+ */
+#define RPI_GPIO_FOR_PS						(20)
+
+/*
+ * GPIO pin number on the target device.
+ * This is used to designate the GPIO pin on target
+ * which will read signal from RPI_GPIO_FOR_RS for waking up target.
+ * [direction]: INPUT
+ */
+#define TARGET_GPIO_FOR_WAKEUP				(11)
+
+/*
+ * GPIO pin number on the target device.
+ * This is used to designate the GPIO pin on target
+ * which will raise signal to wake up host system.
+ * [direction]: OUTPUT
+ */
+#define TARGET_GPIO_FOR_WAKEUP_HOST			(10)
+
+#define RPI_GPIO_FOR_RST					(4)
+
+enum nrc_vendor_event {
+	NRC_SUBCMD_ANNOUNCE1 = 0,
+	NRC_SUBCMD_ANNOUNCE2,
+	NRC_SUBCMD_ANNOUNCE3,
+	NRC_SUBCMD_ANNOUNCE4,
+	NRC_SUBCMD_ANNOUNCE5,
+	NRC_SUBCMD_WOWLAN_PATTERN,
+	NUM_VENDOR_EVENT,
+	MAX_VENDOR_EVENT = NUM_VENDOR_EVENT - 1
+};
+
+enum nrc_vendor_attributes {
+	NRC_VENDOR_ATTR_DATA = 0,
+	NUM_VENDOR_ATTR,
+	MAX_VENDOR_ATTR = NUM_VENDOR_ATTR - 1
+};
+
+#endif /* _NRC_VENDOR_H_ */
diff --git a/drivers/staging/nrc/nrc-wim-types.h b/drivers/staging/nrc/nrc-wim-types.h
new file mode 100644
index 000000000000..55d858efbf97
--- /dev/null
+++ b/drivers/staging/nrc/nrc-wim-types.h
@@ -0,0 +1,872 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _NRC_WIM_TYPES_H_
+#define _NRC_WIM_TYPES_H_
+
+#ifndef BIT
+#define BIT(x) (1 << (x))
+#endif
+
+#ifndef ETH_ALEN
+#define ETH_ALEN 6
+#endif
+
+#ifndef NR_NRC_VIF
+#define NR_NRC_VIF 2
+#endif
+
+#define MAX_FRAME_PKT_TLV_SIZE      (256)
+#define MAX_WIM_PKT_TLV_SIZE        (1500)
+#define WIM_HEAD_SIZE               (sizeof(struct hif_hdr) \
+					+ sizeof(struct wim_hdr))
+#define WIM_MAX_DATA_SIZE           (512)
+#define WIM_MAX_TLV_SIZE            (1024)
+#define WIM_MAX_SIZE                (WIM_HEAD_SIZE \
+					+ WIM_MAX_DATA_SIZE + WIM_MAX_TLV_SIZE)
+#define WIM_MAX_TLV_SCAN_IE         (512)
+
+#ifndef __packed
+#define  __packed __attribute__((__packed__))
+#endif
+
+enum HIF_TYPE {
+	HIF_TYPE_FRAME  = 0,
+	HIF_TYPE_WIM,
+	HIF_TYPE_NANOPB,
+	HIF_TYPE_UART_CMD,
+	HIF_TYPE_SSP_READYRX,
+	HIF_TYPE_SSP_PING,
+	HIF_TYPE_SSP_PONG,
+	HIF_TYPE_SSP_SKIP,
+	HIF_TYPE_LOG,
+	HIF_TYPE_LOOPBACK,
+	HIF_TYPE_DUMP,
+	HIF_TYPE_MAX
+};
+
+enum HIF_SUBTYPE {
+	HIF_FRAME_SUB_DATA_BE = 0,
+	HIF_FRAME_SUB_DATA_BK,
+	HIF_FRAME_SUB_DATA_VO,
+	HIF_FRAME_SUB_DATA_VI,
+	HIF_FRAME_SUB_MGMT,
+	HIF_FRAME_SUB_BEACON,
+	HIF_FRAME_SUB_PROBE_RESP,
+	HIF_FRAME_SUB_802_3,
+	HIF_FRAME_SUB_CTRL,
+	HIF_FRAME_SUB_RESPONSE = 31,
+	HIF_WIM_SUB_REQUEST = 0,
+	HIF_WIM_SUB_RESPONSE,
+	HIF_WIM_SUB_EVENT,
+	HIF_WIM_SUB_MAX,
+	HIF_NANOPB_SUB_REQUEST = 0,
+	HIF_NANOPB_SUB_RESPONSE,
+	HIF_NANOPB_SUB_EVENT,
+	HIF_NANOPB_SUB_EAPOL,
+	HIF_NANOPB_SUB_L2PACKET,
+	HIF_NANOPB_SUB_ACTION,
+	HIF_NANOPB_SUB_DATA,
+	HIF_NANOPB_SUB_MAX,
+	HIF_LOG_SUB_VB		= 0,	/*TL_VB*/
+	HIF_LOG_SUB_INFO	= 1,	/*TL_INFO*/
+	HIF_LOG_SUB_ERROR	= 2,	/*TL_ERR*/
+	HIF_LOG_SUB_ASSERT	= 3,	/*TL_ASSERT*/
+	HIF_LOG_SUB_NONE	= 4,	/*TL_NONE*/
+	HIF_LOG_SUB_MAX				/*TL_MAX*/
+
+};
+
+enum WIM_CMD_GRP {
+	WIM_CMD_GRP_SYSTEM,
+	WIM_CMD_GRP_MGMT,
+	WIM_CMD_GRP_SCAN,
+	WIM_CMD_GRP_PS,
+	WIM_CMD_GRP_P2P,
+	WIM_CMD_GRP_S1G,
+	WIM_CMD_GRP_SEC,
+	WIM_CMD_GRP_STA,
+	WIM_CMD_GRP_MAX = 8
+};
+
+enum WIM_CMD_ID {
+	WIM_CMD_INIT,
+	WIM_CMD_START,
+	WIM_CMD_STOP,
+	WIM_CMD_SCAN_START,
+	WIM_CMD_SCAN_STOP,
+	WIM_CMD_SET_KEY,
+	WIM_CMD_DISABLE_KEY,
+	WIM_CMD_STA_CMD,
+	WIM_CMD_SET,
+	/* DON'T ADD A NEW CMD BEFORE WIM_CMD_REQ_FW !! */
+	WIM_CMD_REQ_FW,
+	WIM_CMD_FW_RELOAD,
+	WIM_CMD_AMPDU_ACTION,
+	WIM_CMD_SHELL,
+	WIM_CMD_SLEEP,
+	WIM_CMD_MIC_SCAN,
+	WIM_CMD_KEEP_ALIVE,
+	WIM_CMD_SET_IE,
+	WIM_CMD_SET_SAE,
+	WIM_CMD_PM,
+	WIM_CMD_SHELL_RAW,
+	WIM_CMD_MAX,
+};
+
+enum WIM_EVENT_ID {
+	WIM_EVENT_SCAN_COMPLETED,
+	WIM_EVENT_READY,
+	WIM_EVENT_CREDIT_REPORT,
+	WIM_EVENT_PS_READY,
+	WIM_EVENT_PS_WAKEUP,
+	WIM_EVENT_KEEP_ALIVE,
+	WIM_EVENT_REQ_DEAUTH,
+	WIM_EVENT_CSA,
+	WIM_EVENT_CH_SWITCH,
+	WIM_EVENT_LBT_ENABLED,
+	WIM_EVENT_LBT_DISABLED,
+	WIM_EVENT_MAX,
+};
+
+enum WIM_TLV_ID {
+	WIM_TLV_SSID = 0,
+	WIM_TLV_BSSID = 1,
+	WIM_TLV_MACADDR = 2,
+	WIM_TLV_AID = 3,
+	WIM_TLV_STA_TYPE = 4,
+	WIM_TLV_SCAN_PARAM = 5,
+	WIM_TLV_KEY_PARAM = 6,
+	WIM_TLV_STA_PARAM = 7,
+	WIM_TLV_CHANNEL = 8,
+	WIM_TLV_HT_MODE = 9,
+	WIM_TLV_BCN_INTV = 10,
+	WIM_TLV_SCAN_BAND_IE = 11,
+	WIM_TLV_SCAN_PROBE_REQ_IE = 12,
+	WIM_TLV_SCAN_COMMON_IE = 13,
+	WIM_TLV_BEACON = 14,
+	WIM_TLV_BEACON_ENABLE = 15,
+	WIM_TLV_PROBE_RESP = 16,
+	WIM_TLV_FIRMWARE = 17,
+	WIM_TLV_PS_ENABLE = 18,
+	WIM_TLV_READY = 19,
+	WIM_TLV_TXQ_PARAM = 20,
+	WIM_TLV_AC_CREDIT_REPORT = 21,
+	WIM_TLV_MCS = 22,
+	WIM_TLV_CHANNEL_WIDTH = 23,
+	WIM_TLV_BASIC_RATE = 24,
+	WIM_TLV_CH_BW_MCS = 25,
+	WIM_TLV_CH_BW = 26,
+	WIM_TLV_MCS_NSS = 27,
+	WIM_TLV_BD = 28,
+	WIM_TLV_TID,
+	WIM_TLV_AMPDU_MODE, //30
+	WIM_TLV_EXTRA_TX_INFO,
+	WIM_TLV_SHORT_BCN_INTV,
+	/* CB4861 */
+	WIM_TLV_CAP,
+	WIM_TLV_SUPPORTED_RATES,
+	WIM_TLV_HT_CAP,
+	WIM_TLV_PHY_MODE,
+	WIM_TLV_ERP_PARAM,
+	WIM_TLV_TIM_PARAM,
+	WIM_TLV_SHELL_CMD,
+	WIM_TLV_SHELL_RESP, //40
+	WIM_TLV_MACADDR_PARAM,
+	WIM_TLV_DTIM_PERIOD,
+	WIM_TLV_P2P_OPPPS,
+	WIM_TLV_P2P_NOA,
+	WIM_TLV_SGI,
+	WIM_TLV_S1G_STA_TYPE,
+	WIM_TLV_AMPDU_SUPPORT,
+	WIM_TLV_AMSDU_SUPPORT,
+	WIM_TLV_S1G_PV1,
+	WIM_TLV_COUNTRY_CODE, //50
+	WIM_TLV_CH_TABLE,
+	WIM_TLV_1MHZ_CTRL_RSP,
+	WIM_TLV_COLOR_IND,
+	WIM_TLV_S1G_TIM_MODE,
+	WIM_TLV_AP_ONLY,
+	WIM_TLV_SLEEP_DURATION,
+	WIM_TLV_CCA_1M,
+	WIM_TLV_S1G_CHANNEL,
+	WIM_TLV_RTS_THREASHOLD,
+	WIM_TLV_FRAME_INJECTION, //60
+	WIM_TLV_IE_PARAM,
+	WIM_TLV_NDP_PREQ,
+	WIM_TLV_SAE_PARAM,
+	WIM_TLV_DRV_INFO,
+	WIM_TLV_NDP_ACK_1M, //65
+	WIM_TLV_SET_TXPOWER,
+	WIM_TLV_LEGACY_ACK,
+	WIM_TLV_MAX,
+};
+
+enum WIM_STA_TYPE {
+	WIM_STA_TYPE_NONE = 0,
+	WIM_STA_TYPE_STA,
+	WIM_STA_TYPE_AP,
+	WIM_STA_TYPE_P2P_GO,
+	WIM_STA_TYPE_P2P_GC,
+	WIM_STA_TYPE_P2P_DEVICE,
+	WIM_STA_TYPE_MONITOR,
+	WIM_STA_TYPE_MESH_POINT
+};
+
+enum WIM_S1G_STA_TYPE {
+	WIM_S1G_STA_TYPE_BOTH,
+	WIM_S1G_STA_TYPE_SENSOR,
+	WIM_S1G_STA_TYPE_NON_SENSOR,
+};
+
+enum WIM_AMPDU_ACTION {
+	WIM_AMPDU_TX_START = 0,
+	WIM_AMPDU_TX_STOP,
+	WIM_AMPDU_RX_START,
+	WIM_AMPDU_RX_STOP,
+	WIM_AMPDU_TX_OPERATIONAL,
+};
+
+enum WIM_S1G_TIM_MODE {
+	WIM_TIM_OLB = 0,
+	WIM_TIM_SINGLE_AID,
+	WIM_TIM_BLOCK_BMP
+};
+
+struct wim_cmd_map {
+	uint16_t grp;
+	uint16_t len;
+};
+
+struct wim_tlv_map {
+	uint16_t type;
+	uint16_t len;
+};
+
+struct hif_hdr {
+	uint8_t type;
+	uint8_t subtype;
+	uint8_t flags;
+	int8_t vifindex;
+	uint16_t len;
+	uint16_t tlv_len;
+} __packed;
+
+struct hif_lb_hdr {
+	uint8_t type;
+	uint8_t subtype;
+	uint16_t count;
+	uint16_t len;
+	uint16_t index;
+} __packed;
+
+#define NRC_FRAME_CIPHER_NONE (0)
+#define NRC_FRAME_CIPHER_CCMP (1)
+
+struct frame_hdr {
+	union {
+		struct rx_flags {
+			uint8_t error_mic:1;
+			uint8_t iv_stripped:1;
+			uint8_t snr:6;
+			int8_t rssi;
+		} rx;
+		struct tx_flags {
+			uint8_t ac;
+			uint8_t reserved;
+		} tx;
+	} flags;
+	union {
+		struct rx_info {
+			uint16_t frequency;
+		} rx;
+
+		struct tx_info {
+			uint8_t cipher;
+			uint8_t tlv_len;
+		} tx;
+	} info;
+} __packed;
+
+enum {
+	WIM_BW_1M = 0,
+	WIM_BW_2M,
+	WIM_BW_4M,
+	WIM_BW_MAX,
+
+	WIM_BW_8M = 3,
+	WIM_BW_16M,
+};
+
+enum {
+	WIM_S1G = 0,
+	WIM_S1G_DUP_1M,
+	WIM_S1G_DUP_2M
+};
+
+struct sigS1g {
+	union {
+		struct s1g1M {
+			/* sig bit pattern LSB -> MSB */
+			uint32_t nsts			: 2;
+			/* 0=1 space time stream, 1=2 space time stream, etc. */
+			uint32_t short_gi		: 1;
+			/* 0 for no use of short guard interval, otherwise 1 */
+			uint32_t coding			: 2;
+			/* x0=BCC, x1=LDPC */
+			uint32_t stbc			: 1;
+			/* 0=no spatial streams has STBC,
+			 * 1=all spatial streams has STBC
+			 */
+			uint32_t reserved2		: 1;
+			uint32_t mcs			: 4;
+			uint32_t aggregation	: 1;
+			/* 1 for aggregation */
+			uint32_t length			: 9;
+			/* PPDU length in symbols in case of aggregation */
+			/* otherwise, byte length */
+			uint32_t response_ind	: 2;
+			/* 0=no rsp, 1=NDP rsp, 2=normal rsp, 3=long rsp */
+			uint32_t smoothing		: 1;
+			/* 1 for recommending channel smoothing */
+			uint32_t doppler		: 1;
+			/* 0=regular pilot tone, 1=traveling pilots */
+			uint32_t ndp_ind		: 1;
+			/* 1 for NDP */
+			uint32_t crc			: 4;
+			/* for TX use (CRC calulation for S1G SIGA fields) */
+			uint32_t reserved1		: 2;
+
+			uint32_t magic_code_3	: 8;
+			uint32_t magic_code_2	: 8;
+			uint32_t magic_code_1	: 8;
+			uint32_t magic_code_0	: 8;
+		} s1g1M;
+		struct s1gShort {
+			/* sig bit pattern LSB -> MSB */
+			uint32_t reserved2		: 1;
+			uint32_t stbc			: 1;
+			uint32_t uplink_ind		: 1;
+			/* set to the value of TXVECTOR
+			 * parameter UPLINK_INDICATION
+			 */
+			uint32_t bandwidth		: 2;
+			/* 0:2M, 1:4M, 2:8M, 3:16M */
+			uint32_t nsts			: 2;
+			uint32_t id				: 9;
+			uint32_t short_gi		: 1;
+			uint32_t coding			: 2;
+			uint32_t mcs			: 4;
+			uint32_t smoothing		: 1;
+			uint32_t reserved1		: 8;
+			uint32_t aggregation	: 1;
+			uint32_t length			: 9;
+			uint32_t response_ind	: 2;
+			uint32_t doppler		: 1;
+			uint32_t ndp_ind		: 1;
+			uint32_t crc			: 4;
+			/* for TX use */
+			uint32_t reserved3		: 14;
+		} s1gShort;
+		struct s1gLong {
+			/* sig bit pattern LSB -> MSB */
+			uint32_t mu_su			: 1;
+			uint32_t stbc			: 1;
+			uint32_t uplink_ind		: 1;
+			uint32_t bandwidth		: 2;
+			/* 0:2M, 1:4M, 2:8M, 3:16M */
+			uint32_t nsts			: 2;
+			uint32_t id				: 9;
+			uint32_t short_gi		: 1;
+			uint32_t coding			: 2;
+			uint32_t mcs			: 4;
+			uint32_t smoothing		: 1;
+			uint32_t reserved1		: 8;
+			uint32_t aggregation	: 1;
+			uint32_t length			: 9;
+			uint32_t response_ind	: 2;
+			uint32_t reserved3		: 1;
+			uint32_t doppler		: 1;
+			uint32_t crc			: 4;
+			/* for TX use */
+			uint32_t reserved2		: 14;
+		} s1gLong;
+	} flags;
+} __packed;
+
+struct rxInfo {
+	uint32_t mpdu_length			: 14;
+	uint32_t center_freq				: 18;
+	uint32_t format					: 2;
+	uint32_t preamble_type			: 1;
+	uint32_t bandwidth				: 2;
+	uint32_t scrambler_or_crc		: 7;
+	uint32_t rcpi					: 8;
+	uint32_t obss_frame				: 1;
+	uint32_t ndp_ind				: 1;
+	uint32_t long_2m_ind			: 1;
+	uint32_t aggregation			: 1;
+	uint32_t error_mic				: 1;
+	uint32_t error_key				: 1;
+	uint32_t protection				: 1;
+	uint32_t error_length			: 1;
+	uint32_t error_match			: 1;
+	uint32_t error_crc				: 1;
+	uint32_t okay					: 1;
+	uint32_t valid					: 1;
+	uint32_t timestamp				: 32;
+	uint32_t fcs					: 32;
+} __packed;
+
+struct wim_hdr {
+	union {
+		uint16_t cmd;
+		uint16_t resp;
+		uint16_t event;
+	};
+	uint8_t seq_no;
+	uint8_t n_tlvs;
+} __packed;
+
+#define NRC_TLV_HDR_LEN (4)
+struct nrc_tlv_hdr {
+	uint16_t type;
+	uint16_t len;
+};
+
+struct nrc_tlv_item {
+	uint16_t type;
+	uint16_t len;
+	uint8_t value[0];
+};
+
+struct nrc_tlv {
+	struct nrc_tlv_hdr tlv_hdr;
+	union {
+		struct wim_scan_param *scan_param;
+		struct wim_channel_1m_param *chan_1m_param;
+		struct wim_tx_queue_param *queue_param;
+		struct wim_key_param *key_param;
+		struct wim_channel_param *channel_param;
+		struct wim_sta_param *sta_param;
+		struct wim_ready_param *ready_param;
+		struct wim_credit_report_param *credit_report_param;
+		struct wim_channel_width_param *channel_width_param;
+		struct wim_basic_rate_param *basic_rate_param;
+		struct wim_ch_bw_mcs_param *ch_bw_mcs_param;
+		struct wim_ch_bw_param *ch_bw_param;
+		struct wim_mcs_nss_param *mcs_nss_param;
+		struct frame_tx_info_param *tx_info_param;
+		struct wim_tim_param *tim_param;
+		struct wim_sleep_duration_param *sleep_duration_param;
+		struct wim_pm_param *pm_param;
+		struct wim_s1g_channel_param *s1g_chan_param;
+		struct wim_bd_param *bd_param;
+		uint8_t *bytes_param;
+		bool *bool_param;
+		uint32_t *u32_param;
+		uint16_t *u16_param;
+		uint8_t *u8_param;
+		void *pvoid;
+		uint8_t param[0];
+	};
+} __packed;
+
+enum WIM_SCAN_FLAG {
+	WIM_SCAN_FLAG_NOCCK = BIT(1),
+};
+
+enum WIM_AID_ADDR_FLAG {
+	AID_ADDR_FLAG_HAS_MACADDR = BIT(0),
+	AID_ADDR_FLAG_HAS_AID     = BIT(1),
+};
+
+enum WIM_CHANNEL_PARAM_TYPE {
+	CHAN_NO_HT,
+	CHAN_HT20,
+	CHAN_HT40MINUS,
+	CHAN_HT40PLUS
+};
+
+enum WIM_CHANNEL_PARAM_WIDTH {
+	CH_WIDTH_20_NOHT,
+	CH_WIDTH_20,
+	CH_WIDTH_40,
+	CH_WIDTH_80,
+	CH_WIDTH_80P80,
+	CH_WIDTH_160,
+	CH_WIDTH_5,
+	CH_WIDTH_10,
+	CH_WIDTH_1,
+	CH_WIDTH_2,
+	CH_WIDTH_4,
+	CH_WIDTH_8,
+	CH_WIDTH_16,
+};
+
+struct wim_channel_param {
+	uint16_t channel;
+	uint8_t type;
+	uint8_t width;
+} __packed;
+
+
+#define WIM_MAX_BD_DATA_LEN		(540)
+struct wim_bd_param {
+	uint16_t type;
+	uint16_t length;
+	uint16_t checksum;
+	uint16_t hw_version;
+	uint8_t value[WIM_MAX_BD_DATA_LEN];
+} __packed;
+
+#define WIM_MAX_SCAN_SSID       (2)
+#define WIM_MAX_SCAN_BSSID      (2)
+#define WIM_MAX_SCAN_CHANNEL    (55)
+#ifndef IEEE80211_MAX_SSID_LEN
+#define IEEE80211_MAX_SSID_LEN  (32)
+#endif
+
+struct wim_scan_ssid {
+	uint8_t ssid[IEEE80211_MAX_SSID_LEN];
+	uint8_t ssid_len;
+}  __packed;
+
+struct wim_scan_bssid {
+	uint8_t bssid[6];
+} __packed;
+
+#define WIM_DECLARE(x) \
+	struct x {\
+		struct nrc_tlv_hdr h;\
+		struct x##_param v;\
+	} __packed
+
+#define WIM_SYSTEM_VER_11N      (1)
+#define WIM_SYSTEM_VER_11AH_1ST (2)
+#define WIM_SYSTEM_VER_11AH_2ND (3)
+#define WIM_SYSTEM_VER_11AH_3RD (4)
+
+enum wim_system_cap {
+	WIM_SYSTEM_CAP_USF = BIT(0),
+	WIM_SYSTEM_CAP_HWSEC = BIT(1),
+	WIM_SYSTEM_CAP_HWSEC_OFFL = BIT(2),
+	WIM_SYSTEM_CAP_CHANNEL_2G = BIT(3),
+	WIM_SYSTEM_CAP_CHANNEL_5G = BIT(4),
+	WIM_SYSTEM_CAP_MULTI_VIF = BIT(5),
+};
+
+struct wim_vif_cap_param {
+	uint64_t cap;
+} __packed;
+
+struct wim_cap_param {
+	uint64_t cap;
+	uint16_t listen_interval;
+	uint16_t bss_max_idle;
+	uint16_t max_vif;
+	struct wim_vif_cap_param vif_caps[];
+} __packed;
+
+struct wim_ready_param {
+	uint32_t version;
+	uint32_t tx_head_size;
+	uint32_t rx_head_size;
+	uint32_t payload_align;
+	uint32_t buffer_size;
+	uint8_t macaddr[NR_NRC_VIF][ETH_ALEN];
+	bool has_macaddr[NR_NRC_VIF];
+	uint16_t hw_version;
+	struct wim_cap_param cap;
+} __packed;
+WIM_DECLARE(wim_ready);
+
+struct wim_credit_report_param {
+	uint8_t change_index;
+	uint8_t reserved0;
+	uint8_t reserved1;
+	uint8_t reserved2;
+	uint8_t ac[12];
+} __packed;
+WIM_DECLARE(wim_credit_report);
+
+struct wim_channel_width_param {
+	uint8_t chan_width;
+	uint8_t prim_loc;
+	uint8_t reserved[2];
+} __packed;
+WIM_DECLARE(wim_channel_width);
+
+struct wim_basic_rate_param {
+	uint32_t rate;
+} __packed;
+WIM_DECLARE(wim_basic_rate);
+
+struct wim_ch_bw_mcs_param {
+	uint8_t prim_ch_num;
+	uint8_t second_ch_offset;
+	uint8_t sta_channel_width;
+	uint8_t reserved;
+	uint32_t mcs[4];
+} __packed;
+WIM_DECLARE(wim_ch_bw_mcs);
+
+struct wim_ch_bw_param {
+	uint8_t prim_ch_width;
+	uint8_t oper_ch_width;
+	uint8_t loc_1m_prim_ch;
+	uint8_t prim_ch_num;
+	uint8_t center_freq;
+	uint8_t mcs_10_permit;
+	uint8_t mcs_min;
+	uint8_t mcs_max;
+	uint8_t nss;
+	uint8_t reserved[3];
+} __packed;
+WIM_DECLARE(wim_ch_bw);
+
+struct wim_mcs_nss_param {
+	uint8_t mcs_min;
+	uint8_t mcs_max;
+	uint8_t nss;
+	uint8_t reserved;
+} __packed;
+WIM_DECLARE(wim_mcs_nss);
+
+struct frame_tx_info_param {
+	uint16_t aid;
+	uint8_t use_rts:1;
+	uint8_t use_11b_protection:1;
+	uint8_t short_preamble:1;
+	uint8_t ampdu:1;
+	uint8_t after_dtim:1;
+	uint8_t no_ack:1;
+	uint8_t eosp:1;
+	uint8_t inject:1;
+	uint16_t reserved0:8;
+	uint32_t reserved1;
+} __packed;
+WIM_DECLARE(frame_tx_info);
+
+struct wim_sleep_duration_param {
+	uint32_t sleep_ms;
+} __packed;
+WIM_DECLARE(wim_sleep_duration);
+
+/**
+ * struct wowlan_pattern - packet pattern
+ * @offset: packet offset (in bytes)
+ * @mask_len: length of mask (in bytes)
+ * @pattern_len: length of pattern (in bytes)
+ * @mask: bitmask where to match pattern and where to ignore bytes,
+ *  one bit per byte, in same format as nl80211
+ * @pattern: bytes to match where bitmask is 1
+ */
+struct wowlan_pattern {
+	uint16_t offset:6;
+	uint16_t mask_len:4;
+	uint16_t pattern_len:6;
+	uint8_t mask[7];
+	uint8_t pattern[56];
+} __packed;
+
+struct wim_pm_param {
+	uint8_t ps_mode;
+	uint8_t ps_enable;
+	uint16_t ps_wakeup_pin;
+	uint64_t ps_duration;
+	uint8_t wowlan_wakeup_host_pin;
+	uint8_t wowlan_enable_any;
+	uint8_t wowlan_enable_magicpacket;
+	uint8_t wowlan_enable_disconnect;
+	uint8_t wowlan_n_patterns;
+	struct wowlan_pattern wp[2];
+} __packed;
+WIM_DECLARE(wim_pm);
+
+struct wim_drv_info_param {
+	uint32_t boot_mode			:1;
+	uint32_t cqm_off			:1;
+	uint32_t bitmap_encoding	:1;
+	uint32_t reverse_scrambler	:1;
+	uint32_t reserved			:28;
+} __packed;
+WIM_DECLARE(wim_drv_info);
+
+#define WIM_SCAN_PARAM_FLAG_NO_CCK      (BIT(0))
+#define WIM_SCAN_PARAM_FLAG_HT			(BIT(1))
+#define WIM_SCAN_PARAM_FLAG_WMM			(BIT(2))
+#define WIM_SCAN_PARAM_FLAG_DS			(BIT(3))
+
+struct wim_channel_1m_param {
+	int channel_start;
+	int channel_end;
+	uint32_t cca_bitmap;
+} __packed;
+WIM_DECLARE(wim_channel_1m);
+
+struct wim_scan_channel {
+	uint16_t freq;
+	struct wim_channel_width_param width;
+};
+
+struct wim_scan_param {
+	uint8_t mac_addr[6];
+	uint8_t mac_addr_mask[6];
+	uint32_t rate;
+	uint32_t scan_flag;
+	uint8_t n_ssids;
+	uint8_t n_bssids;
+	uint8_t n_channels;
+	struct wim_scan_ssid    ssid[WIM_MAX_SCAN_SSID];
+	struct wim_scan_bssid   bssid[WIM_MAX_SCAN_BSSID];
+	uint16_t                channel[WIM_MAX_SCAN_CHANNEL];
+	struct wim_scan_channel s1g_channel[WIM_MAX_SCAN_CHANNEL];
+} __packed;
+
+enum wim_cipher_type {
+	WIM_CIPHER_TYPE_INVALID = -1,
+	WIM_CIPHER_TYPE_WEP40 = 0,
+	WIM_CIPHER_TYPE_WEP104 = 1,
+	WIM_CIPHER_TYPE_TKIP = 2,
+	WIM_CIPHER_TYPE_CCMP = 3,
+	WIM_CIPHER_TYPE_CCMP_256 = 3,
+	WIM_CIPHER_TYPE_WAPI = 4,
+	WIM_CIPHER_TYPE_NONE = 5,
+	WIM_CIPHER_TYPE_BIP = 6,
+};
+
+#define WIM_KEY_MAX_LEN         (32)
+#define WIM_KEY_MAX_INDEX       (4)
+
+#define WIM_KEY_FLAG_PAIRWISE   BIT(0)
+#define WIM_KEY_FLAG_GROUP      BIT(1)
+#define WIM_KEY_FLAG_IGROUP     BIT(2)
+
+struct wim_key_param {
+	uint8_t cipher_type;
+	uint8_t key_index;
+	uint8_t mac_addr[6];
+	uint16_t aid;
+	uint32_t key_flags;
+	uint32_t key_len;
+	uint8_t key[WIM_KEY_MAX_LEN];
+};
+
+enum wim_sta_cmd {
+	WIM_STA_CMD_ADD    = 0,
+	WIM_STA_CMD_REMOVE,
+	WIM_STA_CMD_NOTIFY,
+	WIM_STA_CMD_STATE_NOTEXIST,
+	WIM_STA_CMD_STATE_NONE,
+	WIM_STA_CMD_STATE_AUTH,
+	WIM_STA_CMD_STATE_ASSOC,
+	WIM_STA_CMD_STATE_AUTHORIZED,
+};
+
+struct wim_sta_param {
+	uint8_t cmd;
+	uint8_t addr[6];
+	uint8_t sleep; /*0: awake, 1: sleep*/
+	uint16_t aid;
+	uint32_t flags;
+};
+
+#define INFO_ELEMENT_MAX_LENGTH	255
+struct wim_set_ie_param {
+	uint16_t eid;
+	uint8_t length;
+	uint8_t data[INFO_ELEMENT_MAX_LENGTH];
+};
+
+#define SET_SAE_MAX_LENGTH 515
+struct wim_set_sae_param {
+	uint16_t eid;
+	uint16_t length;
+	uint8_t data[SET_SAE_MAX_LENGTH];
+};
+
+struct wim_tx_queue_param {
+	uint8_t ac;
+	uint16_t txop;
+	uint16_t cw_min;
+	uint16_t cw_max;
+	uint8_t aifsn; /* aifs or aifsn? */
+	uint8_t acm;
+	uint8_t uapsd;
+	uint8_t sta_type; /* 0: both, 1: sensor, 2: non-sensor */
+	uint8_t rvd;
+} __packed;
+
+struct wim_tim_param {
+	uint16_t aid;
+	bool set;
+};
+
+struct wim_erp_param {
+	uint8_t use_11b_protection;
+	uint8_t use_short_preamble;
+	uint8_t use_short_slot;
+} __packed;
+WIM_DECLARE(wim_erp);
+
+#define FRAME_PKT_N_TLV_MAX    (1)
+struct frame_pkt {
+	struct hif_hdr   _hif_hdr;
+	struct frame_hdr _frame_hdr;
+	uint8_t *frame;
+};
+
+#define WIM_PKT_N_TLV_MAX    (10)
+struct wim_pkt {
+	struct hif_hdr _hif_hdr;
+	struct wim_hdr _wim_hdr;
+	struct nrc_tlv tlvs[WIM_PKT_N_TLV_MAX];
+};
+
+struct wim_addr_param {
+	bool enable; /*0: awake, 1: sleep*/
+	bool p2p;	/*0: non-p2p, 1: p2p*/
+	uint8_t addr[6];
+};
+
+struct wim_noa_param {
+	uint8_t index;
+	uint8_t count;          /*how many absence period be scheduled*/
+	uint32_t start_time;    /*Start Time of first absence period*/
+	uint32_t interval;      /*time between consecutive absence periods*/
+	uint32_t duration;      /*length of each absence period*/
+};
+
+enum WIM_S1G_CHANNEL_FLAGS {
+	/* Recommended not to use MCS10 */
+	WIM_S1G_CHANNEL_FLAG_MCS10_NOT_RECOMMENDED = BIT(2),
+};
+
+struct wim_s1g_channel_param {
+	uint16_t pr_freq;
+	uint16_t op_freq;
+	uint16_t width;
+	uint16_t flags;
+};
+
+enum WIM_TXPWR_TYPE {
+	TXPWR_AUTO = 0,
+	TXPWR_LIMIT,
+	TXPWR_FIXED,
+};
+
+#endif /* _NRC_WIM_TYPES_H_ */
diff --git a/drivers/staging/nrc/nrc.h b/drivers/staging/nrc/nrc.h
new file mode 100755
index 000000000000..56091312be4e
--- /dev/null
+++ b/drivers/staging/nrc/nrc.h
@@ -0,0 +1,501 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _NRC_H_
+#define _NRC_H_
+
+#include "nrc-build-config.h"
+#include <linux/etherdevice.h>
+#include <linux/rtnetlink.h>
+#include <linux/firmware.h>
+#include <linux/sched.h>
+#include <linux/circ_buf.h>
+#include <linux/completion.h>
+#include <net/cfg80211.h>
+#include <net/mac80211.h>
+#include <net/ieee80211_radiotap.h>
+
+
+#define DEFAULT_INTERFACE_NAME			"nrc"
+struct nrc_hif_device;
+#define WIM_SKB_MAX         (10)
+#define WIM_RESP_TIMEOUT    (msecs_to_jiffies(100))
+#define NR_NRC_VIF			(2)
+#define NR_NRC_VIF_HW_QUEUE	(4)
+#define NR_NRC_MAX_TXQ		(130)
+#ifdef CONFIG_CHECK_DATA_SIZE
+#define NR_NRC_MAX_TXQ_SIZE	(1500*100) /* 150K */
+#endif
+/* VIF0 AC0~3,BCN, GP, VIF1 AC0~3,BCN */
+#define NRC_QUEUE_MAX					(NR_NRC_VIF_HW_QUEUE*NR_NRC_VIF + 3)
+
+#ifdef CONFIG_SUPPORT_AFTER_KERNEL_3_0_36
+#else
+#define IEEE80211_NUM_ACS				(4)
+#define IEEE80211_P2P_NOA_DESC_MAX		(4)
+#endif
+#define NRC_MAX_TID						(8)
+
+enum NRC_SCAN_MODE {
+	NRC_SCAN_MODE_IDLE = 0,
+	NRC_SCAN_MODE_SCANNING,
+	NRC_SCAN_MODE_ABORTING,
+};
+
+#define NRC_FW_ACTIVE					(0)
+#define NRC_FW_LOADING					(1)
+#define	NRC_FW_PREPARE_SLEEP			(2)
+#define	NRC_FW_SLEEP					(3)
+
+enum NRC_DRV_STATE {
+	NRC_DRV_REBOOT = -2,
+	NRC_DRV_BOOT = -1,
+	NRC_DRV_INIT = 0,
+	NRC_DRV_STOP,
+	NRC_DRV_CLOSING,
+	NRC_DRV_CLOSED,
+	NRC_DRV_START,
+	NRC_DRV_RUNNING,
+	NRC_DRV_PS,
+};
+
+enum NRC_PS_MODE {
+	NRC_PS_NONE,
+	NRC_PS_MODEMSLEEP,
+	NRC_PS_DEEPSLEEP_TIM,
+	NRC_PS_DEEPSLEEP_NONTIM
+};
+
+#ifdef CONFIG_SUPPORT_AFTER_KERNEL_3_0_36
+#else
+enum ieee80211_sta_state {
+	/* NOTE: These need to be ordered correctly! */
+	IEEE80211_STA_NOTEXIST,
+	IEEE80211_STA_NONE,
+	IEEE80211_STA_AUTH,
+	IEEE80211_STA_ASSOC,
+	IEEE80211_STA_AUTHORIZED,
+};
+#endif
+
+enum ieee80211_tx_ba_state {
+	IEEE80211_BA_NONE,
+	IEEE80211_BA_REQUEST,
+	IEEE80211_BA_ACCEPT,
+	IEEE80211_BA_REJECT,
+	IEEE80211_BA_CLOSE,
+	IEEE80211_BA_DISABLE,
+};
+
+struct fwinfo_t {
+	uint32_t ready;
+	uint32_t version;
+	uint32_t tx_head_size;
+	uint32_t rx_head_size;
+	uint32_t payload_align;
+	uint32_t buffer_size;
+	uint16_t hw_version;
+};
+
+struct vif_capabilities {
+	uint64_t cap_mask;
+};
+
+struct nrc_capabilities {
+	uint64_t cap_mask;
+	uint16_t listen_interval;
+	uint16_t bss_max_idle;
+	uint8_t bss_max_idle_options;
+	uint8_t max_vif;
+	struct vif_capabilities vif_caps[NR_NRC_VIF];
+};
+
+#define BSS_MAX_ILDE_DEAUTH_LIMIT_COUNT 3 /* Keep Alive Timeout Limit Count on AP */
+struct nrc_max_idle {
+	bool enable;
+	u16 period;
+	u16 scale_factor;
+	u8 options;
+	u16 timeout_cnt;
+	struct timer_list keep_alive_timer;
+
+	unsigned long idle_period; /* jiffies */
+	struct timer_list timer;
+};
+
+/* Private txq driver data structure */
+struct nrc_txq {
+	u16 hw_queue; /* 0: AC_BK, 1: AC_BE, 2: AC_VI, 3: AC_VO */
+	struct list_head list;
+	struct sk_buff_head queue; /* own queue */
+#ifdef CONFIG_CHECK_DATA_SIZE
+	unsigned int data_size;
+#endif
+	unsigned long nr_fw_queueud;
+	unsigned long nr_push_allowed;
+	struct ieee80211_vif vif;
+	struct ieee80211_sta *sta;
+};
+
+struct nrc_delayed_deauth {
+	atomic_t delayed_deauth;
+	s8 vif_index;
+	u16 aid;
+	bool removed;
+	struct sk_buff *deauth_frm;
+	struct sk_buff *ch_skb;
+	struct ieee80211_vif v;
+	struct ieee80211_sta s;
+	struct ieee80211_key_conf p;
+	struct ieee80211_key_conf g;
+	struct ieee80211_bss_conf b;
+#ifdef CONFIG_SUPPORT_CHANNEL_INFO
+	struct cfg80211_chan_def c;
+	struct ieee80211_channel ch;
+#else
+	struct ieee80211_conf c;
+#endif
+	struct ieee80211_tx_queue_params tqp[NRC_QUEUE_MAX];
+};
+
+struct nrc {
+	struct platform_device *pdev;
+	struct nrc_hif_device *hif;
+
+	struct ieee80211_hw *hw;
+	struct ieee80211_vif *vif[NR_NRC_VIF];
+	int nr_active_vif;
+	bool enable_vif[NR_NRC_VIF];
+	spinlock_t vif_lock;
+	bool promisc;
+#ifdef CONFIG_USE_NEW_BAND_ENUM
+	struct ieee80211_supported_band bands[NUM_NL80211_BANDS];
+#else
+	struct ieee80211_supported_band bands[IEEE80211_NUM_BANDS];
+#endif
+	struct mac_address mac_addr[NR_NRC_VIF];
+
+	int drv_state;
+	atomic_t fw_state;
+	atomic_t fw_tx;
+	atomic_t fw_rx;
+	u64 tsf_offset;
+	u32 sleep_ms;
+	struct nrc_txq ntxq[NRC_QUEUE_MAX];
+
+	struct mutex target_mtx;
+	struct mutex state_mtx;
+	enum NRC_SCAN_MODE scan_mode;
+	struct workqueue_struct *workqueue;
+	struct delayed_work check_start;
+
+	char alpha2[2];
+
+	/* Move to vif or sta driver data */
+	u8 frame_seqno;
+	u8 wim_seqno;
+	u8 band;
+	u16 center_freq;
+	u16 aid;
+	u32 cipher_pairwise;
+	u32 cipher_group;
+
+	struct fwinfo_t fwinfo;
+	struct nrc_capabilities cap;
+
+	/* power management */
+	enum ps_mode {
+		PS_DISABLED,
+		PS_ENABLED,
+		PS_AUTO_POLL,
+		PS_MANUAL_POLL
+	} ps;
+	bool ps_poll_pending;
+	bool ps_enabled;
+	bool ps_drv_state;
+	bool invoke_beacon_loss;
+	struct timer_list dynamic_ps_timer;
+	struct workqueue_struct *ps_wq;
+
+	/* sync power management operation between
+	 * mac80211 config and host interface
+	 */
+	struct completion hif_tx_stopped;
+	struct completion hif_rx_stopped;
+	struct completion hif_irq_stopped;
+	uint32_t vendor_arg;
+
+	struct dentry *debugfs;
+	bool loopback;
+	bool ampdu_supported;
+	int lb_count;
+	bool amsdu_supported;
+	bool block_frame;
+	bool ampdu_reject;
+	bool bd_valid;
+
+	/* tx */
+	spinlock_t txq_lock;
+	struct list_head txq;
+	/* 0: AC_BK, 1: AC_BE, 2: AC_VI, 3: AC_VO */
+	atomic_t tx_credit[IEEE80211_NUM_ACS*3];
+	atomic_t tx_pend[IEEE80211_NUM_ACS*3];
+
+	struct completion wim_responded;
+	struct sk_buff *last_wim_responded;
+
+	/* firmware */
+	struct nrc_fw_priv *fw_priv;
+	struct firmware *fw;
+	bool   has_macaddr[NR_NRC_VIF];
+
+    /* p2p remain on channel */
+	struct delayed_work roc_finish;
+
+	/* beacon interval (AP) */
+	u16 beacon_int;
+	/* vendor specific element (AP) */
+	struct sk_buff *vendor_skb;
+	/* work for removing vendor specific ie for wowlan pattern (AP) */
+	struct delayed_work rm_vendor_ie_wowlan_pattern;
+	/* this must be assigned via nrc_mac_set_wakeup() */
+	bool wowlan_enabled;
+
+	/* CQM offload */
+	struct timer_list bcn_mon_timer;
+	unsigned long beacon_timeout;
+	bool associated;
+
+	/* for processing deauth when deepsleep */
+	struct nrc_delayed_deauth d_deauth;
+
+	/* firmware recovery */
+	struct nrc_recovery_wdt *recovery_wdt;
+};
+
+/* vif driver data structure */
+struct nrc_vif {
+	struct nrc *nw;
+	int index;
+	struct net_device *dev;
+
+	/* scan */
+	struct delayed_work scan_timeout;
+
+	/* power save */
+	bool ps_polling;
+
+	/* MLME */
+	spinlock_t preassoc_sta_lock;
+	struct list_head preassoc_sta_list;
+
+	/* inactivity */
+	u16 max_idle_period;
+
+#ifdef CONFIG_SUPPORT_AFTER_KERNEL_3_0_36
+	/* P2p client NoA */
+	struct ieee80211_noa_data noa;
+#endif
+};
+
+#define to_ieee80211_vif(v) \
+	container_of((void *)v, struct ieee80211_vif, drv_priv)
+
+#define to_i_vif(v) ((struct nrc_vif *) (v)->drv_priv)
+
+static inline int hw_vifindex(struct ieee80211_vif *vif)
+{
+	struct nrc_vif *i_vif;
+
+	if (vif == NULL)
+		return 0;
+
+	i_vif = to_i_vif(vif);
+	return i_vif->index;
+}
+
+/* sta driver data structure */
+struct nrc_sta {
+	struct nrc *nw;
+	struct ieee80211_vif *vif;
+	/*struct ieee80211_sta *sta;*/
+
+	enum ieee80211_sta_state state;
+	struct list_head list;
+
+	/* keys */
+	struct ieee80211_key_conf *ptk;
+	struct ieee80211_key_conf *gtk;
+
+	/* BSS max idle period */
+	struct nrc_capabilities cap;
+	struct nrc_max_idle max_idle;
+
+	/* Block Ack Session per TID */
+	enum ieee80211_tx_ba_state tx_ba_session[NRC_MAX_TID];
+	uint32_t ba_req_last_jiffies[NRC_MAX_TID];
+};
+
+#define to_ieee80211_sta(s) \
+	container_of((void *)s, struct ieee80211_sta, drv_priv)
+
+#define to_i_sta(s) ((struct nrc_sta *) (s)->drv_priv)
+
+struct nrc_sta_handler {
+	int (*sta_state)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+			 struct ieee80211_sta *sta,
+			 enum ieee80211_sta_state old_state,
+			 enum ieee80211_sta_state new_state);
+
+};
+
+#define STAH(fn)					\
+	static struct nrc_sta_handler __stah_ ## fn	\
+	__attribute((__used__))				\
+	__attribute((__section__("nrc.sta"))) = {	\
+		.sta_state = fn,			\
+	}
+
+extern struct nrc_sta_handler __sta_h_start, __sta_h_end;
+
+/* trx */
+
+struct nrc_trx_data {
+	struct nrc *nw;
+	struct ieee80211_vif *vif;
+	struct ieee80211_sta *sta;
+	struct sk_buff *skb;
+	int result;
+};
+
+struct nrc_trx_handler {
+	struct list_head list;
+	int (*handler)(struct nrc_trx_data *data);
+	bool need_sta;
+	u32 vif_types;
+};
+
+#define TXH(fn, mask)					\
+	static struct nrc_trx_handler __txh_ ## fn	\
+	__attribute((__used__))				\
+	__attribute((__section__("nrc.txh"))) = {	\
+		.handler = fn,				\
+		.vif_types = mask,			\
+	}
+
+#define RXH(fn, mask)					\
+	static struct nrc_trx_handler __rxh_ ## fn	\
+	__attribute((__used__))				\
+	__attribute((__section__("nrc.rxh"))) = {	\
+		.handler = fn,				\
+		.vif_types = mask,			\
+	}
+
+extern struct nrc_trx_handler __tx_h_start, __tx_h_end;
+extern struct nrc_trx_handler __rx_h_start, __rx_h_end;
+
+
+#define NL80211_IFTYPE_ALL (BIT(NUM_NL80211_IFTYPES)-1)
+
+/* radio tap */
+struct nrc_radiotap_hdr {
+	struct ieee80211_radiotap_header hdr;
+	uint64_t rt_tsft;		/* IEEE80211_RADIOTAP_TSFT */
+	uint8_t  rt_flags;		/* IEEE80211_RADIOTAP_FLAGS */
+	uint8_t  rt_pad;		/* pad for IEEE80211_RADIOTAP_CHANNEL */
+	uint16_t rt_ch_frequency;	/* IEEE80211_RADIOTAP_CHANNEL */
+	uint16_t rt_ch_flags;
+	uint16_t rt_pad2;		/* pad for IEEE80211_RADIOTAP_TLV:S1G */
+	uint16_t rt_tlv_type;	/* IEEE80211_RADIOTAP_TLV */
+	uint16_t rt_tlv_length;
+	uint16_t rt_s1g_known;
+	uint16_t rt_s1g_data1;
+	uint16_t rt_s1g_data2;
+} __packed;
+
+struct nrc_radiotap_hdr_agg {
+	struct ieee80211_radiotap_header hdr;
+	uint64_t rt_tsft;		/* IEEE80211_RADIOTAP_TSFT */
+	uint8_t  rt_flags;		/* IEEE80211_RADIOTAP_FLAGS */
+	uint8_t  rt_pad;		/* pad for IEEE80211_RADIOTAP_CHANNEL */
+	uint16_t rt_ch_frequency; /* IEEE80211_RADIOTAP_CHANNEL */
+	uint16_t rt_ch_flags;
+	/* pad for IEEE80211_RADIOTAP_AMPDU_STATUS */
+	uint16_t rt_pad2;
+	uint32_t rt_ampdu_ref;	/* IEEE80211_RADIOTAP_AMPDU_STATUS */
+	uint16_t rt_ampdu_flags;
+	uint8_t  rt_ampdu_crc;
+	uint8_t  rt_ampdu_reserved;
+	uint16_t rt_tlv_type;	/* IEEE80211_RADIOTAP_TLV */
+	uint16_t rt_tlv_length;
+	uint16_t rt_s1g_known;
+	uint16_t rt_s1g_data1;
+	uint16_t rt_s1g_data2;
+} __packed;
+
+struct nrc_radiotap_hdr_ndp {
+	struct ieee80211_radiotap_header hdr;
+	uint64_t rt_tsft;		/* IEEE80211_RADIOTAP_TSFT */
+	uint8_t  rt_flags;		/* IEEE80211_RADIOTAP_FLAGS */
+	uint8_t  rt_pad;		/* pad for IEEE80211_RADIOTAP_CHANNEL */
+	uint16_t rt_ch_frequency;	/* IEEE80211_RADIOTAP_CHANNEL */
+	uint16_t rt_ch_flags;
+	uint8_t  rt_zero_length_psdu; /* IEEE80211_RADIOTAP_0_LENGTH_PSDU */
+} __packed;
+
+struct nrc_local_radiotap_hdr {
+	struct ieee80211_radiotap_header hdr;
+	__le64 rt_tsft;
+	u8 rt_flags;
+	u8 rt_rate;
+	__le16 rt_channel;
+	__le16 rt_chbitmask;
+} __packed;
+
+/* Module parameters */
+extern char *hifport;
+extern int hifspeed;
+extern int spi_bus_num;
+extern int spi_cs_num;
+extern int spi_gpio_irq;
+extern int spi_polling_interval;
+extern int spi_gdma_irq;
+extern int disable_cqm;
+extern int bss_max_idle_offset;
+extern int power_save;
+extern int sleep_duration[];
+extern bool wlantest;
+extern bool ndp_preq;
+extern bool ndp_ack_1m;
+extern bool enable_hspi_init;
+extern bool nullfunc_enable;
+extern bool auto_ba;
+extern bool sw_enc;
+extern bool signal_monitor;
+extern bool enable_usn;
+extern bool debug_level_all;
+extern bool enable_short_bi;
+extern int credit_ac_be;
+extern bool discard_deauth;
+extern bool enable_legacy_ack;
+#if defined(CONFIG_SUPPORT_BD)
+extern char *bd_name;
+#endif /* CONFIG_SUPPORT_BD */
+extern int beacon_loss_count;
+
+void nrc_set_bss_max_idle_offset(int value);
+void nrc_set_auto_ba(bool toggle);
+#endif
diff --git a/drivers/staging/nrc/nrc.lds b/drivers/staging/nrc/nrc.lds
new file mode 100644
index 000000000000..f3e9d0e22925
--- /dev/null
+++ b/drivers/staging/nrc/nrc.lds
@@ -0,0 +1,16 @@
+SECTIONS
+{
+	.handlers : {
+		__tx_h_start = . ;
+		*(nrc.txh) ;
+		__tx_h_end = . ;
+
+		__rx_h_start = . ;
+		*(nrc.rxh) ;
+		__rx_h_end = . ;
+
+		__sta_h_start = . ;
+		*(nrc.sta) ;
+		__sta_h_end = . ; 
+	}
+}
diff --git a/drivers/staging/nrc/wim.c b/drivers/staging/nrc/wim.c
new file mode 100644
index 000000000000..cba74860f68d
--- /dev/null
+++ b/drivers/staging/nrc/wim.c
@@ -0,0 +1,752 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <net/mac80211.h>
+#include "nrc.h"
+#include "wim.h"
+#include "nrc-hif.h"
+#include "nrc-fw.h"
+#include "nrc-recovery.h"
+#include "nrc-mac80211.h"
+
+#if defined(CONFIG_SUPPORT_BD)
+#include "nrc-bd.h"
+#endif /* defined(CONFIG_SUPPORT_BD) */
+
+static void nrc_wim_skb_bind_vif(struct sk_buff *skb, struct ieee80211_vif *vif)
+{
+	struct ieee80211_tx_info *txi = IEEE80211_SKB_CB(skb);
+
+	txi->control.vif = vif;
+}
+
+
+struct sk_buff *nrc_wim_alloc_skb(struct nrc *nw, u16 cmd, int size)
+{
+	struct sk_buff *skb;
+	struct wim *wim;
+
+	skb = dev_alloc_skb(size + sizeof(struct hif) + sizeof(struct wim));
+	if (!skb)
+		return NULL;
+
+	/* Increase the headroom */
+	skb_reserve(skb, sizeof(struct hif));
+
+	/* Put wim header */
+	wim = (struct wim *)skb_put(skb, sizeof(*wim));
+	memset(wim, 0, sizeof(*wim));
+	wim->cmd = cmd;
+	wim->seqno = nw->wim_seqno++;
+
+	nrc_wim_skb_bind_vif(skb, NULL);
+
+	return skb;
+}
+
+struct sk_buff *nrc_wim_alloc_skb_vif(struct nrc *nw, struct ieee80211_vif *vif,
+				      u16 cmd, int size)
+{
+	struct sk_buff *skb;
+
+	skb = nrc_wim_alloc_skb(nw, cmd, size);
+	if (!skb)
+		return NULL;
+
+	nrc_wim_skb_bind_vif(skb, vif);
+
+	return skb;
+}
+
+int nrc_xmit_wim_simple_request(struct nrc *nw, int cmd)
+{
+	struct sk_buff *skb = nrc_wim_alloc_skb(nw, cmd, 0);
+
+	return nrc_xmit_wim_request(nw, skb);
+}
+
+struct sk_buff *nrc_xmit_wim_simple_request_wait(struct nrc *nw, int cmd,
+		int timeout)
+{
+	struct sk_buff *skb = nrc_wim_alloc_skb(nw, cmd, 0);
+
+	return nrc_xmit_wim_request_wait(nw, skb, timeout);
+}
+
+static void wim_set_tlv(struct wim_tlv *tlv, u16 t, u16 l)
+{
+	tlv->t = t;
+	tlv->l = l;
+}
+
+void *nrc_wim_skb_add_tlv(struct sk_buff *skb, u16 T, u16 L, void *V)
+{
+	struct wim_tlv *tlv;
+
+	if (L == 0) {
+		tlv = (struct wim_tlv *)(skb_put(skb, sizeof(struct wim_tlv)));
+		wim_set_tlv(tlv, T, L);
+		return (void *)skb->data;
+	}
+
+	tlv = (struct wim_tlv *)(skb_put(skb, tlv_len(L)));
+	wim_set_tlv(tlv, T, L);
+
+	if (V)
+		memcpy(tlv->v, V, L);
+
+	return (void *)tlv->v;
+}
+
+void nrc_wim_set_aid(struct nrc *nw, struct sk_buff *skb, u16 aid)
+{
+	nrc_wim_skb_add_tlv(skb, WIM_TLV_AID, sizeof(u16), &aid);
+}
+
+void nrc_wim_add_mac_addr(struct nrc *nw, struct sk_buff *skb, u8 *addr)
+{
+	nrc_wim_skb_add_tlv(skb, WIM_TLV_MACADDR, ETH_ALEN, addr);
+}
+
+void nrc_wim_set_bssid(struct nrc *nw, struct sk_buff *skb, u8 *bssid)
+{
+	nrc_wim_skb_add_tlv(skb, WIM_TLV_BSSID, ETH_ALEN, bssid);
+}
+
+void nrc_wim_set_ndp_preq(struct nrc *nw, struct sk_buff *skb, u8 enable)
+{
+	nrc_wim_skb_add_tlv(skb, WIM_TLV_NDP_PREQ, sizeof(u8), &enable);
+}
+
+void nrc_wim_set_legacy_ack(struct nrc *nw, struct sk_buff *skb, u8 enable)
+{
+	nrc_wim_skb_add_tlv(skb, WIM_TLV_LEGACY_ACK, sizeof(u8), &enable);
+}
+
+int nrc_wim_change_sta(struct nrc *nw, struct ieee80211_vif *vif,
+		       struct ieee80211_sta *sta, u8 cmd, bool sleep)
+{
+	struct sk_buff *skb;
+	struct wim_sta_param *p;
+
+	if (!sta)
+		return -EINVAL;
+
+	skb = nrc_wim_alloc_skb_vif(nw, vif, WIM_CMD_STA_CMD,
+				    tlv_len(sizeof(*p)));
+
+	p = nrc_wim_skb_add_tlv(skb, WIM_TLV_STA_PARAM, sizeof(*p), NULL);
+	memset(p, 0, sizeof(*p));
+
+	p->cmd = cmd;
+	p->flags = 0;
+	p->sleep = sleep;
+	ether_addr_copy(p->addr, sta->addr);
+	p->aid = sta->aid;
+
+	return nrc_xmit_wim_request(nw, skb);
+}
+
+int nrc_wim_hw_scan(struct nrc *nw, struct ieee80211_vif *vif,
+		    struct cfg80211_scan_request *req,
+		    struct ieee80211_scan_ies *ies)
+{
+	struct sk_buff *skb;
+	struct wim_scan_param *p;
+	int i, size = tlv_len(sizeof(struct wim_scan_param));
+#if defined(CONFIG_SUPPORT_BD)
+	int j;
+	bool avail_ch_flag = false;
+#endif /* defined(CONFIG_SUPPORT_BD) */
+	if (ies) {
+		size += tlv_len(ies->common_ie_len);
+		size += ies->len[NL80211_BAND_2GHZ];
+		size += ies->len[NL80211_BAND_5GHZ];
+	} else {
+		size += tlv_len(req->ie_len);
+	}
+
+	skb = nrc_wim_alloc_skb_vif(nw, vif, WIM_CMD_SCAN_START, size);
+
+	/* WIM_TL_SCAN_PARAM */
+	p = nrc_wim_skb_add_tlv(skb, WIM_TLV_SCAN_PARAM, sizeof(*p), NULL);
+	memset(p, 0, sizeof(*p));
+
+	if (WARN_ON(req->n_channels > WIM_MAX_SCAN_CHANNEL))
+		req->n_channels = WIM_MAX_SCAN_CHANNEL;
+
+	p->n_channels = req->n_channels;
+	for (i = 0; i < req->n_channels; i++)
+		p->channel[i] = req->channels[i]->center_freq;
+#if defined(CONFIG_SUPPORT_BD)
+#if BD_DEBUG
+	nrc_dbg(NRC_DBG_MAC, "org_ch_freq");
+	for (i = 0; i < p->n_channels; i++) {
+		nrc_dbg(NRC_DBG_MAC, "%u", p->channel[i]);
+	}
+#endif
+
+	if(g_supp_ch_list.num_ch) {
+		for (i = 0; i < req->n_channels; i++) {
+			for(j=0; j< g_supp_ch_list.num_ch; j++) {
+				if(p->channel[i] == g_supp_ch_list.nons1g_ch_freq[j])
+					avail_ch_flag = true;
+			}
+			if(!avail_ch_flag) {
+				p->n_channels--;
+				p->channel[i] = 0;
+			} else
+				avail_ch_flag = false;
+		}
+
+		j = 0;
+		for (i = 0; i < req->n_channels; i++) {
+			if(p->channel[i]) {
+				p->channel[j] = req->channels[i]->center_freq;
+				j++;
+			}
+		}
+#if BD_DEBUG	
+		nrc_dbg(NRC_DBG_MAC, "%s: org_num_ch %u  num_ch %u", __func__,
+			req->n_channels,
+			p->n_channels);
+
+		nrc_dbg(NRC_DBG_MAC, "mod_ch_freq");
+		for (i = 0; i < p->n_channels; i++) {
+			nrc_dbg(NRC_DBG_MAC, "%u", p->channel[i]);
+		}
+#endif
+	}
+#endif /* defined(CONFIG_SUPPORT_BD) */
+
+	p->n_ssids = req->n_ssids;
+	for (i = 0; i < req->n_ssids; i++) {
+		p->ssid[i].ssid_len = req->ssids[i].ssid_len;
+		memcpy(p->ssid[i].ssid, req->ssids[i].ssid,
+				req->ssids[i].ssid_len);
+	}
+
+	if (ies) {
+		u8 *p;
+		int b;
+
+		p = nrc_wim_skb_add_tlv(skb,
+					WIM_TLV_SCAN_PROBE_REQ_IE,
+					ies->common_ie_len +
+					ies->len[NL80211_BAND_2GHZ] +
+					ies->len[NL80211_BAND_5GHZ],
+					NULL);
+
+		for (b = NL80211_BAND_2GHZ; b < ARRAY_SIZE(ies->ies); b++)
+			if (ies->ies[b] && ies->len[b] > 0) {
+				memcpy(p, ies->ies[b], ies->len[b]);
+				p += ies->len[b];
+			}
+
+		if (ies->common_ies && ies->common_ie_len > 0) {
+			memcpy(p, ies->common_ies, ies->common_ie_len);
+			p += ies->common_ie_len;
+		}
+
+	} else if (req->ie)
+		nrc_wim_skb_add_tlv(skb,
+				    WIM_TLV_SCAN_PROBE_REQ_IE,
+				    req->ie_len,
+				    (void *)req->ie);
+
+	return nrc_xmit_wim_request(nw, skb);
+}
+
+static char *ieee80211_cipher_str(u32 cipher)
+{
+	switch (cipher) {
+	case WLAN_CIPHER_SUITE_WEP40:
+		return "WEP40";
+	case WLAN_CIPHER_SUITE_WEP104:
+		return "WEP104";
+	case WLAN_CIPHER_SUITE_TKIP:
+		return "TKIP";
+	case WLAN_CIPHER_SUITE_CCMP:
+		return "CCMP";
+	default:
+		return NULL;
+	}
+};
+
+enum wim_cipher_type nrc_to_wim_cipher_type(u32 cipher)
+{
+	switch (cipher) {
+	case WLAN_CIPHER_SUITE_WEP40:
+		return WIM_CIPHER_TYPE_WEP40;
+	case WLAN_CIPHER_SUITE_WEP104:
+		return WIM_CIPHER_TYPE_WEP104;
+	case WLAN_CIPHER_SUITE_TKIP:
+		return WIM_CIPHER_TYPE_TKIP;
+	case WLAN_CIPHER_SUITE_CCMP:
+		return WIM_CIPHER_TYPE_CCMP;
+	case WLAN_CIPHER_SUITE_AES_CMAC:
+	case WLAN_CIPHER_SUITE_BIP_GMAC_128:
+	case WLAN_CIPHER_SUITE_BIP_GMAC_256:
+		return WIM_CIPHER_TYPE_NONE;
+	default:
+		return WIM_CIPHER_TYPE_INVALID;
+	}
+}
+
+u32 nrc_to_ieee80211_cipher(enum wim_cipher_type cipher)
+{
+	switch (cipher) {
+	case WIM_CIPHER_TYPE_WEP40:
+		return WLAN_CIPHER_SUITE_WEP40;
+	case WIM_CIPHER_TYPE_WEP104:
+		return WLAN_CIPHER_SUITE_WEP104;
+	case WIM_CIPHER_TYPE_TKIP:
+		return WLAN_CIPHER_SUITE_TKIP;
+	case WIM_CIPHER_TYPE_CCMP:
+		return WLAN_CIPHER_SUITE_TKIP;
+	default:
+		return -1;
+	}
+}
+
+int nrc_wim_install_key(struct nrc *nw, enum set_key_cmd cmd,
+			struct ieee80211_vif *vif,
+			struct ieee80211_sta *sta,
+			struct ieee80211_key_conf *key)
+{
+	struct sk_buff *skb;
+	struct wim_key_param *p;
+	u8 cipher;
+	const u8 *addr;
+	u16 aid = 0;
+
+	cipher = nrc_to_wim_cipher_type(key->cipher);
+	if (cipher == -1)
+		return -ENOTSUPP;
+
+	if (key->keyidx > WIM_KEY_MAX_INDEX)
+		return -EINVAL;
+
+	nrc_dbg(NRC_DBG_MAC, "%s: cmd=%s, key=(%s,%s,%d)\n", __func__,
+		(cmd == SET_KEY) ? "install" : "delete",
+		(key->flags & IEEE80211_KEY_FLAG_PAIRWISE) ? "PTK" : "GTK",
+		ieee80211_cipher_str(key->cipher),
+		key->keyidx);
+
+	skb = nrc_wim_alloc_skb_vif(nw, vif, WIM_CMD_SET_KEY + (cmd - SET_KEY),
+				tlv_len(sizeof(*p)));
+
+	p = nrc_wim_skb_add_tlv(skb, WIM_TLV_KEY_PARAM, sizeof(*p), NULL);
+
+	memset(p, 0, sizeof(*p));
+
+	if (sta) {
+		addr = sta->addr;
+	} else if (vif->type == NL80211_IFTYPE_AP
+			|| vif->type == NL80211_IFTYPE_MESH_POINT
+			|| vif->type == NL80211_IFTYPE_P2P_GO) {
+		addr = vif->addr;
+	} else {
+		addr = vif->bss_conf.bssid;
+	}
+
+	if (key->flags & IEEE80211_KEY_FLAG_PAIRWISE) {
+		if (!((vif->type == NL80211_IFTYPE_AP)
+				|| (vif->type == NL80211_IFTYPE_MESH_POINT)
+				|| (vif->type == NL80211_IFTYPE_P2P_GO)))
+			aid = vif->bss_conf.aid;
+		else if (sta)
+			aid = sta->aid;
+	} else
+		aid = 0;
+
+	ether_addr_copy(p->mac_addr, addr);
+	p->aid = aid;
+	memcpy(p->key, key->key, key->keylen);
+	p->cipher_type = cipher;
+	p->key_index = key->keyidx;
+	p->key_len = key->keylen;
+	p->key_flags = (key->flags & IEEE80211_KEY_FLAG_PAIRWISE) ?
+		WIM_KEY_FLAG_PAIRWISE : WIM_KEY_FLAG_GROUP;
+
+	nrc_dbg(NRC_DBG_MAC, "%s: cmd=%s, key=(%s,%s,%d), aid=%d\n", __func__,
+		(cmd == SET_KEY) ? "install" : "delete",
+		(key->flags & IEEE80211_KEY_FLAG_PAIRWISE) ? "PTK" : "GTK",
+		ieee80211_cipher_str(key->cipher),
+		key->keyidx,
+		p->aid);
+
+
+	return nrc_xmit_wim_request(nw, skb);
+}
+
+
+static int to_wim_sta_type(enum nl80211_iftype type)
+{
+	int sta_type;
+
+	switch (type) {
+	case NL80211_IFTYPE_STATION:
+		sta_type = WIM_STA_TYPE_STA;
+		break;
+	case NL80211_IFTYPE_AP:
+		sta_type = WIM_STA_TYPE_AP;
+		break;
+	case NL80211_IFTYPE_P2P_GO:
+		sta_type = WIM_STA_TYPE_P2P_GO;
+		break;
+	case NL80211_IFTYPE_P2P_CLIENT:
+		sta_type = WIM_STA_TYPE_P2P_GC;
+		break;
+#ifdef CONFIG_SUPPORT_P2P
+	case NL80211_IFTYPE_P2P_DEVICE:
+		sta_type = WIM_STA_TYPE_P2P_DEVICE;
+		break;
+#endif
+	case NL80211_IFTYPE_MONITOR:
+		sta_type = WIM_STA_TYPE_MONITOR;
+		break;
+	case NL80211_IFTYPE_MESH_POINT:
+		sta_type = WIM_STA_TYPE_MESH_POINT;
+		break;
+	case NL80211_IFTYPE_UNSPECIFIED:
+		sta_type = WIM_STA_TYPE_NONE;
+		break;
+	default:
+		sta_type = -ENOTSUPP;
+		break;
+	}
+
+	return sta_type;
+}
+
+int nrc_wim_set_sta_type(struct nrc *nw, struct ieee80211_vif *vif)
+{
+	struct sk_buff *skb;
+	int sta_type, skb_len;
+
+	if ((nw->vif[0] && nw->vif[1])
+	    || vif->type == NL80211_IFTYPE_MESH_POINT) {
+		sw_enc = 1;
+	}
+
+	sta_type = to_wim_sta_type(ieee80211_iftype_p2p(vif->type, vif->p2p));
+	if (sta_type < 0)
+		return -ENOTSUPP;
+
+	skb_len = tlv_len(sizeof(u32));
+	if (nrc_mac_is_s1g(nw) && sta_type == WIM_STA_TYPE_AP) {
+		skb_len += tlv_len(sizeof(u8));
+	}
+
+	skb = nrc_wim_alloc_skb_vif(nw, vif, WIM_CMD_SET, skb_len);
+
+	nrc_wim_skb_add_tlv(skb, WIM_TLV_STA_TYPE, sizeof(u32), &sta_type);
+	if (nrc_mac_is_s1g(nw) && sta_type == WIM_STA_TYPE_AP) {
+		nrc_wim_skb_add_tlv(skb, WIM_TLV_NDP_ACK_1M, sizeof(u8), &ndp_ack_1m);
+	}
+
+	return nrc_xmit_wim_request(nw, skb);
+}
+
+int nrc_wim_unset_sta_type(struct nrc *nw, struct ieee80211_vif *vif)
+{
+	struct sk_buff *skb;
+	int sta_type;
+
+	sta_type = to_wim_sta_type(NL80211_IFTYPE_UNSPECIFIED);
+	if (sta_type < 0)
+		return -ENOTSUPP;
+
+	skb = nrc_wim_alloc_skb_vif(nw, vif, WIM_CMD_SET, tlv_len(sizeof(u32)));
+
+	nrc_wim_skb_add_tlv(skb, WIM_TLV_STA_TYPE, sizeof(u32), &sta_type);
+
+	return nrc_xmit_wim_request(nw, skb);
+}
+
+static int nrc_wim_set_sta_mac_addr(struct nrc *nw, struct ieee80211_vif *vif,
+				char *addr, bool enable, bool p2p)
+{
+	struct sk_buff *skb;
+	struct wim_addr_param *p;
+
+	skb = nrc_wim_alloc_skb_vif(nw, vif, WIM_CMD_SET, tlv_len(ETH_ALEN));
+
+	p = nrc_wim_skb_add_tlv(skb, WIM_TLV_MACADDR_PARAM, sizeof(*p), NULL);
+	p->enable = enable;
+	p->p2p = p2p;
+	ether_addr_copy(p->addr, addr);
+
+	return nrc_xmit_wim_request(nw, skb);
+}
+int nrc_wim_set_p2p_addr(struct nrc *nw, struct ieee80211_vif *vif)
+{
+	return nrc_wim_set_sta_mac_addr(nw, vif, vif->addr, true, true);
+}
+
+int nrc_wim_set_mac_addr(struct nrc *nw, struct ieee80211_vif *vif)
+{
+	return nrc_wim_set_sta_mac_addr(nw, vif, vif->addr, true, false);
+}
+
+bool nrc_wim_request_keep_alive(struct nrc *nw)
+{
+	int ret;
+
+	ret = nrc_xmit_wim_simple_request(nw, WIM_CMD_KEEP_ALIVE);
+	return (ret == 0);
+}
+
+void nrc_wim_handle_fw_ready(struct nrc *nw)
+{
+	struct nrc_hif_device *hdev = nw->hif;
+
+#if defined(CONFIG_SUPPORT_BD)
+	struct regulatory_request request;
+	request.alpha2[0] = nw->alpha2[0];
+	request.alpha2[1] = nw->alpha2[1];
+#endif
+	nrc_ps_dbg("[%s,L%d]\n", __func__, __LINE__);
+	atomic_set(&nw->fw_state, NRC_FW_ACTIVE);
+	nrc_hif_resume(hdev);
+#if defined(CONFIG_SUPPORT_BD)
+	nrc_reg_notifier(nw->hw->wiphy, &request);
+#endif
+}
+
+#define MAC_ADDR_LEN 6
+void nrc_wim_handle_fw_reload(struct nrc *nw)
+{
+	nrc_ps_dbg("[%s,L%d]\n", __func__, __LINE__);
+	atomic_set(&nw->fw_state, NRC_FW_LOADING);
+	//nrc_recovery_wdt_stop(nw);
+	nrc_hif_cleanup(nw->hif);
+	msleep(200);
+	if (nrc_check_fw_file(nw)) {
+		nrc_download_fw(nw);
+		nw->hif->hif_ops->config(nw->hif);
+		msleep(500);
+		nrc_release_fw(nw);
+	}
+}
+
+void nrc_wim_handle_req_deauth(struct nrc *nw)
+{
+	nrc_ps_dbg("[%s,L%d]\n", __func__, __LINE__);
+
+	if (power_save >= NRC_PS_DEEPSLEEP_TIM)
+		ieee80211_connection_loss(nw->vif[0]);
+}
+
+static int nrc_wim_request_handler(struct nrc *nw,
+				   struct sk_buff *skb)
+{
+	struct wim *wim = (struct wim *)skb->data;
+
+	switch (wim->cmd) {
+	case WIM_CMD_FW_RELOAD:
+		nrc_wim_handle_fw_reload(nw);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int nrc_wim_response_handler(struct nrc *nw,
+				    struct sk_buff *skb)
+{
+	nw->last_wim_responded = skb;
+	if (completion_done(&nw->wim_responded)) {
+	/* No completion waiters, free the SKB */
+		pr_err("no completion");
+		return 0;
+	}
+	complete(&nw->wim_responded);
+	return 1;
+}
+
+#ifdef CONFIG_USE_TXQ
+static int nrc_wim_update_tx_credit(struct nrc *nw, struct wim *wim)
+{
+	struct wim_credit_report *r = (void *)(wim + 1);
+	int ac;
+
+	for (ac = 0; ac < (IEEE80211_NUM_ACS*3); ac++)
+		atomic_set(&nw->tx_credit[ac], r->v.ac[ac]);
+
+#ifdef CONFIG_NRC_HIF_PRINT_FLOW_CONTROL
+	nrc_dbg(NRC_DBG_WIM,
+		"accepted credit ac[0]=%d, ac[1]=%d, ac[2]=%d, ac[3]=%d",
+			(int)atomic_read(&nw->tx_credit[0]),
+			(int)atomic_read(&nw->tx_credit[1]),
+			(int)atomic_read(&nw->tx_credit[2]),
+			(int)atomic_read(&nw->tx_credit[3]));
+	nrc_dbg(NRC_DBG_WIM,
+		"accepted credit ac[6]=%d, ac[7]=%d, ac[8]=%d, ac[9]=%d",
+			(int)atomic_read(&nw->tx_credit[6]),
+			(int)atomic_read(&nw->tx_credit[7]),
+			(int)atomic_read(&nw->tx_credit[8]),
+			(int)atomic_read(&nw->tx_credit[9]));
+#endif
+
+	nrc_kick_txq(nw->hw);
+
+	return 0;
+}
+#endif
+
+static int nrc_wim_event_handler(struct nrc *nw,
+				 struct sk_buff *skb)
+{
+	struct ieee80211_vif *vif = NULL;
+	struct wim *wim = (void *) skb->data;
+	struct hif *hif = (void *)(skb->data - sizeof(*hif));
+	//struct wim_sleep_duration *sleep_duration;
+	//struct sk_buff *ps_skb;
+
+	/* hif->vifindex to vif */
+	if (hif->vifindex != -1)
+		vif = nw->vif[hif->vifindex];
+
+	if ((!atomic_read(&nw->d_deauth.delayed_deauth) && !vif) || 
+		  vif->type == NL80211_IFTYPE_MONITOR) {
+		return 0;
+	}
+
+	switch (wim->event) {
+	case WIM_EVENT_SCAN_COMPLETED:
+		nrc_dbg(NRC_DBG_HIF, "scan completed");
+		nrc_mac_cancel_hw_scan(nw->hw, vif);
+		break;
+	case WIM_EVENT_READY:
+		nrc_wim_handle_fw_ready(nw);
+		break;
+	case WIM_EVENT_CREDIT_REPORT:
+#ifdef CONFIG_USE_TXQ
+		nrc_wim_update_tx_credit(nw, wim);
+#endif
+		break;
+
+	case WIM_EVENT_PS_READY:
+		/* yj.kim 06/03/2020 - It needs to add more procedures when clock is off during modem_sleep
+		*sleep_duration = (void *)(wim + 1);
+		*nw->sleep_ms = sleep_duration->v.sleep_ms;
+		*nrc_ps_dbg("WIM_EVENT_PS_READY:%d ms", nw->sleep_ms);
+		*ps_skb = nrc_wim_alloc_skb_vif(nw, vif,
+		*		   WIM_CMD_SLEEP, WIM_MAX_SIZE);
+		*nrc_wim_skb_add_tlv(ps_skb, WIM_TLV_SLEEP_DURATION,
+		*			sizeof(struct wim_sleep_duration_param),
+		*			&nw->sleep_ms);
+		*nrc_xmit_wim_request(nw, ps_skb);
+		*/ 
+		break;
+
+	case WIM_EVENT_PS_WAKEUP:
+		/* yj.kim 06/03/2020 - It needs to add more procedures when clock is off during modem_sleep
+		* nrc_ps_dbg("WIM_EVENT_PS_WAKEUP");
+		*/
+		//atomic_set(&nw->fw_state, NRC_FW_ACTIVE);
+		break;
+
+	case WIM_EVENT_KEEP_ALIVE:
+		break;
+	case WIM_EVENT_REQ_DEAUTH:
+		nrc_wim_handle_req_deauth(nw);
+		break;
+	case WIM_EVENT_CSA:
+		ieee80211_csa_finish(vif);
+		break;
+	case WIM_EVENT_CH_SWITCH:
+		ieee80211_chswitch_done(vif, true);
+		break;
+	case WIM_EVENT_LBT_ENABLED:
+		if (!enable_usn) {
+			enable_usn = true;
+			nrc_dbg(NRC_DBG_HIF, "lbt enabled");
+		}
+		break;
+	case WIM_EVENT_LBT_DISABLED:
+		if (enable_usn) {
+			enable_usn = false;
+			nrc_dbg(NRC_DBG_HIF, "lbt disabled");
+		}
+		break;
+	}
+
+	return 0;
+}
+
+typedef int (*wim_rx_func)(struct nrc *nw, struct sk_buff *skb);
+
+static wim_rx_func wim_rx_handler[] = {
+	[HIF_WIM_SUB_REQUEST] = nrc_wim_request_handler,
+	[HIF_WIM_SUB_RESPONSE] = nrc_wim_response_handler,
+	[HIF_WIM_SUB_EVENT] = nrc_wim_event_handler,
+};
+
+
+int nrc_wim_rx(struct nrc *nw, struct sk_buff *skb, u8 subtype)
+{
+	int ret;
+
+#if defined(CONFIG_NRC_HIF_PRINT_RX_DATA)
+	skb_push(skb, sizeof(struct hif));
+	nrc_dump_wim(skb);
+	skb_pull(skb, sizeof(struct hif));
+#endif
+
+	ret = wim_rx_handler[subtype](nw, skb);
+
+	if (ret != 1)
+	/* Free the skb later (e.g. on Response WIM handler) */
+		dev_kfree_skb(skb);
+
+	return 0; /* for the time being */
+}
+
+/* to be removed */
+int __nrc_wim_ampdu_action(struct nrc *nw, enum WIM_AMPDU_ACTION action,
+		struct ieee80211_sta *sta, u16 tid)
+{
+	struct sk_buff *skb;
+
+	skb = nrc_wim_alloc_skb(nw, WIM_CMD_AMPDU_ACTION,
+			tlv_len(sizeof(u16)) + tlv_len(ETH_ALEN));
+
+	nrc_wim_skb_add_tlv(skb, WIM_TLV_AMPDU_MODE, sizeof(u16), &action);
+	nrc_wim_add_mac_addr(nw, skb, sta->addr);
+	nrc_wim_skb_add_tlv(skb, WIM_TLV_TID, sizeof(u16), &tid);
+
+	return nrc_xmit_wim_request(nw, skb);
+}
+
+int nrc_wim_ampdu_action(struct nrc *nw, struct ieee80211_vif *vif,
+			enum WIM_AMPDU_ACTION action,
+			struct ieee80211_sta *sta, u16 tid)
+{
+	struct sk_buff *skb;
+
+	skb = nrc_wim_alloc_skb_vif(nw, vif, WIM_CMD_AMPDU_ACTION,
+				tlv_len(sizeof(u16)) + tlv_len(ETH_ALEN));
+
+	nrc_wim_skb_add_tlv(skb, WIM_TLV_AMPDU_MODE, sizeof(u16), &action);
+	nrc_wim_add_mac_addr(nw, skb, sta->addr);
+	nrc_wim_skb_add_tlv(skb, WIM_TLV_TID, sizeof(u16), &tid);
+
+	return nrc_xmit_wim_request(nw, skb);
+}
diff --git a/drivers/staging/nrc/wim.h b/drivers/staging/nrc/wim.h
new file mode 100755
index 000000000000..ada5f0bc6551
--- /dev/null
+++ b/drivers/staging/nrc/wim.h
@@ -0,0 +1,183 @@
+/*
+ * Copyright (c) 2016-2019 Newracom, Inc.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _WIM_H_
+#define _WIM_H_
+
+#include <linux/types.h>
+#include <linux/bitops.h>
+#include <linux/if_ether.h>
+#include <net/mac80211.h>
+#ifdef CONFIG_SUPPORT_AFTER_KERNEL_3_0_36
+#else
+#include "nrc-mac80211.h"
+#endif
+
+#include "nrc-wim-types.h"
+
+struct nrc;
+
+struct wim {
+	union {
+		u16 cmd;
+		u16 resp;
+		u16 event;
+	};
+	u8 seqno;
+	u8 n_tlvs;
+	u8 payload[0];
+} __packed;
+
+struct wim_tlv {
+	u16 t;
+	u16 l;
+	u8  v[0];
+} __packed;
+
+#define tlv_len(l) (sizeof(struct wim_tlv) + (l))
+
+extern void nrc_hif_cleanup(struct nrc_hif_device *dev);
+
+/**
+ * nrc_wim_alloc_skb - allocate a sk_buff for wim message transmission
+ * @nw: pointer to nrc hw
+ * @vif: vif
+ * @cmd: wim command (enum WIM_CMD_ID)
+ * @size: wim payload size in byte (excluding wim header)
+ *
+ * This function allocates a sk_buff,  prepends a wim header, and fills
+ * a couple of wim header fields. A pointer to the allocated sk_buff is
+ * returned.
+ */
+struct sk_buff *nrc_wim_alloc_skb(struct nrc *nw, u16 cmd, int size);
+
+struct sk_buff *nrc_wim_alloc_skb_vif(struct nrc *nw, struct ieee80211_vif *vif,
+				      u16 cmd, int size);
+/**
+ * nrc_xmit_wim_simple_request - sends a wim request with no payload
+ * @nw: pointer to nrc hw
+ * @cmd: wim command to send (enum WIM_CMD_ID)
+ */
+int nrc_xmit_wim_simple_request(struct nrc *nw, int cmd);
+
+/**
+ * nrc_xmit_wim_simple_request_wait - sends a wim request with no payload
+ * and wait for response within given timeout
+ * @nw: pointer to nrc hw
+ * @cmd: wim command to send (enum WIM_CMD_ID)
+ * @timeout: timeout in jiffies
+ */
+struct sk_buff *nrc_xmit_wim_simple_request_wait(struct nrc *nw,
+		int cmd, int timeout);
+
+
+/**
+ * nrc_wim_skb_add_tlv - append a TLV parameter
+ * @skb: buffer to use.
+ * @T: type of the parameter to add.
+ * @L: length of the parameter to add.
+ * @V: value of the parameter.
+ *
+ * This function appends a TLV parameter to @skb. If @V is non-NULL,
+ * @L bytes are copied from the buffer pointed to by it. Ohterwise,
+ * the copy does not take place. A pointer to the first byte of V in
+ * @skb is returned.
+ */
+void *nrc_wim_skb_add_tlv(struct sk_buff *skb, u16 T, u16 L, void *V);
+
+/**
+ * nrc_wim_set_aid - adds AID TLV
+ * @nw: pointer to nrc hw
+ * @skb: sk_buff containing wim set command message.
+ * @aid: AID to be set
+ */
+void nrc_wim_set_aid(struct nrc *nw, struct sk_buff *skb, u16 aid);
+
+/**
+ * nrc_wim_add_mac_addr - adds MACADDR TLV
+ * @nw: pointer to nrc hw
+ * @skb: sk_buff containing wim set command message.
+ * @addr: mac address to set
+ */
+void nrc_wim_add_mac_addr(struct nrc *nw, struct sk_buff *skb, u8 *addr);
+
+/**
+ * nrc_wim_set_bssid - adds BSSID TLV
+ * @nw: pointer to nrc hw
+ * @skb: sk_buff containing wim set command message.
+ * @bssid: bssid to set
+ */
+void nrc_wim_set_bssid(struct nrc *nw, struct sk_buff *skb, u8 *bssid);
+
+/**
+ * nrc_wim_set_ndp_preq - set NDP probe request
+ * @nw: pointer to nrc hw
+ * @skb: sk_buff containing wim set command message.
+ * @bssid: bssid to set
+ */
+void nrc_wim_set_ndp_preq(struct nrc *nw, struct sk_buff *skb, u8 enable);
+
+/**
+ * nrc_wim_set_legacy_ack - set legacy ack mode
+ * @nw: pointer to nrc hw
+ * @skb: sk_buff containing wim set command message.
+ * @enable: enable(1)/disable(0)
+ */
+void nrc_wim_set_legacy_ack(struct nrc *nw, struct sk_buff *skb, u8 enable);
+
+int nrc_wim_change_sta(struct nrc *nw, struct ieee80211_vif *vif,
+		       struct ieee80211_sta *sta, u8 cmd, bool sleep);
+
+int nrc_wim_hw_scan(struct nrc *nw, struct ieee80211_vif *vif,
+		    struct cfg80211_scan_request *req,
+		    struct ieee80211_scan_ies *ies);
+
+int nrc_wim_set_sta_type(struct nrc *nw, struct ieee80211_vif *vif);
+int nrc_wim_unset_sta_type(struct nrc *nw, struct ieee80211_vif *vif);
+int nrc_wim_set_mac_addr(struct nrc *nw, struct ieee80211_vif *vif);
+int nrc_wim_set_p2p_addr(struct nrc *nw, struct ieee80211_vif *vif);
+
+bool nrc_wim_request_keep_alive(struct nrc *nw);
+void nrc_wim_handle_fw_request(struct nrc *nw);
+
+enum wim_cipher_type nrc_to_wim_cipher_type(u32 cipher);
+u32 nrc_to_ieee80211_cipher(enum wim_cipher_type cipher);
+
+int nrc_wim_install_key(struct nrc *nw, enum set_key_cmd cmd,
+			struct ieee80211_vif *vif,
+			struct ieee80211_sta *sta,
+			struct ieee80211_key_conf *key);
+
+
+int nrc_wim_ampdu_action(struct nrc *nw, struct ieee80211_vif *vif,
+			 enum WIM_AMPDU_ACTION action,
+			 struct ieee80211_sta *sta, u16 tid);
+/**
+ * nrc_wim_rx - handles a received wim message from the target
+ * @nw: pointer to nrc hw.
+ * @skb: received wim message
+ * @subtype: HIF_WIM_SUB_XXX, where XXX is either of REQUEST/RESPONSE/EVENT.
+ *
+ * This function is a callback invoked by HIF receive thread for
+ * incoming WIM message.
+ *
+ * The function returns zero if the received @skb is successfully handled,
+ * and negative value on failure.
+ */
+int nrc_wim_rx(struct nrc *nw, struct sk_buff *skb, u8 subtype);
+int nrc_wim_pm_req(struct nrc *nw, uint32_t cmd, uint64_t arg);
+
+#endif
-- 
2.40.1

